
\chapter{Examples}

\section{Tuning of applications}

Tone\_curveを対象に，チューニング方法を例示する．

\begin{figure}[htbp]
\center
\includegraphics[angle=270,origin=b,width=0.49\textwidth]{tone_curve.eps}
\includegraphics[angle=270,origin=b,width=0.46\textwidth]{tone1.eps}
\caption{Tone curve}
\end{figure}

\subsection{Cによるアルゴリズムの記述}

\begin{screen}
\footnotesize
\begin{verbatim}
/* CPU */
for (row=0; row<HT; row++) {
  for (col=0; col<WD; col++) {
    Uint pix = hin[row*WD+col];
    hout0[row*WD+col]
      = ((ht)[pix>>24])<<24 | (ht[256+((pix>>16)&255)])<<16 | (ht[512+((pix>>8)&255)])<<8;
  }
}
\end{verbatim}
\end{screen}

\subsection{CUDAによるアルゴリズムの記述}

\begin{screen}
\scriptsize
\begin{verbatim}
/* GPU */
if (cudaSuccess != cudaMemcpy(din, hin, sizeof(Uint)*WD*HT, cudaMemcpyHostToDevice))
  { printf("can't cudaMemcpy\n"); exit(1); }
if (cudaSuccess != cudaMemcpy(dt, ht, sizeof(Uint)*256*3, cudaMemcpyHostToDevice))
  { printf("can't cudaMemcpy\n"); exit(1); }
dim3 Thread  = dim3(THREADX, THREADY, 1);
dim3 Block   = dim3(BLOCKX, BLOCKY, 1);
tone_curve<<<Block,Thread>>>(dout, din, dt); /* search triangle in {frontier,next} */
if (cudaSuccess != cudaMemcpy(hout1, dout, sizeof(Uint)*WD*HT, cudaMemcpyDeviceToHost))
  { printf("can't cudaMemcpy\n"); exit(1); }
__global__ void tone_curve(Uint *out, Uint *in, Uchar *t)
{
  int row, col;
  row = blockIdx.y*blockDim.y + threadIdx.y;
  col = blockIdx.x*blockDim.x + threadIdx.x;
  Uint pix = in[row*WD+col];
  out[row*WD+col] = ((t)[pix>>24])<<24 | (t[256+((pix>>16)&255)])<<16 | (t[512+((pix>>8)&255)])<<8;
  __syncthreads();
}
\end{verbatim}
\end{screen}

\clearpage

\subsection{IMAX向けC言語記述（毎サイクル１画素を出力）}

\begin{screen}
\scriptsize
\begin{verbatim}
void tone_curve(r, d, t)
     unsigned int *r, *d;
     unsigned char *t;
{
  Ull  t1 = t;
  Ull  t2 = t+256;
  Ull  t3 = t+512;
  Ull  BR[16][4][4]; /* output registers in each unit */
  Ull  r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15,
       r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31;
  int loop=WD;
//EMAX5A begin tone_curve mapdist=0
  while (loop--) {
    mop(OP_LDWR,  1, &BR[0][1][1], (Ull)(r++), 0LL,         MSK_D0, (Ull)r, 320, 0,0, (Ull)NULL, 320);/* stage#0 */
    mop(OP_LDBR,  1, &BR[1][1][1], (Ull)t1,    BR[0][1][1], MSK_B3, (Ull)t1, 64, 0,0, (Ull)NULL, 64); /* stage#1 */
    mop(OP_LDBR,  1, &BR[1][2][1], (Ull)t2,    BR[0][1][1], MSK_B2, (Ull)t2, 64, 0,0, (Ull)NULL, 64); /* stage#1 */
    mop(OP_LDBR,  1, &BR[1][3][1], (Ull)t3,    BR[0][1][1], MSK_B1, (Ull)t3, 64, 0,0, (Ull)NULL, 64); /* stage#1 */
    exe(OP_MMRG, &r1, BR[1][1][1], EXP_H3210,  BR[1][2][1], EXP_H3210, BR[1][3][1], EXP_H3210, OP_NOP, 0, OP_NOP, 0);
    mop(OP_STWR,  3, &r1,          (Ull)(d++), 0LL,         MSK_D0, (Ull)d, 320, 0,0, (Ull)NULL, 320);/* stage#2 */
  }
//EMAX5A end
}
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\includegraphics[angle=270,origin=b,width=0.98\textwidth]{tone3.eps}
\caption{Tone curve 1 pixel per cycle}
\end{figure}

\clearpage

\subsection{IMAX向けC言語記述（毎サイクル２画素を出力）}

\begin{figure}[htbp]
\center
\includegraphics[angle=270,origin=b,width=0.70\textwidth]{tone2.eps}
\caption{Dual tone curve}
\end{figure}

\begin{screen}
\scriptsize
\begin{verbatim}
void tone_curve(r, d, t)
     unsigned int *r, *d;
     unsigned char *t;
{
  Ull  t1 = t;
  Ull  t2 = t+256;
  Ull  t3 = t+512;
  Ull  BR[16][4][4]; /* output registers in each unit */
  Ull  r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, , r31;
  int loop=WD/2;
//EMAX5A begin tone_curve mapdist=0
  while (loop--) {
    mop(OP_LDR,   1, &BR[0][1][1], (Ull)(rr++), 0LL,        MSK_D0, (Ull)r, 320,  0,  0, (Ull)NULL,320);   /* stage#0 */
    mop(OP_LDBR,  1, &BR[1][1][1], (Ull)t1,    BR[0][1][1], MSK_B3, (Ull)t1, 64,  0,  0, (Ull)NULL, 64);   /* stage#1 */
    mop(OP_LDBR,  1, &BR[1][1][0], (Ull)t1,    BR[0][1][1], MSK_B7, (Ull)t1, 64,  0,  0, (Ull)NULL, 64);   /* stage#1 */
    mop(OP_LDBR,  1, &BR[1][2][1], (Ull)t2,    BR[0][1][1], MSK_B2, (Ull)t2, 64,  0,  0, (Ull)NULL, 64);   /* stage#1 */
    mop(OP_LDBR,  1, &BR[1][2][0], (Ull)t2,    BR[0][1][1], MSK_B6, (Ull)t2, 64,  0,  0, (Ull)NULL, 64);   /* stage#1 */
    mop(OP_LDBR,  1, &BR[1][3][1], (Ull)t3,    BR[0][1][1], MSK_B1, (Ull)t3, 64,  0,  0, (Ull)NULL, 64);   /* stage#1 */
    mop(OP_LDBR,  1, &BR[1][3][0], (Ull)t3,    BR[0][1][1], MSK_B5, (Ull)t3, 64,  0,  0, (Ull)NULL, 64);   /* stage#1 */
    exe(OP_CCAT,  &r1, BR[1][1][0], EXP_H3210, BR[1][1][1], EXP_H3210,        0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);
    exe(OP_CCAT,  &r2, BR[1][2][0], EXP_H3210, BR[1][2][1], EXP_H3210,        0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);
    exe(OP_CCAT,  &r3, BR[1][3][0], EXP_H3210, BR[1][3][1], EXP_H3210,        0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);
    exe(OP_MMRG,  &r0,          r1, EXP_H3210, r2, EXP_H3210, r3, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);
    mop(OP_STR,   3, &r0,          (Ull)(dd++), 0LL,        MSK_D0, (Ull)d, 320,  0,  0, (Ull)NULL,320);   /* stage#2 */
  }
//EMAX5A end
}
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\includegraphics[angle=270,origin=b,width=0.96\textwidth]{tone4.eps}
\caption{Tone curve 2 pixels per cycle}
\end{figure}

\clearpage

\subsection{IMAX向けC言語記述（複数段利用，２重ループ一括実行，マルチチップ実行）}

\begin{screen}
\scriptsize
\begin{verbatim}
void tone_curve(Uint *r, Uint *d, Uchar *t) /* R, D, lut */
{
#define NCHIP     1
#define RMGRP     6
#define OMAP     10
#define PAD       0
#define RRANGE   ((HT-PAD*2)/NCHIP/OMAP)
  int i;
  for(i=0; i<256; i++) {
    t[i+  0] = 0xff-i;
    t[i+256] = 0xff-i;
    t[i+512] = 0xff-i;
  }
  Ull  top, rofs, cofs, oc, pofs;
  Ull  t1 = t;
  Ull  t2 = t+256;
  Ull  t3 = t+512;
  Ull  CHIP;
  Ull  LOOP1, LOOP0;
  Ull  INIT1, INIT0;
  Ull  AR[64][4];                     /* output of EX     in each unit */
  Ull  BR[64][4][4];                  /* output registers in each unit */
  Ull  r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15;
  Ull  r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31;
  Ull  cc0, cc1, cc2, cc3, ex0, ex1;
  for (top=0; top<RRANGE; top+=RMGRP) {
    Ull  rtop0[NCHIP], dtop0[NCHIP];
    Ull  rtop1[NCHIP], dtop1[NCHIP];
    Ull  rtop2[NCHIP], dtop2[NCHIP];
    Ull  rtop3[NCHIP], dtop3[NCHIP];
    Ull  rtop4[NCHIP], dtop4[NCHIP];
    Ull  rtop5[NCHIP], dtop5[NCHIP];
    Ull  rtop6[NCHIP], dtop6[NCHIP];
    Ull  rtop7[NCHIP], dtop7[NCHIP];
    Ull  rtop8[NCHIP], dtop8[NCHIP];
    Ull  rtop9[NCHIP], dtop9[NCHIP];
    for (CHIP=0; CHIP<NCHIP; CHIP++) { /* output channels are parallelized by multi-chip (OC/#chip) */
      rtop0[CHIP] = r+(CHIP*RRANGE*OMAP+RRANGE*0+top)*WD; dtop0[CHIP] = d+(CHIP*RRANGE*OMAP+RRANGE*0+top)*WD;
      rtop1[CHIP] = r+(CHIP*RRANGE*OMAP+RRANGE*1+top)*WD; dtop1[CHIP] = d+(CHIP*RRANGE*OMAP+RRANGE*1+top)*WD;
      rtop2[CHIP] = r+(CHIP*RRANGE*OMAP+RRANGE*2+top)*WD; dtop2[CHIP] = d+(CHIP*RRANGE*OMAP+RRANGE*2+top)*WD;
      rtop3[CHIP] = r+(CHIP*RRANGE*OMAP+RRANGE*3+top)*WD; dtop3[CHIP] = d+(CHIP*RRANGE*OMAP+RRANGE*3+top)*WD;
      rtop4[CHIP] = r+(CHIP*RRANGE*OMAP+RRANGE*4+top)*WD; dtop4[CHIP] = d+(CHIP*RRANGE*OMAP+RRANGE*4+top)*WD;
      rtop5[CHIP] = r+(CHIP*RRANGE*OMAP+RRANGE*5+top)*WD; dtop5[CHIP] = d+(CHIP*RRANGE*OMAP+RRANGE*5+top)*WD;
      rtop6[CHIP] = r+(CHIP*RRANGE*OMAP+RRANGE*6+top)*WD; dtop6[CHIP] = d+(CHIP*RRANGE*OMAP+RRANGE*6+top)*WD;
      rtop7[CHIP] = r+(CHIP*RRANGE*OMAP+RRANGE*7+top)*WD; dtop7[CHIP] = d+(CHIP*RRANGE*OMAP+RRANGE*7+top)*WD;
      rtop8[CHIP] = r+(CHIP*RRANGE*OMAP+RRANGE*8+top)*WD; dtop8[CHIP] = d+(CHIP*RRANGE*OMAP+RRANGE*8+top)*WD;
      rtop9[CHIP] = r+(CHIP*RRANGE*OMAP+RRANGE*9+top)*WD; dtop9[CHIP] = d+(CHIP*RRANGE*OMAP+RRANGE*9+top)*WD;
    }
//EMAX5A begin tone_curve mapdist=0
    for (CHIP=0; CHIP<NCHIP; CHIP++) { /* output channels are parallelized by multi-chip (OC/#chip) */
/*2*/for (INIT1=1,LOOP1=RMGRP,rofs=0-WD*4; LOOP1--; INIT1=0) {     /* stage#0 *//* mapped to FOR() on BR[63][1][0] */
 /*1*/for (INIT0=1,LOOP0=WD,cofs=0-4; LOOP0--; INIT0=0) {          /* stage#0 *//* mapped to FOR() on BR[63][0][0] */
       exe(OP_ADD,  &cofs, INIT0?cofs:cofs, EXP_H3210, 4, EXP_H3210, 0,EXP_H3210,OP_AND,0x0ffffffffLL,OP_NOP,0);/* s#0*/
       exe(OP_ADD,  &rofs, rofs, EXP_H3210, INIT0?WD*4:0, EXP_H3210, 0,EXP_H3210,OP_NOP,0, OP_NOP, 0);          /* s#0*/
       exe(OP_ADD,  &pofs, rofs, EXP_H3210, cofs, EXP_H3210, 0,EXP_H3210, OP_AND,0x000000ffffffffLL, OP_NOP, 0);/* s#1*/
       /*map0*/
       mop(OP_LDWR, 1, &BR[2][1][1], rtop0[CHIP], pofs,  MSK_D0, rtop0[CHIP], WD*RMGRP,0,0,NULL,WD*RMGRP);      /* s#2*/
       mop(OP_LDBR, 1, &BR[3][1][1], t1,    BR[2][1][1], MSK_B3, t1, 256/4,  0,  0, NULL, 256/4);               /* s#3*/
       mop(OP_LDBR, 1, &BR[3][2][1], t2,    BR[2][1][1], MSK_B2, t2, 256/4,  0,  0, NULL, 256/4);               /* s#3*/
       mop(OP_LDBR, 1, &BR[3][3][1], t3,    BR[2][1][1], MSK_B1, t3, 256/4,  0,  0, NULL, 256/4);               /* s#3*/
       exe(OP_MMRG, &r1,BR[3][1][1], EXP_H3210, BR[3][2][1],EXP_H3210, BR[3][3][1],EXP_H3210,OP_NOP,0,OP_NOP,0);/* s#3*/
       mop(OP_STWR, 3, &r1,          dtop0[CHIP], pofs,  MSK_D0, dtop0[CHIP], WD*RMGRP,0,0,NULL,WD*RMGRP);      /* s#3*/
         :
       /*map9*/
       mop(OP_LDWR, 1, &BR[20][1][1],rtop9[CHIP], pofs,  MSK_D0, rtop9[CHIP], WD*RMGRP,0,0,NULL,WD*RMGRP);      /*s#20*/
       mop(OP_LDBR, 1, &BR[21][1][1],t1,    BR[20][1][1],MSK_B3, t1, 256/4,  0,  0, NULL, 256/4);               /*s#21*/
       mop(OP_LDBR, 1, &BR[21][2][1],t2,    BR[20][1][1],MSK_B2, t2, 256/4,  0,  0, NULL, 256/4);               /*s#21*/
       mop(OP_LDBR, 1, &BR[21][3][1],t3,    BR[20][1][1],MSK_B1, t3, 256/4,  0,  0, NULL, 256/4);               /*s#21*/
       exe(OP_MMRG, &r1,BR[21][1][1],EXP_H3210,BR[21][2][1],EXP_H3210,BR[21][3][1],EXP_H3210,OP_NOP,0,OP_NOP,0);/*s#21*/
       mop(OP_STWR, 3, &r1,          dtop9[CHIP], pofs,  MSK_D0, dtop9[CHIP], WD*RMGRP,0,0,NULL,WD*RMGRP);      /*s#21*/
      }
     }
    }
//EMAX5A end
  }
//EMAX5A drain_dirty_lmm
}
\end{verbatim}
\end{screen}

\clearpage

\section{Basics}

\subsection{FFT}

\shabox{
\leftline{cent\% make -f Makefile-csim.emax6+dma all clean}
\leftline{cent\% ../../src/csim/csim -x fft-csim.emax6+dma 4 4096}
}

\shabox{
\leftline{zynq\% make -f Makefile-zynq.emax6+dma all clean}
\leftline{zynq\% ./fft-zynq.emax6+dma 4 4096}
}

\subsubsection{Simple implementation}

最大8192（LMM=8K*4byte*2=64KB）要素のFFT．なお，IMAXの空き場所に展開すれば，
大容量・高速化可能．

\begin{screen}
\tiny
\begin{verbatim}
printf("<<<ORIG>>>\n");
reset_nanosec();
BlockEnd = 1;
for (BlockSize=2; BlockSize<=NumSamples; BlockSize<<=1) {
  for (i=0; i<NumSamples; i+=BlockSize) {
    for (j=i,n=0; n<BlockEnd; j++,n++) {
      k   = j + BlockEnd;
      idx = n + BlockEnd;
      tr = art[idx]*RealOut[k] - ait[idx]*ImagOut[k];
      ti = art[idx]*ImagOut[k] + ait[idx]*RealOut[k];
      RealOut[k] = RealOut[j] - tr;
      ImagOut[k] = ImagOut[j] - ti;
      RealOut[j] += tr;
      ImagOut[j] += ti;
  } }
  BlockEnd = BlockSize;
}
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
  Ull  CHIP;
  Ull  LOOP1, LOOP0;
  Ull  INIT1, INIT0;
  Ull  AR[64][4];                     /* output of EX     in each unit */
  Ull  BR[64][4][4];                  /* output registers in each unit */
  Ull  r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15;
  Ull  r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31;
  Ull  cc0, cc1, cc2, cc3, ex0, ex1;
  Ull  ar, ai, rok, iok, roj, ioj;
  Ull  tr0, ti0, tr1, ti1, roj1, ioj1;

  printf("<<<IMAX>>> NumSamples=%d (LMM should be >= %dB)\n", NumSamples, NumSamples*4*2);
  reset_nanosec();

#define fft_core0(r) \
          exe(OP_ADD,     &j,         i,        EXP_H3210,  n,       EXP_H3210, 0LL,          EXP_H3210, OP_NOP, 0LL, OP_SLL, 2LL); /* stage#1 */\
          exe(OP_ADD3,    &k,         i,        EXP_H3210,  n,       EXP_H3210, BlockEnd,     EXP_H3210, OP_NOP, 0LL, OP_SLL, 2LL); /* stage#1 */\
          exe(OP_ADD3,    &idx,       0LL,      EXP_H3210,  n,       EXP_H3210, BlockEnd,     EXP_H3210, OP_NOP, 0LL, OP_SLL, 2LL); /* stage#1 */\
          exe(OP_NOP,     &AR[r][0],  0LL,      EXP_H3210,  0LL,     EXP_H3210, 0LL,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#2 [2][0]     */\
          mop(OP_LDWR, 3, &rok,       RealOut,  k,          MSK_D0,  RealOut,   NumSamples,   0, 1,  NULL,  NumSamples);            /* stage#2 RealOut[k] */\
          mop(OP_LDWR, 3, &roj,       j,        RealOut,    MSK_D0,  RealOut,   NumSamples,   0, 1,  NULL,  NumSamples);            /* stage#2 RealOut[j] */\
          exe(OP_NOP,     &AR[r][2],  0LL,      EXP_H3210,  0LL,     EXP_H3210, 0LL,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#2 [2][2]     */\
          mop(OP_LDWR, 3, &iok,       ImagOut,  k,          MSK_D0,  ImagOut,   NumSamples,   0, 1,  NULL,  NumSamples);            /* stage#2 ImagOut[k] */\
          mop(OP_LDWR, 3, &ioj,       j,        ImagOut,    MSK_D0,  ImagOut,   NumSamples,   0, 1,  NULL,  NumSamples)             /* stage#2 ImagOut[j] */
#define fft_core1(r) \
          exe(OP_NOP,     &AR[r][0],  0LL,      EXP_H3210,  0LL,     EXP_H3210, 0LL,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#3 [3][0]     */\
          mop(OP_LDWR, 3, &ar,        art,      idx,        MSK_D0,  art,       NumSamples,   0, 0,  NULL,  NumSamples);            /* stage#3 art[idx]   */\
          exe(OP_NOP,     &AR[r][2],  0LL,      EXP_H3210,  0LL,     EXP_H3210, 0LL,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#3 [3][2]     */\
          mop(OP_LDWR, 3, &ai,        ait,      idx,        MSK_D0,  ait,       NumSamples,   0, 0,  NULL,  NumSamples);            /* stage#3 ait[idx]   */\
          exe(OP_FML,     &tr0,       ar,       EXP_H3210,  rok,     EXP_H3210, 0LL,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#4 */\
          exe(OP_FML,     &ti0,       ar,       EXP_H3210,  iok,     EXP_H3210, 0LL,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#4 */\
          exe(OP_FMS,     &tr1,       tr0,      EXP_H3210,  ai,      EXP_H3210, iok,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#5 */\
          exe(OP_FMA,     &ti1,       ti0,      EXP_H3210,  ai,      EXP_H3210, rok,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL)  /* stage#5 */
#define fft_final(r) \
          exe(OP_FMS,     &AR[r][0],  roj,      EXP_H3210,  tr1,     EXP_H3210, 0x3f800000LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#6 */\
          mop(OP_STWR, 3, &AR[r][0],  RealOut,  k,          MSK_D0,  RealOut,   NumSamples,   0, 0,  NULL,  NumSamples);            /* stage#6 */\
          exe(OP_FAD,     &AR[r][1],  roj,      EXP_H3210,  tr1,     EXP_H3210, 0LL,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#6 */\
          mop(OP_STWR, 3, &AR[r][1],  RealOut,  j,          MSK_D0,  RealOut,   NumSamples,   0, 0,  NULL,  NumSamples);            /* stage#6 */\
          exe(OP_FMS,     &AR[r][2],  ioj,      EXP_H3210,  ti1,     EXP_H3210, 0x3f800000LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#6 */\
          mop(OP_STWR, 3, &AR[r][2],  ImagOut,  k,          MSK_D0,  ImagOut,   NumSamples,   0, 0,  NULL,  NumSamples);            /* stage#6 */\
          exe(OP_FAD,     &AR[r][3],  ioj,      EXP_H3210,  ti1,     EXP_H3210, 0LL,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#6 */\
          mop(OP_STWR, 3, &AR[r][3],  ImagOut,  j,          MSK_D0,  ImagOut,   NumSamples,   0, 0,  NULL,  NumSamples)             /* stage#6 */
  BlockEnd = 1;
  for (BlockSize=2; BlockSize<=NumSamples; BlockSize<<=1) {
//with-prefetch/post-drain
//EMAX5A begin imax mapdist=0
/*3*/for (CHIP=0; CHIP<NCHIP; CHIP++) {
  /*2*/for (INIT1=1,LOOP1=NumSamples/BlockSize,i=0LL<<32|(0-BlockSize)&0xffffffff; LOOP1--; INIT1=0) {
    /*1*/for (INIT0=1,LOOP0=BlockEnd,n=0LL<<32|(0-1LL)&0xffffffff; LOOP0--; INIT0=0) {
          exe(OP_ADD,     &i,     i,         EXP_H3210,   INIT0?BlockSize:0, EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);          /* stage#0 */
          exe(OP_ADD,     &n,     INIT0?n:n, EXP_H3210,   0LL<<32|1LL,       EXP_H3210, 0LL,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#0 */
          fft_core0(2); /* stage#2   */
          fft_core1(3); /* stage#3-5 */
          fft_final(6); /* stage#6   */
    } } }
//EMAX5A end
//EMAX5A drain_dirty_lmm
    BlockEnd = BlockSize;
  }
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\epsfile{file=fourierf-imax-emax6.eps,width=1.00\textwidth}
\caption{FFT}
\end{figure}

\clearpage

\subsubsection{Pipelined implementation}

FFTのパイプライン版．最大4096（LMM=4K*4byte*2*2=64KB）要素のFFT．中間のLMMを
ダブルバッファとして使用している．

\begin{screen}
\tiny
\begin{verbatim}
  Ull  CHIP;
  Ull  LOOP1, LOOP0, L;
  Ull  INIT1, INIT0;
  Ull  AR[64][4];                     /* output of EX     in each unit */
  Ull  BR[64][4][4];                  /* output registers in each unit */
  Ull  r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15;
  Ull  r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31;
  Ull  cc0, cc1, cc2, cc3, ex0, ex1;
  Ull  J[16], K[16], IDX[16]; /* log2(NumSamples=65536)=16まで対応可 */
  Ull  BufReal[16], BufImag[16];
  Ull  ar, ai, rok, iok, roj, ioj, tr0, ti0, tr1, ti1;
  Ull  Pipeline, Lmmrotate; /* log2(NumSamples=65536)=16回繰り返すと,最終段のLMMに,最初のRealOut/ImagOutが格納される */
  printf("<<<IMAX>>> NumSamples=%d (LMM should be >= %dB)\n", NumSamples, NumSamples*4*2);
  reset_nanosec();
#define fft_core0(r, x, MASK_M, MASK_N, BS) \
        exe(OP_ADD,     &i,         L,          EXP_H3210,  L,       EXP_H3210, 0LL,          EXP_H3210, OP_AND, MASK_M, OP_NOP, 0LL); /* stage#1 i  =(L*2)&M   */\
        exe(OP_ADD,     &n,         L,          EXP_H3210,  0LL,     EXP_H3210, 0LL,          EXP_H3210, OP_AND, MASK_N, OP_NOP, 0LL); /* stage#1 n  =L    &N   */\
        exe(OP_ADD,     &J[x],      i,          EXP_H3210,  n,       EXP_H3210, 0LL,          EXP_H3210, OP_NOP, 0LL,    OP_SLL, 2LL); /* stage#2 j  =i+n       */\
        exe(OP_ADD3,    &K[x],      i,          EXP_H3210,  n,       EXP_H3210, BS,           EXP_H3210, OP_NOP, 0LL,    OP_SLL, 2LL); /* stage#2 k  =i+n+BS(2) */\
        exe(OP_ADD3,    &IDX[x],    0LL,        EXP_H3210,  n,       EXP_H3210, BS,           EXP_H3210, OP_NOP, 0LL,    OP_SLL, 2LL)  /* stage#2 idx=  n+BS(2) */
#define fft_core1(r, x) \
        exe(OP_NOP,     &AR[r][0],  0LL,        EXP_H3210,  0LL,     EXP_H3210, 0LL,          EXP_H3210, OP_NOP, 0LL,    OP_NOP, 0LL); /* stage#3 [3][0]        */\
        mop(OP_LDWR, 3, &rok,       RealIn,     K[x],       MSK_D0,  RealIn,    NumSamples,   0, 1,  NULL,  NumSamples);               /* stage#3 RealIn[k]     */\
        mop(OP_LDWR, 3, &roj,       J[x],       RealIn,     MSK_D0,  RealIn,    NumSamples,   0, 1,  NULL,  NumSamples);               /* stage#3 RealIn[j]     */\
        exe(OP_NOP,     &AR[r][2],  0LL,        EXP_H3210,  0LL,     EXP_H3210, 0LL,          EXP_H3210, OP_NOP, 0LL,    OP_NOP, 0LL); /* stage#3 [3][2]        */\
        mop(OP_LDWR, 3, &iok,       ImagIn,     K[x],       MSK_D0,  ImagIn,    NumSamples,   0, 1,  NULL,  NumSamples);               /* stage#3 ImagIn[k]     */\
        mop(OP_LDWR, 3, &ioj,       J[x],       ImagIn,     MSK_D0,  ImagIn,    NumSamples,   0, 1,  NULL,  NumSamples)                /* stage#3 ImagIn[j]     */
#define fft_core2(r, x, y, MASK_M, MASK_N, BS) \
        exe(OP_NOP,     &AR[r][0],  0LL,        EXP_H3210,  0LL,     EXP_H3210, 0LL,          EXP_H3210, OP_NOP, 0LL,    OP_NOP, 0LL); /* stage#4 [4][0]        */\
        exe(OP_ADD,     &i,         L,          EXP_H3210,  L,       EXP_H3210, 0LL,          EXP_H3210, OP_AND, MASK_M, OP_NOP, 0LL); /* stage#4 i  =(L*2)&M   */\
        mop(OP_LDWR, 3, &ar,        art,        IDX[x],     MSK_D0,  art,       NumSamples,   0, 0,  NULL,  NumSamples);               /* stage#4 art[idx]      */\
        exe(OP_NOP,     &AR[r][2],  0LL,        EXP_H3210,  0LL,     EXP_H3210, 0LL,          EXP_H3210, OP_NOP, 0LL,    OP_NOP, 0LL); /* stage#4 [4][2]        */\
        exe(OP_ADD,     &n,         L,          EXP_H3210,  0LL,     EXP_H3210, 0LL,          EXP_H3210, OP_AND, MASK_N, OP_NOP, 0LL); /* stage#4 n  = L   &N   */\
        mop(OP_LDWR, 3, &ai,        ait,        IDX[x],     MSK_D0,  ait,       NumSamples,   0, 0,  NULL,  NumSamples);               /* stage#4 ait[idx]      */\
        \
        exe(OP_ADD,     &J[y],      i,          EXP_H3210,  n,       EXP_H3210, 0LL,          EXP_H3210, OP_NOP, 0LL,    OP_SLL, 2LL); /* stage#5 j  =i+n       */\
        exe(OP_ADD3,    &K[y],      i,          EXP_H3210,  n,       EXP_H3210, BS,           EXP_H3210, OP_NOP, 0LL,    OP_SLL, 2LL); /* stage#5 k  =i+n+BS(2) */\
        exe(OP_FML,     &tr0,       ar,         EXP_H3210,  rok,     EXP_H3210, 0LL,          EXP_H3210, OP_NOP, 0LL,    OP_NOP, 0LL); /* stage#5 */\
        exe(OP_FML,     &ti0,       ar,         EXP_H3210,  iok,     EXP_H3210, 0LL,          EXP_H3210, OP_NOP, 0LL,    OP_NOP, 0LL); /* stage#5 */\
        \
        exe(OP_ADD3,    &IDX[y],    0LL,        EXP_H3210,  n,       EXP_H3210, BS,           EXP_H3210, OP_NOP, 0LL,    OP_SLL, 2LL); /* stage#6 idx=  n+BS(2) */\
        exe(OP_FMS,     &tr1,       tr0,        EXP_H3210,  ai,      EXP_H3210, iok,          EXP_H3210, OP_NOP, 0LL,    OP_NOP, 0LL); /* stage#6 */\
        exe(OP_FMA,     &ti1,       ti0,        EXP_H3210,  ai,      EXP_H3210, rok,          EXP_H3210, OP_NOP, 0LL,    OP_NOP, 0LL)  /* stage#6 */
#define fft_core3(r, x, y) \
        exe(OP_FMS,     &AR[r][0],  roj,        EXP_H3210,  tr1,     EXP_H3210, 0x3f800000LL, EXP_H3210, OP_NOP, 0LL,    OP_NOP, 0LL); /* stage#7 */\
        mop(OP_STWR, 3, &AR[r][0],  BufReal[x], K[x],       MSK_D0,  BufReal[x],0LL,          0, 0,  NULL,  0LL);                      /* stage#7 */\
        mop(OP_LDWR, 3, &rok,       K[y],       BufReal[y], MSK_D0,  BufReal[x],0LL,          0, 0,  NULL,  0LL);                      /* stage#7 BufReal[k] */\
        exe(OP_FAD,     &AR[r][1],  roj,        EXP_H3210,  tr1,     EXP_H3210, 0LL,          EXP_H3210, OP_NOP, 0LL,    OP_NOP, 0LL); /* stage#7 */\
        mop(OP_STWR, 3, &AR[r][1],  BufReal[x], J[x],       MSK_D0,  BufReal[x],0LL,          0, 0,  NULL,  0LL);                      /* stage#7 */\
        mop(OP_LDWR, 3, &roj,       J[y],       BufReal[y], MSK_D0,  BufReal[x],0LL,          0, 0,  NULL,  0LL);                      /* stage#7 BufReal[j] */\
        exe(OP_FMS,     &AR[r][2],  ioj,        EXP_H3210,  ti1,     EXP_H3210, 0x3f800000LL, EXP_H3210, OP_NOP, 0LL,    OP_NOP, 0LL); /* stage#7 */\
        mop(OP_STWR, 3, &AR[r][2],  BufImag[x], K[x],       MSK_D0,  BufImag[x],0LL,          0, 0,  NULL,  0LL);                      /* stage#7 */\
        mop(OP_LDWR, 3, &iok,       K[y],       BufImag[y], MSK_D0,  BufImag[x],0LL,          0, 0,  NULL,  0LL);                      /* stage#7 BufImag[k] */\
        exe(OP_FAD,     &AR[r][3],  ioj,        EXP_H3210,  ti1,     EXP_H3210, 0LL,          EXP_H3210, OP_NOP, 0LL,    OP_NOP, 0LL); /* stage#7 */\
        mop(OP_STWR, 3, &AR[r][3],  BufImag[x], J[x],       MSK_D0,  BufImag[x],0LL,          0, 0,  NULL,  0LL);                      /* stage#7 */\
        mop(OP_LDWR, 3, &ioj,       J[y],       BufImag[y], MSK_D0,  BufImag[x],0LL,          0, 0,  NULL,  0LL)                       /* stage#7 BufImag[j] */
#define fft_final(r, x) \
        exe(OP_FMS,     &AR[r][0],  roj,        EXP_H3210,  tr1,     EXP_H3210, 0x3f800000LL, EXP_H3210, OP_NOP, 0LL,    OP_NOP, 0LL); /* stage#7 */\
        mop(OP_STWR, 3, &AR[r][0],  RealOut,    K[x],       MSK_D0,  RealOut,   NumSamples,   0, 0,  NULL,  NumSamples);               /* stage#7 */\
        exe(OP_FAD,     &AR[r][1],  roj,        EXP_H3210,  tr1,     EXP_H3210, 0LL,          EXP_H3210, OP_NOP, 0LL,    OP_NOP, 0LL); /* stage#7 */\
        mop(OP_STWR, 3, &AR[r][1],  RealOut,    J[x],       MSK_D0,  RealOut,   NumSamples,   0, 0,  NULL,  NumSamples);               /* stage#7 */\
        exe(OP_FMS,     &AR[r][2],  ioj,        EXP_H3210,  ti1,     EXP_H3210, 0x3f800000LL, EXP_H3210, OP_NOP, 0LL,    OP_NOP, 0LL); /* stage#7 */\
        mop(OP_STWR, 3, &AR[r][2],  ImagOut,    K[x],       MSK_D0,  ImagOut,   NumSamples,   0, 0,  NULL,  NumSamples);               /* stage#7 */\
        exe(OP_FAD,     &AR[r][3],  ioj,        EXP_H3210,  ti1,     EXP_H3210, 0LL,          EXP_H3210, OP_NOP, 0LL,    OP_NOP, 0LL); /* stage#7 */\
        mop(OP_STWR, 3, &AR[r][3],  ImagOut,    J[x],       MSK_D0,  ImagOut,   NumSamples,   0, 0,  NULL,  NumSamples)                /* stage#7 */
  for (Pipeline=0; Pipeline<NumBits; Pipeline++) {
    /* 0: buf[0]=[(0+4-0)%4]:0 buf[1]=[(1+4-0)%4]:1 buf[2]=[(2+4-0)%4]:2 buf[3]=[(3+4-0)%4]:3 */
    /* 1: buf[0]=[(0+4-1)%4]:3 buf[1]=[(1+4-1)%4]:0 buf[2]=[(2+4-1)%4]:1 buf[3]=[(3+4-1)%4]:2 */
    /* 2: buf[0]=[(0+4-2)%4]:2 buf[1]=[(1+4-2)%4]:3 buf[2]=[(2+4-2)%4]:0 buf[3]=[(3+4-2)%4]:1 */
    for (Lmmrotate=0; Lmmrotate<=NumBits; Lmmrotate++) {
      BufReal[Lmmrotate] = &pseudoLMM[NumSamples*(((Lmmrotate+NumBits+1-Pipeline)%(NumBits+1))*2  )];
      BufImag[Lmmrotate] = &pseudoLMM[NumSamples*(((Lmmrotate+NumBits+1-Pipeline)%(NumBits+1))*2+1)];
    }
//EMAX5A begin pipeline mapdist=0
/*3*/for (CHIP=0; CHIP<NCHIP; CHIP++) {
 /*1*/for (INIT0=1,LOOP0=NumSamples/2,L=0LL<<32|(0-1LL)&0xffffffff; LOOP0--; INIT0=0) { /* NumSamples<=4096 */
        exe(OP_ADD,     &L,         L,          EXP_H3210,  0LL<<32|1LL, EXP_H3210, 0LL,      EXP_H3210, OP_NOP, 0LL,    OP_NOP, 0LL); /* stage#0 */
#if (H==2)
        fft_core0( 1,  0,     0xfffeLL, 0x0000LL, 1LL); /* stage#1-2   */
        fft_core1( 3,  0);                              /* stage#3     */
        fft_core2( 4,  0,  1, 0xfffcLL, 0x0001LL, 2LL); /* stage#4-6   */
        fft_final( 7,  0);                              /* stage#7     */
#endif
#if (H==4096)
        fft_core0( 1,  0,     0xfffeLL, 0x0000LL,    1LL); /* stage#1-2   */
        fft_core1( 3,  0);                                 /* stage#3     */
        fft_core2( 4,  0,  1, 0xfffcLL, 0x0001LL,    2LL); /* stage#4-6   */
        fft_core3( 7,  0,  1);                             /* stage#7     */
        fft_core2( 8,  1,  2, 0xfff8LL, 0x0003LL,    4LL); /* stage#8-10  */
        fft_core3(11,  1,  2);                             /* stage#11    */
        fft_core2(12,  2,  3, 0xfff0LL, 0x0007LL,    8LL); /* stage#12-14 */
        fft_core3(15,  2,  3);                             /* stage#15    */
        fft_core2(16,  3,  4, 0xffe0LL, 0x000fLL,   16LL); /* stage#16-18 */
        fft_core3(19,  3,  4);                             /* stage#19    */
        fft_core2(20,  4,  5, 0xffc0LL, 0x001fLL,   32LL); /* stage#20-22 */
        fft_core3(23,  4,  5);                             /* stage#23    */
        fft_core2(24,  5,  6, 0xff80LL, 0x003fLL,   64LL); /* stage#24-26 */
        fft_core3(27,  5,  6);                             /* stage#27    */
        :
        fft_core2(44, 10, 11, 0xf000LL, 0x07ffLL, 2048LL); /* stage#44-46 */
        fft_core3(47, 10, 11);                             /* stage#47    */
        fft_core2(48, 11, 12, 0xe000LL, 0x0fffLL, 4096LL); /* stage#48-50 */
        fft_final(51, 11);                                 /* stage#51    */
#endif
    } }
//EMAX5A end
//EMAX5A drain_dirty_lmm
  }
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\epsfile{file=fourierf-pipeline-emax6.eps,width=1.00\textwidth}
\caption{FFT}
\end{figure}

\clearpage

\subsection{Merge sort}

\shabox{
\leftline{cent\% make -f Makefile-csim.emax6+dma all clean}
\leftline{cent\% ../../src/csim/csim -x sort-merge-csim.emax6+dma 4096}
}

\shabox{
\leftline{zynq\% make -f Makefile-zynq.emax6+dma all clean}
\leftline{zynq\% ./sort-merge-zynq.emax6+dma 4096}
}

\vskip .1in

最大4096（LMM=4K*8byte*2=64KB）要素のパイプライン版merge sort．中間のLMMをダ
ブルバッファとして使用している．なお，入力データは各要素8バイトである．上位4
バイトが大小比較対象，下位4バイトはポインタや属性など任意の値に使用できる．

\begin{screen}
\tiny
\begin{verbatim}
printf("<<<ORIG>>>\n");
BlockEnd = 1;
for (BlockSize=2; BlockSize<=NumSamples; BlockSize<<=1) {
  for (i=0; i<NumSamples; i+=BlockSize) {
    for (j=i,k=i+BlockEnd,t=i; t<i+BlockSize; t++) {
      int cc0 = j<i+BlockEnd;
      int cc1 = k<i+BlockSize;
      int cc2 = In[j].val < In[k].val;
      if ((( cc2 && cc1) || !cc1) && cc0) /* 7,5,1 0x00a2 */ Out[t] = In[j++];
      if (((!cc2 && cc0) || !cc0) && cc1) /* 6,3,2 0x004c */ Out[t] = In[k++];
  } }
  BlockEnd = BlockSize;
  for (i=0; i<NumSamples; i++)
    In[i] = Out[i];
}
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
#define NCHIP 1
#define H     4096
Ull  CHIP;
Ull  LOOP1, LOOP0, L8;
Ull  INIT1, INIT0;
Ull  AR[64][4];           /* output of EX     in each unit */
Ull  BR[64][4][4];        /* output registers in each unit */
Ull  r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15;
Ull  r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31;
Ull  cc0, cc1, cc2, cc3, ex0, ex1, ex2, ex3;
Ull  Buf[32];
Ull  base, J[16], K[16];  /* log2(NumSamples=65536)=16まで対応可 */
Ull  Pipeline, Lmmrotate; /* log2(NumSamples=65536)=16回繰り返すと,最終段のLMMに,最初のOutが格納される */
printf("<<<IMAX>>> NumSamples=%d (LMM should be >= %dB)\n", NumSamples, NumSamples2*4);

for (i=0; i<NumBits; i++) { J[i]=0; K[i]=0; }
#define sort_core0(r, rp1, x, MASK_M, In, BE8) \
 exe(OP_NOP,      &AR[r][1],    0LL,         EXP_H3210, 0LL,         EXP_H3210,  0LL,  EXP_H3210, OP_NOP, 0LL,    OP_NOP, 0LL); /*stage#1 dmy            */\
 exe(OP_ADD,      &i,           L8,          EXP_H3210, 0LL,         EXP_H3210,  0LL,  EXP_H3210, OP_AND, MASK_M, OP_NOP, 0LL); /*stage#1 i    = L8&M    */\
 exe(OP_NOP,      &AR[rp1][3],  0LL,         EXP_H3210, 0LL,         EXP_H3210,  0LL,  EXP_H3210, OP_NOP, 0LL,    OP_NOP, 0LL); /*stage#2 dmy            */\
 exe(OP_ADD,      &base,        In,          EXP_H3210, i,           EXP_H3210,  0LL,  EXP_H3210, OP_NOP, 0LL,    OP_NOP, 0LL)  /*stage#2 baseJ=&In[i],baseK=&In[i+BE]*/
#define sort_core1(r, rp1, x, In, Ilen, BE8, Buf, Out, Olen) \
 mex(OP_CMPA_LE, &J[x], INIT0?0LL:J[x], INIT0?0LL:8LL, OP_CMPA_GE, &K[x], INIT0?BE8:K[x], INIT0?0LL:8LL, BE8, BR[r][3][1], BR[r][3][0]);     /* stage#3 */\
 mop(OP_LDR, 3,   &BR[r][3][1], J[x],        base,      MSK_D0,      In,         Ilen, 0, 0,      NULL,   Ilen);/*LMM[2]確定   LD実行はcol2*//* stage#3 */\
 mop(OP_LDR, 3,   &BR[r][3][0], K[x],        base,      MSK_D0,      In,         Ilen, 0, 0,      NULL,   Ilen);/*LMM[1]間借り LD実行はcol2*//* stage#3 */\
 exe(OP_CMP_LT,   &cc0,         J[x],        EXP_H1010, BE8,         EXP_H1010,  0LL,  EXP_H3210, OP_NOP, 0LL, OP_NOP, 0);/* J[x]<BE8 */     /* stage#4 */\
 exe(OP_CMP_LT,   &cc1,         K[x],        EXP_H1010, BE8*2,       EXP_H1010,  0LL,  EXP_H3210, OP_NOP, 0LL, OP_NOP, 0);/* K[x]<BE8 */     /* stage#4 */\
 exe(OP_CMP_LT,   &cc2,         BR[r][3][1], EXP_H3232, BR[r][3][0], EXP_H3232,  0LL,  EXP_H3210, OP_NOP, 0LL, OP_NOP, 0);/* *J<*K    */     /* stage#4 */\
 cex(OP_CEXE,     &ex0,         0, cc2, cc1, cc0, 0x00a2);                     /* if (( cc2 && cc1 && cc0) || (!cc1 &&  cc0)) 7,5,1 0x00a2 *//* stage#5 */\
 mop(OP_STR, ex0, &BR[r][3][1], Buf,         L8,        MSK_W0,      Out,        Olen, 0, 0,      NULL,   Olen);/*LMM[1]間借り LD実行はcol2*//* stage#5 */\
 cex(OP_CEXE,     &ex1,         0, cc2, cc1, cc0, 0x004c);                     /* if ((!cc2 && cc1 && cc0) || ( cc1 && !cc0)) 6,3,2 0x004c *//* stage#5 */\
 mop(OP_STR, ex1, &BR[r][3][0], Buf,         L8,        MSK_W0,      Out,        Olen, 0, 0,      NULL,   Olen) /*LMM[1]間借り LD実行はcol2*//* stage#5 */

for (Pipeline=0; Pipeline<NumBits; Pipeline++) {
  for (Lmmrotate=0; Lmmrotate<NumBits*2; Lmmrotate++)
    Buf[Lmmrotate] = &pseudoLMM[NumSamples*((Lmmrotate+NumBits*2-Pipeline)%(NumBits*2))];
//EMAX5A begin pipeline mapdist=0
/*3*/for (CHIP=0; CHIP<NCHIP; CHIP++) {
/*1*/for (INIT0=1,LOOP0=NumSamples,L8=0LL<<32|(0-8LL)&0xffffffff; LOOP0--; INIT0=0) { /* NumSamples<=4096 */
      exe(OP_ADD, &L8, L8, EXP_H3210, 0LL<<32|8LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#0 */
#if (H==2)
      sort_core0( 1,  2, 0, 0xfffffffffffffff0LL, In,      8LL);                                   /* stage#1-2   */
      sort_core1( 3,  4, 0, In,       NumSamples2,         8LL,     Out,    Out,     NumSamples2); /* stage#3-5   */
#endif
#if (H==4096)
      sort_core0( 1,  2, 0, 0xfffffffffffffff0LL, In,      8LL);                                   /* stage#1-2   */
      sort_core1( 3,  4, 0, In,       NumSamples2,         8LL,     Buf[0],  Buf[1], 0LL);         /* stage#3-5   */
      sort_core0( 3,  4, 1, 0xffffffffffffffe0LL, Buf[1],  16LL);                                  /* stage#3-4   */
      sort_core1( 5,  6, 1, Buf[1],   0LL,                 16LL,    Buf[2],  Buf[3], 0LL);         /* stage#5-7   */
      sort_core0( 5,  6, 2, 0xffffffffffffffc0LL, Buf[3],  32LL);                                  /* stage#5-6   */
      sort_core1( 7,  8, 2, Buf[3],   0LL,                 32LL,    Buf[4],  Buf[5], 0LL);         /* stage#7-9   */
      sort_core0( 7,  8, 3, 0xffffffffffffff80LL, Buf[5],  64LL);                                  /* stage#7-8   */
      sort_core1( 9, 10, 3, Buf[5],   0LL,                 64LL,    Buf[6],  Buf[7], 0LL);         /* stage#9-11  */
      sort_core0( 9, 10, 4, 0xffffffffffffff00LL, Buf[7],  128LL);                                 /* stage#9-10  */
      sort_core1(11, 12, 4, Buf[7],   0LL,                 128LL,   Buf[8],  Buf[9], 0LL);         /* stage#11-13 */
      sort_core0(11, 12, 5, 0xfffffffffffffe00LL, Buf[9],  256LL);                                 /* stage#11-12 */
      sort_core1(13, 14, 5, Buf[9],   0LL,                 256LL,   Buf[10], Buf[11],0LL);         /* stage#13-15 */
      sort_core0(13, 14, 6, 0xfffffffffffffc00LL, Buf[11], 512LL);                                 /* stage#13-14 */
      :
      sort_core1(21, 22, 9, Buf[17],  0LL,                 4096LL,  Buf[18], Buf[19],0LL);         /* stage#21-23 */
      sort_core0(21, 22,10, 0xffffffffffffc000LL, Buf[19], 8192LL);                                /* stage#21-22 */
      sort_core1(23, 24,10, Buf[19],  0LL,                 8192LL,  Buf[20], Buf[21],0LL);         /* stage#23-25 */
      sort_core0(23, 24,11, 0xffffffffffff8000LL, Buf[21], 16384LL);                               /* stage#23-24 */
      sort_core1(25, 26,11, Buf[21],  0LL,                 16384LL, Out,     Out,    NumSamples2); /* stage#25-27 */
#endif
  } }
//EMAX5A end
//EMAX5A drain_dirty_lmm
}
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\epsfile{file=sort-merge-pipeline-emax6.eps,width=1.00\textwidth}
\caption{FFT}
\end{figure}

\clearpage

\subsection{文字列検索}

\shabox{
\leftline{cent\% make -f Makefile-csim.emax6+dma all clean}
\leftline{cent\% ../../src/csim/csim -x search-csim.emax6+dma search.txt target.txt}
}

\shabox{
\leftline{zynq\% make -f Makefile-zynq.emax6+dma all clean}
\leftline{zynq\% ./search-zynq.emax6+dma search.txt target.txt}
}

\vskip .1in

最大8文字までの文字列検索である．一度のバースト演算により9個の文字列を検索す
る．

\begin{figure}[htbp]
\center
\includegraphics[angle=270,origin=b,width=0.70\textwidth]{string.eps}
\caption{String search}
\end{figure}

\begin{screen}
\tiny
\begin{verbatim}
orig()
{
  int i;
  printf("<<<ORIG>>>\n");
  for (i=0; i<snum; i++) {
    init_search(i);
    strsearch(i);
  }
  return 0;
}
init_search(int i)/* for ARM */
{
  char *str = sstr[i];
  int  len  = slen[i];
  int  j;
  for (j = 0; j <= UCHAR_MAX; j++)
    table[j] = len;
  for (j = 0; j < len; j++)
    table[(Uchar)str[j]] = len - j - 1;
  for (j = 0; j < clen; j++)
    *(out0+clen*i+j) = 0;
}
strsearch(int i)
{
  char *str = sstr[i];
  int  len  = slen[i];
  register size_t shift;
  register size_t pos = len - 1;
  char   *found;
  while (pos < clen) {
    while (pos < clen && (shift = table[(unsigned char)target[pos]]) > 0)
      pos += shift;
    if (!shift) {
      if (!strncmp(str, &target[pos-len+1], len))
        out0[i*clen+(pos-len+1)] = 0xff;
      pos++;
} } }
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
imax()
{
  int i, j;
  printf("<<<IMAX>>>\n");
  for (i=0; i<snum; i++) {
    for (j=0; j<clen; j++) {
      if (!strncmp(sstr[i], &target[j], slen[i]))
        out1[i*clen+j] = 0xff;
      else
        out1[i*clen+j] = 0;
} } }
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
imax()
{
  Ull   CHIP;
  Ull   LOOP1, LOOP0;
  Ull   INIT1, INIT0;
  Ull   AR[64][4];                     /* output of EX     in each unit */
  Ull   BR[64][4][4];                  /* output registers in each unit */
  Ull   r00, r01, r02, r03, r04, r05, r06, r07, r08, r09, r10, r11, r12, r13, r14, r15;
  Ull   r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31;
  Ull   c0, c1, c2, c3, ex0, ex1;
  Ull   t0[NCHIP], t1[NCHIP], t2[NCHIP], t3[NCHIP], t4[NCHIP], t5[NCHIP], t6[NCHIP], t7[NCHIP], t8[NCHIP];
  Ull   t0t[NCHIP], t1t[NCHIP], t2t[NCHIP], t3t[NCHIP], t4t[NCHIP], t5t[NCHIP], t6t[NCHIP], t7t[NCHIP], t8t[NCHIP];
  Ull   r0[NCHIP], r1[NCHIP], r2[NCHIP], r3[NCHIP], r4[NCHIP], r5[NCHIP], r6[NCHIP], r7[NCHIP], r8[NCHIP];
  Ull   r0t[NCHIP], r1t[NCHIP], r2t[NCHIP], r3t[NCHIP], r4t[NCHIP], r5t[NCHIP], r6t[NCHIP], r7t[NCHIP], r8t[NCHIP];
  Ull   i, dmy, loop=clen/NCHIP;
  Ull   dwi = clen/NCHIP/4+1; /* dwords */
  Ull   dwo = clen/NCHIP/4  ; /* dwords */

  printf("<<<IMAX>>>\n");
  for (CHIP=0; CHIP<NCHIP; CHIP++) {
    t0t[CHIP]=target+(clen/NCHIP*CHIP);
    t1t[CHIP]=target+(clen/NCHIP*CHIP);
    t2t[CHIP]=target+(clen/NCHIP*CHIP);
    t3t[CHIP]=target+(clen/NCHIP*CHIP);
    t4t[CHIP]=target+(clen/NCHIP*CHIP);
    t5t[CHIP]=target+(clen/NCHIP*CHIP);
    t6t[CHIP]=target+(clen/NCHIP*CHIP);
    t7t[CHIP]=target+(clen/NCHIP*CHIP);
    t8t[CHIP]=target+(clen/NCHIP*CHIP);
  }
  for (i=0; i<snum; i+=OMAP) {
    Ull  c00=sstr[i+0][0], c01=sstr[i+0][1], c02=sstr[i+0][2], c03=sstr[i+0][3], c04=sstr[i+0][4], c05=sstr[i+0][5], c06=sstr[i+0][6], c07=sstr[i+0][7];
    Ull  c10=sstr[i+1][0], c11=sstr[i+1][1], c12=sstr[i+1][2], c13=sstr[i+1][3], c14=sstr[i+1][4], c15=sstr[i+1][5], c16=sstr[i+1][6], c17=sstr[i+1][7];
         :
    Ull  c80=sstr[i+8][0], c81=sstr[i+8][1], c82=sstr[i+8][2], c83=sstr[i+8][3], c84=sstr[i+8][4], c85=sstr[i+8][5], c86=sstr[i+8][6], c87=sstr[i+8][7];
    Ull  slen0=slen[i+0], slen1=slen[i+1], slen2=slen[i+2], slen3=slen[i+3], slen4=slen[i+4], slen5=slen[i+5], slen6=slen[i+6], slen7=slen[i+7], slen8=slen[i+8];
    for (CHIP=0; CHIP<NCHIP; CHIP++) {
      t0[CHIP] = t0t[CHIP]-1;
      t1[CHIP] = t1t[CHIP]-1;
        :
      t8[CHIP] = t8t[CHIP]-1;
      r0[CHIP] = r0t[CHIP] = out1+(i+0)*clen+(clen/NCHIP*CHIP);
      r1[CHIP] = r1t[CHIP] = out1+(i+1)*clen+(clen/NCHIP*CHIP);
        :
      r8[CHIP] = r8t[CHIP] = out1+(i+8)*clen+(clen/NCHIP*CHIP);
    }
//EMAX5A begin search mapdist=0
    for (CHIP=0; CHIP<NCHIP; CHIP++) { //チップ方向は検索対象文書の大きさ方向
      for (INIT0=1,LOOP0=loop,dmy=0; LOOP0--; INIT0=0) { //長さは64KB文字まで
      /* map#0 */
/*@0,1*/ exe(OP_ADD,       &t0[CHIP],     t0[CHIP], EXP_H3210,   1LL,          EXP_H3210, 0LL, EXP_H3210, OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL);
/*@1,0*/ exe(OP_MCAS,      &r00,          slen0,    EXP_H3210,   1,            EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL,    OP_NOP,  0LL);
/*@1,1*/ exe(OP_MCAS,      &r01,          slen0,    EXP_H3210,   2,            EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL,    OP_NOP,  0LL);
/*@1,2*/ exe(OP_MCAS,      &r02,          slen0,    EXP_H3210,   3,            EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL,    OP_NOP,  0LL);
/*@1,3*/ exe(OP_MCAS,      &r03,          slen0,    EXP_H3210,   4,            EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL,    OP_NOP,  0LL);
/*@1,0*/ mop(OP_LDBR,  1,  &BR[1][0][1],  t0[CHIP], 0,   MSK_D0, t0t[CHIP],    dwi,  0,   0,   (Ull)NULL,  dwi);
/*@1,0*/ mop(OP_LDBR,  1,  &BR[1][0][0],  t0[CHIP], 1,   MSK_D0, t0t[CHIP],    dwi,  0,   0,   (Ull)NULL,  dwi);
/*@1,1*/ mop(OP_LDBR,  1,  &BR[1][1][1],  t0[CHIP], 2,   MSK_D0, t0t[CHIP],    dwi,  0,   0,   (Ull)NULL,  dwi);
/*@1,1*/ mop(OP_LDBR,  1,  &BR[1][1][0],  t0[CHIP], 3,   MSK_D0, t0t[CHIP],    dwi,  0,   0,   (Ull)NULL,  dwi);
/*@1,2*/ mop(OP_LDBR,  1,  &BR[1][2][1],  t0[CHIP], 4,   MSK_D0, t0t[CHIP],    dwi,  0,   0,   (Ull)NULL,  dwi);
/*@1,2*/ mop(OP_LDBR,  1,  &BR[1][2][0],  t0[CHIP], 5,   MSK_D0, t0t[CHIP],    dwi,  0,   0,   (Ull)NULL,  dwi);
/*@1,3*/ mop(OP_LDBR,  1,  &BR[1][3][1],  t0[CHIP], 6,   MSK_D0, t0t[CHIP],    dwi,  0,   0,   (Ull)NULL,  dwi);
/*@1,3*/ mop(OP_LDBR,  1,  &BR[1][3][0],  t0[CHIP], 7,   MSK_D0, t0t[CHIP],    dwi,  0,   0,   (Ull)NULL,  dwi);
/*@2,0*/ exe(OP_CMP_NE,    &r16,          c00,      EXP_H3210,   BR[1][0][1],  EXP_H3210, 0LL, EXP_H3210, OP_AND, r00,    OP_NOP,  0LL); // 1 if unmatch
/*@2,1*/ exe(OP_CMP_NE,    &r17,          c01,      EXP_H3210,   BR[1][0][0],  EXP_H3210, 0LL, EXP_H3210, OP_AND, r01,    OP_NOP,  0LL); // 1 if unmatch
/*@2,2*/ exe(OP_CMP_NE,    &r18,          c02,      EXP_H3210,   BR[1][1][1],  EXP_H3210, 0LL, EXP_H3210, OP_AND, r02,    OP_NOP,  0LL); // 1 if unmatch
/*@2,3*/ exe(OP_CMP_NE,    &r19,          c03,      EXP_H3210,   BR[1][1][0],  EXP_H3210, 0LL, EXP_H3210, OP_AND, r03,    OP_NOP,  0LL); // 1 if unmatch
/*@3,0*/ exe(OP_MCAS,      &r04,          slen0,    EXP_H3210,   5,            EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL,    OP_NOP,  0LL);
/*@3,1*/ exe(OP_MCAS,      &r05,          slen0,    EXP_H3210,   6,            EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL,    OP_NOP,  0LL);
/*@3,2*/ exe(OP_MCAS,      &r06,          slen0,    EXP_H3210,   7,            EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL,    OP_NOP,  0LL);
/*@3,3*/ exe(OP_MCAS,      &r07,          slen0,    EXP_H3210,   8,            EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL,    OP_NOP,  0LL);
/*@4,0*/ exe(OP_CMP_NE,    &r20,          c04,      EXP_H3210,   BR[1][2][1],  EXP_H3210, 0LL, EXP_H3210, OP_AND, r04,    OP_NOP,  0LL); // 1 if unmatch
/*@4,1*/ exe(OP_CMP_NE,    &r21,          c05,      EXP_H3210,   BR[1][2][0],  EXP_H3210, 0LL, EXP_H3210, OP_AND, r05,    OP_NOP,  0LL); // 1 if unmatch
/*@4,2*/ exe(OP_CMP_NE,    &r22,          c06,      EXP_H3210,   BR[1][3][1],  EXP_H3210, 0LL, EXP_H3210, OP_AND, r06,    OP_NOP,  0LL); // 1 if unmatch
/*@4,3*/ exe(OP_CMP_NE,    &r23,          c07,      EXP_H3210,   BR[1][3][0],  EXP_H3210, 0LL, EXP_H3210, OP_AND, r07,    OP_NOP,  0LL); // 1 if unmatch
/*@5,0*/ exe(OP_ADD3,      &r10,          r16,      EXP_H3210,   r17,          EXP_H3210, r18, EXP_H3210, OP_NOP, 0LL,    OP_NOP,  0LL); //
/*@5,1*/ exe(OP_ADD3,      &r11,          r19,      EXP_H3210,   r20,          EXP_H3210, r21, EXP_H3210, OP_NOP, 0LL,    OP_NOP,  0LL); //
/*@5,2*/ exe(OP_ADD,       &r12,          r22,      EXP_H3210,   r23,          EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL,    OP_NOP,  0LL); //
/*@6,0*/ exe(OP_ADD3,      &r00,          r10,      EXP_H3210,   r11,          EXP_H3210, r12, EXP_H3210, OP_NOP, 0LL,    OP_NOP,  0LL); //
/*@7,0*/ exe(OP_MCAS,      &r31,          0LL,      EXP_H3210,   r00,          EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL,    OP_NOP,  0LL); // FF if match
/*@7,0*/ mop(OP_STBR, 3,   &r31,          r0[CHIP]++, 0, MSK_D0, r0t[CHIP],    dwo,  0,   0,   (Ull)NULL,  dwo);
        :
      /* map#8 */
/*@56,1*/exe(OP_ADD,       &t8[CHIP],     t8[CHIP], EXP_H3210,   1LL,          EXP_H3210, 0LL, EXP_H3210, OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL);
/*@57,0*/exe(OP_MCAS,      &r00,          slen8,    EXP_H3210,   1,            EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL,    OP_NOP,  0LL);
/*@57,1*/exe(OP_MCAS,      &r01,          slen8,    EXP_H3210,   2,            EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL,    OP_NOP,  0LL);
/*@57,2*/exe(OP_MCAS,      &r02,          slen8,    EXP_H3210,   3,            EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL,    OP_NOP,  0LL);
/*@57,3*/exe(OP_MCAS,      &r03,          slen8,    EXP_H3210,   4,            EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL,    OP_NOP,  0LL);
/*@57,0*/mop(OP_LDBR,  1,  &BR[57][0][1], t8[CHIP], 0,   MSK_D0, t7t[CHIP],    dwi,  0,   0,   (Ull)NULL,  dwi);
/*@57,0*/mop(OP_LDBR,  1,  &BR[57][0][0], t8[CHIP], 1,   MSK_D0, t7t[CHIP],    dwi,  0,   0,   (Ull)NULL,  dwi);
/*@57,1*/mop(OP_LDBR,  1,  &BR[57][1][1], t8[CHIP], 2,   MSK_D0, t7t[CHIP],    dwi,  0,   0,   (Ull)NULL,  dwi);
/*@57,1*/mop(OP_LDBR,  1,  &BR[57][1][0], t8[CHIP], 3,   MSK_D0, t7t[CHIP],    dwi,  0,   0,   (Ull)NULL,  dwi);
/*@57,2*/mop(OP_LDBR,  1,  &BR[57][2][1], t8[CHIP], 4,   MSK_D0, t7t[CHIP],    dwi,  0,   0,   (Ull)NULL,  dwi);
/*@57,2*/mop(OP_LDBR,  1,  &BR[57][2][0], t8[CHIP], 5,   MSK_D0, t7t[CHIP],    dwi,  0,   0,   (Ull)NULL,  dwi);
/*@57,3*/mop(OP_LDBR,  1,  &BR[57][3][1], t8[CHIP], 6,   MSK_D0, t7t[CHIP],    dwi,  0,   0,   (Ull)NULL,  dwi);
/*@57,3*/mop(OP_LDBR,  1,  &BR[57][3][0], t8[CHIP], 7,   MSK_D0, t7t[CHIP],    dwi,  0,   0,   (Ull)NULL,  dwi);
/*@58,0*/exe(OP_CMP_NE,    &r16,          c80,      EXP_H3210,   BR[57][0][1], EXP_H3210, 0LL, EXP_H3210, OP_AND, r00,    OP_NOP,  0LL); // 1 if unmatch
/*@58,1*/exe(OP_CMP_NE,    &r17,          c81,      EXP_H3210,   BR[57][0][0], EXP_H3210, 0LL, EXP_H3210, OP_AND, r01,    OP_NOP,  0LL); // 1 if unmatch
/*@58,2*/exe(OP_CMP_NE,    &r18,          c82,      EXP_H3210,   BR[57][1][1], EXP_H3210, 0LL, EXP_H3210, OP_AND, r02,    OP_NOP,  0LL); // 1 if unmatch
/*@58,3*/exe(OP_CMP_NE,    &r19,          c83,      EXP_H3210,   BR[57][1][0], EXP_H3210, 0LL, EXP_H3210, OP_AND, r03,    OP_NOP,  0LL); // 1 if unmatch
/*@59,0*/exe(OP_MCAS,      &r04,          slen8,    EXP_H3210,   5,            EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL,    OP_NOP,  0LL);
/*@59,1*/exe(OP_MCAS,      &r05,          slen8,    EXP_H3210,   6,            EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL,    OP_NOP,  0LL);
/*@59,2*/exe(OP_MCAS,      &r06,          slen8,    EXP_H3210,   7,            EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL,    OP_NOP,  0LL);
/*@59,3*/exe(OP_MCAS,      &r07,          slen8,    EXP_H3210,   8,            EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL,    OP_NOP,  0LL);
/*@60,0*/exe(OP_CMP_NE,    &r20,          c84,      EXP_H3210,   BR[57][2][1], EXP_H3210, 0LL, EXP_H3210, OP_AND, r04,    OP_NOP,  0LL); // 1 if unmatch
/*@60,1*/exe(OP_CMP_NE,    &r21,          c85,      EXP_H3210,   BR[57][2][0], EXP_H3210, 0LL, EXP_H3210, OP_AND, r05,    OP_NOP,  0LL); // 1 if unmatch
/*@60,2*/exe(OP_CMP_NE,    &r22,          c86,      EXP_H3210,   BR[57][3][1], EXP_H3210, 0LL, EXP_H3210, OP_AND, r06,    OP_NOP,  0LL); // 1 if unmatch
/*@60,3*/exe(OP_CMP_NE,    &r23,          c87,      EXP_H3210,   BR[57][3][0], EXP_H3210, 0LL, EXP_H3210, OP_AND, r07,    OP_NOP,  0LL); // 1 if unmatch
/*@61,0*/exe(OP_ADD3,      &r10,          r16,      EXP_H3210,   r17,          EXP_H3210, r18, EXP_H3210, OP_NOP, 0LL,    OP_NOP,  0LL); //
/*@61,1*/exe(OP_ADD3,      &r11,          r19,      EXP_H3210,   r20,          EXP_H3210, r21, EXP_H3210, OP_NOP, 0LL,    OP_NOP,  0LL); //
/*@61,2*/exe(OP_ADD,       &r12,          r22,      EXP_H3210,   r23,          EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL,    OP_NOP,  0LL); //
/*@62,0*/exe(OP_ADD3,      &r00,          r10,      EXP_H3210,   r11,          EXP_H3210, r12, EXP_H3210, OP_NOP, 0LL,    OP_NOP,  0LL); //
/*@63,0*/exe(OP_MCAS,      &r31,          0LL,      EXP_H3210,   r00,          EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL,    OP_NOP,  0LL); // FF if match
/*@63,0*/mop(OP_STBR, 3,   &r31,          r8[CHIP]++, 0, MSK_D0, r8t[CHIP],    dwo,  0,   0,   (Ull)NULL,  dwo);
      }
    }
//EMAX5A end
//EMAX5A drain_dirty_lmm
  }
}
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\epsfile{file=pbmsrch+rmm-search-emax6.eps,width=1.00\textwidth}
\caption{文字列検索}
\end{figure}

\clearpage

\subsection{16x16畳み込み}

\shabox{
\leftline{cent\% make -f Makefile-csim.emax6+dma all clean}
\leftline{cent\% ../../src/csim/csim -x conv16-csim.emax6+dma}
}

\shabox{
\leftline{zynq\% make -f Makefile-zynq.emax6+dma all clean}
\leftline{zynq\% ./conv16-zynq.emax6+dma}
}

\vskip .1in

16x16の畳み込み演算である．一度のバースト演算により1行分のみ計算する．ステン
シル計算でありmapdist=2である．

\begin{screen}
\tiny
\begin{verbatim}
conv16_x1(float *yi, float *yo)
{
 Ull  loop = image_WD/2-8;
 Ull  x = 8;
#if !defined(EMAX5) && !defined(EMAX6)
 while (loop--) {
 yo[x]= yim8[x-8]*SCON[  0]+yim8[x-7]*SCON[  1]+yim8[x-6]*SCON[  2]+yim8[x-5]*SCON[  3]+yim8[x-4]*SCON[  4]+yim8[x-3]*SCON[  5]+yim8[x-2]*SCON[  6]+yim8[x-1]*SCON[  7]
      + yim8[x+0]*SCON[  8]+yim8[x+1]*SCON[  9]+yim8[x+2]*SCON[ 10]+yim8[x+3]*SCON[ 11]+yim8[x+4]*SCON[ 12]+yim8[x+5]*SCON[ 13]+yim8[x+6]*SCON[ 14]+yim8[x+7]*SCON[ 15]
      + yim7[x-8]*SCON[ 16]+yim7[x-7]*SCON[ 17]+yim7[x-6]*SCON[ 18]+yim7[x-5]*SCON[ 19]+yim7[x-4]*SCON[ 20]+yim7[x-3]*SCON[ 21]+yim7[x-2]*SCON[ 22]+yim7[x-1]*SCON[ 23]
      + yim7[x+0]*SCON[ 24]+yim7[x+1]*SCON[ 25]+yim7[x+2]*SCON[ 26]+yim7[x+3]*SCON[ 27]+yim7[x+4]*SCON[ 28]+yim7[x+5]*SCON[ 29]+yim7[x+6]*SCON[ 30]+yim7[x+7]*SCON[ 31]
      + yim6[x-8]*SCON[ 32]+yim6[x-7]*SCON[ 33]+yim6[x-6]*SCON[ 34]+yim6[x-5]*SCON[ 35]+yim6[x-4]*SCON[ 36]+yim6[x-3]*SCON[ 37]+yim6[x-2]*SCON[ 38]+yim6[x-1]*SCON[ 39]
      :
      + yip1[x+0]*SCON[152]+yip1[x+1]*SCON[153]+yip1[x+2]*SCON[154]+yip1[x+3]*SCON[155]+yip1[x+4]*SCON[156]+yip1[x+5]*SCON[157]+yip1[x+6]*SCON[158]+yip1[x+7]*SCON[159]
      + yip2[x-8]*SCON[160]+yip2[x-7]*SCON[161]+yip2[x-6]*SCON[162]+yip2[x-5]*SCON[163]+yip2[x-4]*SCON[164]+yip2[x-3]*SCON[165]+yip2[x-2]*SCON[166]+yip2[x-1]*SCON[167]
      + yip2[x+0]*SCON[168]+yip2[x+1]*SCON[169]+yip2[x+2]*SCON[170]+yip2[x+3]*SCON[171]+yip2[x+4]*SCON[172]+yip2[x+5]*SCON[173]+yip2[x+6]*SCON[174]+yip2[x+7]*SCON[175]
      + yip3[x-8]*SCON[176]+yip3[x-7]*SCON[177]+yip3[x-6]*SCON[178]+yip3[x-5]*SCON[179]+yip3[x-4]*SCON[180]+yip3[x-3]*SCON[181]+yip3[x-2]*SCON[182]+yip3[x-1]*SCON[183]
      + yip3[x+0]*SCON[184]+yip3[x+1]*SCON[185]+yip3[x+2]*SCON[186]+yip3[x+3]*SCON[187]+yip3[x+4]*SCON[188]+yip3[x+5]*SCON[189]+yip3[x+6]*SCON[190]+yip3[x+7]*SCON[191]
      + yip4[x-8]*SCON[192]+yip4[x-7]*SCON[193]+yip4[x-6]*SCON[194]+yip4[x-5]*SCON[195]+yip4[x-4]*SCON[196]+yip4[x-3]*SCON[197]+yip4[x-2]*SCON[198]+yip4[x-1]*SCON[199]
      + yip4[x+0]*SCON[200]+yip4[x+1]*SCON[201]+yip4[x+2]*SCON[202]+yip4[x+3]*SCON[203]+yip4[x+4]*SCON[204]+yip4[x+5]*SCON[205]+yip4[x+6]*SCON[206]+yip4[x+7]*SCON[207]
      + yip5[x-8]*SCON[208]+yip5[x-7]*SCON[209]+yip5[x-6]*SCON[210]+yip5[x-5]*SCON[211]+yip5[x-4]*SCON[212]+yip5[x-3]*SCON[213]+yip5[x-2]*SCON[214]+yip5[x-1]*SCON[215]
      + yip5[x+0]*SCON[216]+yip5[x+1]*SCON[217]+yip5[x+2]*SCON[218]+yip5[x+3]*SCON[219]+yip5[x+4]*SCON[220]+yip5[x+5]*SCON[221]+yip5[x+6]*SCON[222]+yip5[x+7]*SCON[223]
      + yip6[x-8]*SCON[224]+yip6[x-7]*SCON[225]+yip6[x-6]*SCON[226]+yip6[x-5]*SCON[227]+yip6[x-4]*SCON[228]+yip6[x-3]*SCON[229]+yip6[x-2]*SCON[230]+yip6[x-1]*SCON[231]
      + yip6[x+0]*SCON[232]+yip6[x+1]*SCON[233]+yip6[x+2]*SCON[234]+yip6[x+3]*SCON[235]+yip6[x+4]*SCON[236]+yip6[x+5]*SCON[237]+yip6[x+6]*SCON[238]+yip6[x+7]*SCON[239]
      + yip7[x-8]*SCON[240]+yip7[x-7]*SCON[241]+yip7[x-6]*SCON[242]+yip7[x-5]*SCON[243]+yip7[x-4]*SCON[244]+yip7[x-3]*SCON[245]+yip7[x-2]*SCON[246]+yip7[x-1]*SCON[247]
      + yip7[x+0]*SCON[248]+yip7[x+1]*SCON[249]+yip7[x+2]*SCON[250]+yip7[x+3]*SCON[251]+yip7[x+4]*SCON[252]+yip7[x+5]*SCON[253]+yip7[x+6]*SCON[254]+yip7[x+7]*SCON[255];
 x += 2;
 }
#endif
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
  Ull  AR[64][4];                     /* output of EX     in each unit */
  Ull  BR[64][4][4];                  /* output registers in each unit */
  Ull  r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15;
  Ull  r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31;
  Ull c000=DCON[  0], c002=DCON[  1], c004=DCON[  2], c006=DCON[  3], c008=DCON[  4], c010=DCON[  5], c012=DCON[  6], c014=DCON[  7];
  Ull c016=DCON[  8], c018=DCON[  9], c020=DCON[ 10], c022=DCON[ 11], c024=DCON[ 12], c026=DCON[ 13], c028=DCON[ 14], c030=DCON[ 15];
  Ull c032=DCON[ 16], c034=DCON[ 17], c036=DCON[ 18], c038=DCON[ 19], c040=DCON[ 20], c042=DCON[ 21], c044=DCON[ 22], c046=DCON[ 23];
  Ull c048=DCON[ 24], c050=DCON[ 25], c052=DCON[ 26], c054=DCON[ 27], c056=DCON[ 28], c058=DCON[ 29], c060=DCON[ 30], c062=DCON[ 31];
  Ull c064=DCON[ 32], c066=DCON[ 33], c068=DCON[ 34], c070=DCON[ 35], c072=DCON[ 36], c074=DCON[ 37], c076=DCON[ 38], c078=DCON[ 39];
       :
  Ull c240=DCON[120], c242=DCON[121], c244=DCON[122], c246=DCON[123], c248=DCON[124], c250=DCON[125], c252=DCON[126], c254=DCON[127];
//EMAX5A begin x1 mapdist=2
  while (loop--) {                                  /* mapped to WHILE() on BR[15][0][0] stage#0 */
    mop(OP_LDR,  3, &BR[0][0][1], yim80++, 0, MSK_D0, yim80, 320, 0, 0, (Ull)NULL, 320); /* stage#0 */
    mop(OP_LDR,  3, &r1,          yim81++, 0, MSK_D0, yim80, 320, 0, 0, (Ull)NULL, 320); /* stage#0 */
    mop(OP_LDR,  3, &r2,          yim82++, 0, MSK_D0, yim80, 320, 0, 0, (Ull)NULL, 320); /* stage#0 */
    mop(OP_LDR,  3, &r3,          yim83++, 0, MSK_D0, yim80, 320, 0, 0, (Ull)NULL, 320); /* stage#0 */
    mop(OP_LDR,  3, &r4,          yim84++, 0, MSK_D0, yim80, 320, 0, 0, (Ull)NULL, 320); /* stage#0 */
    mop(OP_LDR,  3, &r5,          yim85++, 0, MSK_D0, yim80, 320, 0, 0, (Ull)NULL, 320); /* stage#0 */
    mop(OP_LDR,  3, &r6,          yim86++, 0, MSK_D0, yim80, 320, 0, 0, (Ull)NULL, 320); /* stage#0 */
    mop(OP_LDR,  3, &r7,          yim87++, 0, MSK_D0, yim80, 320, 0, 0, (Ull)NULL, 320); /* stage#0 */
    exe(OP_FMA, &r10, 0LL, EXP_H3210, BR[0][0][1], EXP_H3210, c000, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#1 */
    exe(OP_FMA, &r11, 0LL, EXP_H3210, r1,          EXP_H3210, c002, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#1 */
    exe(OP_FMA, &r12, 0LL, EXP_H3210, r2,          EXP_H3210, c004, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#1 */
    exe(OP_FMA, &r13, 0LL, EXP_H3210, r3,          EXP_H3210, c006, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#1 */
    exe(OP_FMA, &r20, r10, EXP_H3210, r4,          EXP_H3210, c008, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#2 */
    exe(OP_FMA, &r21, r11, EXP_H3210, r5,          EXP_H3210, c010, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#2 */
    exe(OP_FMA, &r22, r12, EXP_H3210, r6,          EXP_H3210, c012, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#2 */
    exe(OP_FMA, &r23, r13, EXP_H3210, r7,          EXP_H3210, c014, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#2 */
    mop(OP_LDR,  3, &BR[2][0][1], yim70++, 0, MSK_D0, yim70, 320, 0, 0, (Ull)NULL, 320); /* stage#2 */
    mop(OP_LDR,  3, &r1,          yim71++, 0, MSK_D0, yim70, 320, 0, 0, (Ull)NULL, 320); /* stage#2 */
    mop(OP_LDR,  3, &r2,          yim72++, 0, MSK_D0, yim70, 320, 0, 0, (Ull)NULL, 320); /* stage#2 */
    mop(OP_LDR,  3, &r3,          yim73++, 0, MSK_D0, yim70, 320, 0, 0, (Ull)NULL, 320); /* stage#2 */
    mop(OP_LDR,  3, &r4,          yim74++, 0, MSK_D0, yim70, 320, 0, 0, (Ull)NULL, 320); /* stage#2 */
    mop(OP_LDR,  3, &r5,          yim75++, 0, MSK_D0, yim70, 320, 0, 0, (Ull)NULL, 320); /* stage#2 */
    mop(OP_LDR,  3, &r6,          yim76++, 0, MSK_D0, yim70, 320, 0, 0, (Ull)NULL, 320); /* stage#2 */
    mop(OP_LDR,  3, &r7,          yim77++, 0, MSK_D0, yim70, 320, 0, 0, (Ull)NULL, 320); /* stage#2 */
        :
    exe(OP_FMA, &r10, r20, EXP_H3210, BR[30][0][1],EXP_H3210, c240, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#31 */
    exe(OP_FMA, &r11, r21, EXP_H3210, r1,          EXP_H3210, c242, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#31 */
    exe(OP_FMA, &r12, r22, EXP_H3210, r2,          EXP_H3210, c244, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#31 */
    exe(OP_FMA, &r13, r23, EXP_H3210, r3,          EXP_H3210, c246, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#31 */
    exe(OP_FMA, &r20, r10, EXP_H3210, r4,          EXP_H3210, c248, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#32 */
    exe(OP_FMA, &r21, r11, EXP_H3210, r5,          EXP_H3210, c250, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#32 */
    exe(OP_FMA, &r22, r12, EXP_H3210, r6,          EXP_H3210, c252, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#32 */
    exe(OP_FMA, &r23, r13, EXP_H3210, r7,          EXP_H3210, c254, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#32 */

    exe(OP_FAD, &r10,  r20, EXP_H3210,  r21, EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);        /* stage#33 */
    exe(OP_FAD, &r12,  r22, EXP_H3210,  r23, EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);        /* stage#33 */
    exe(OP_FAD, &AR[35][0],  r10, EXP_H3210,  r12, EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);  /* stage#35 */
    mop(OP_STR, 3, &AR[35][0], yoo++, 0LL, MSK_D0, (Ull)yoo, 152, 0, 0, yop, 152);                        /* stage#35 */
  }
//EMAX5A end
#endif
}
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\epsfile{file=conv16-x1-emax6.eps,width=1.00\textwidth}
\caption{16x16畳み込み}
\end{figure}

\clearpage

\subsection{VBGMM\_Logsum}

\shabox{
\leftline{cent\% make -f Makefile-csim.emax6+dma test016-csim.emax6+dma clean}
\leftline{cent\% ../../src/csim/csim -x test016-csim.emax6+dma}
}

\shabox{
\leftline{zynq\% make -f Makefile-zynq.emax6+dma test016-zynq.emax6+dma clean}
\leftline{zynq\% ./test016-zynq.emax6+dma}
}

\begin{screen}
\tiny
\begin{verbatim}
  for (chip=0; chip<NCHIP; chip++) { /* will be parallelized by multi-chip (M/#chip) */
    for (grp=M/NCHIP*chip; grp<M/NCHIP*(chip+1); grp+=RMGRP) { /* will be parallelized by multi-chip (M/#chip) */
      typedef struct {Uint i[4]} Ui4;
      Ui4  *c60 = C1+grp*M, *c600 = c60;
      Ull  row, bofs, rofs;
      Ull  b00;
      Ull  PARAM = 0x0000000100000001LL; /* 1 */
//EMAX5A begin x1 mapdist=0
/*2*/ for (INIT1=1,LOOP1=RMGRP,row=0-M*4; LOOP1--; INIT1=0) {                                                               /* stage#0 */
  /*1*/ for (INIT0=1,LOOP0=M/W,bofs=0-W*4; LOOP0--; INIT0=0) {                                                              /* stage#0 */
          exe(OP_ADD,    &bofs, INIT0?bofs:bofs, EXP_H3210, W*4, EXP_H3210, 0LL, EXP_H3210, OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL);/* stage#0 */
          exe(OP_ADD,    &row, row, EXP_H3210, INIT0?M*4:0, EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#0 */
          exe(OP_ADD,    &rofs, row, EXP_H3210, 0LL,  EXP_H3210, 0LL, EXP_H3210, OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL);/* stage#1 */

          mop(OP_LDWR,   1, &b00,  (Ull)c600, (Ull)rofs,  MSK_W0, (Ull)c60,  M*RMGRP, 0, 1, (Ull)NULL, M*RMGRP);            /* stage#2 */
          exe(OP_ADD,       &b00,  INIT0?b00:b00,   EXP_H3210,  PARAM,  EXP_H3210, 0LL,    EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);  /* stage#2 */
          mop(OP_STWR,   1, &b00,  (Ull)rofs, (Ull)c600,  MSK_D0, (Ull)c60,  M*RMGRP, 0, 1, (Ull)NULL, M*RMGRP);            /* stage#2 */
        }
      }
//EMAX5A end
//EMAX5A drain_dirty_lmm
    }
  }
\end{verbatim}
\end{screen}

\clearpage

\subsection{Stochastic sgemm00}

\shabox{
\leftline{cent\% make -f Makefile-csim.emax6+dma test021-csim.emax6+dma clean}
\leftline{cent\% ../../src/csim/csim -x test021-csim.emax6+dma}
}

\shabox{
\leftline{zynq\% make -f Makefile-zynq.emax6+dma test021-zynq.emax6+dma clean}
\leftline{zynq\% ./test021-zynq.emax6+dma}
}

\begin{figure}[htbp]
\center
\includegraphics[angle=270,origin=b,width=0.75\textwidth]{stochastic.eps}
\caption{Stochastic sgemm00}
\end{figure}

\begin{screen}
\tiny
\begin{verbatim}
for (top=0; top<BS/NCHIP; top+=H) { /* will be parallelized by multi-chip (M/#chip) */
  for (blk=0; blk<OC4; blk+=RMGRP) { /* 3重ループ展開の外側対象 */
    char *a[H][NCHIP];
    char *b, *b0;
    char *c[H][NCHIP], *c0[H][NCHIP];
    b = (Uchar*)i_m0B+blk*IC32; b0 = b+IC32*0;
    for (CHIP=0; CHIP<NCHIP; CHIP++) { /* will be parallelized by multi-chip (M/#chip) */
      for (k=0; k<H; k++) {
        a[k][CHIP] = (Uchar*)i_m0A+(CHIP*BS/NCHIP+top+k)*IC32;
        c[k][CHIP] = (Uchar*)i_m0C+(CHIP*BS/NCHIP+top+k)*OC4+blk;
        c0[k][CHIP]= c[k][CHIP]+0;
      }
    }

#define spike01_core1(r, s) \
  mo4(OP_LDRQ,  1,  BR[r][2], (Ull)b0,                  (Ull)bofs,        MSK_W1,    (Ull)b,          IC32D4RMGRP, 0,      0,   (Ull)NULL, IC32D4RMGRP);/* stage#2 */\
  mo4(OP_LDRQ,  1,  BR[r][1], (Ull)a[s][CHIP],          (Ull)cofs,        MSK_W1,    (Ull)a[s][CHIP], IC32D4,      0,      0,   (Ull)NULL, IC32D4);     /* stage#2 */\
  exe(OP_NOP,      &AR[r][0], 0LL,           EXP_H3210, 0LL,              EXP_H3210, 0LL,             EXP_H3210,   OP_NOP, 0LL, OP_NOP,    0LL);        /* stage#2 */\
  mop(OP_LDBR,  1, &b00,      (Ull)c0[s][CHIP],         (Ull)oofs,        MSK_W0,    (Ull)c[s][CHIP], RMGRPD4,     0,      1,   (Ull)NULL, RMGRPD4);    /* stage#2 */\
  ex4(OP_SFMA,     &b00,      INIT0?b00:b00, EXP_H3210, BR[r][1],         EXP_H3210, BR[r][2],        EXP_H3210,   OP_NOP, 3LL, OP_NOP,    0LL);        /* stage#2 */\
  mop(OP_STBR,  1, &b00,      (Ull)oofs,                (Ull)c0[s][CHIP], MSK_D0,    (Ull)c[s][CHIP], RMGRPD4,     0,      1,   (Ull)NULL, RMGRPD4)     /* stage#2 */

//EMAX5A begin smax2 mapdist=0
  /*3*/ for (CHIP=0; CHIP<NCHIP; CHIP++) { /* will be parallelized by multi-chip (M/#chip) */
/*2*/ for (INIT1=1,LOOP1=RMGRP,rofs=(0-IC32)<<32|((0-1LL)&0xffffffff); LOOP1--; INIT1=0) {      /* stage#0 *//* mapped to FOR() on BR[63][1][0] */
  /*1*/ for (INIT0=1,LOOP0=IC32/32,cofs=(0-32LL)<<32|((0)&0xffffffff); LOOP0--; INIT0=0) {      /* stage#0 *//* mapped to FOR() on BR[63][0][0] */
          exe(OP_ADD,    &cofs, INIT0?cofs:cofs, EXP_H3210, (32LL)<<32|(0), EXP_H3210, 0LL, EXP_H3210, OP_AND, 0xffffffffffffffffLL, OP_NOP, 0LL); /* stage#0 */
          exe(OP_ADD,    &rofs, rofs, EXP_H3210, INIT0?IC321:0, EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);  /* stage#0 */
          exe(OP_ADD,    &bofs, rofs, EXP_H3210, cofs, EXP_H3210, 0, EXP_H3210, OP_AND, 0xffffffffffffffffLL, OP_NOP, 0LL);     /* stage#1 */
          exe(OP_ADD,    &oofs, rofs, EXP_H3210, cofs, EXP_H3210, 0, EXP_H3210, OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL);     /* stage#1 */

          spike01_core1( 2,  0);
          spike01_core1( 3,  1);
          spike01_core1( 4,  2);
          :
          spike01_core1(20, 18);
          spike01_core1(21, 19); /* H=20 */
          spike01_core1(22, 20);
          spike01_core1(23, 21);
          spike01_core1(24, 22);
          spike01_core1(25, 23);
          spike01_core1(26, 24); /* H=25 */
          :
          spike01_core1(50, 48);
          spike01_core1(51, 49); /* H=50 */
        }
      }
    }
//EMAX5A end
  }
}
//EMAX5A drain_dirty_lmm
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\epsfile{file=smax-smax2-emax6.eps,width=1.00\textwidth}
\caption{Stochastic sgemm00}
\end{figure}

\begin{figure}[htbp]
\center
\includegraphics[angle=270,origin=b,width=1.00\textwidth]{sfma1.eps}
\caption{SFMA 1st stage}
\end{figure}

\begin{figure}[htbp]
\center
\includegraphics[angle=270,origin=b,width=1.00\textwidth]{sfma2.eps}
\caption{SFMA 2nd and 3rd stage}
\end{figure}

\clearpage

\subsection{Sparse matrix multiplication}

\shabox{
\leftline{cent\% make -f Makefile-csim.emax6+dma test022-csim.emax6+dma clean}
\leftline{cent\% ../../src/csim/csim -x test022-csim.emax6+dma}
}

\shabox{
\leftline{zynq\% make -f Makefile-zynq.emax6+dma test022-zynq.emax6+dma clean}
\leftline{zynq\% ./test022-zynq.emax6+dma}
}

\begin{figure}[htbp]
\center
\includegraphics[angle=270,origin=b,width=0.75\textwidth]{sparse_mat.eps}
\caption{Sparse matrix multiplication}
\end{figure}

\subsubsection{Single flow}

\begin{screen}
\tiny
\begin{verbatim}
for (blk=0; blk<M2; blk+=RMGRP) { /* 3重ループ展開の外側対象 */
  for (top=0; top<M1/NCHIP; top+=H) { /* will be parallelized by multi-chip (M/#chip) */
    packed *a[H][NCHIP], *a0[H][NCHIP];
    packed *b, *b0[H];
    float  *c[H][NCHIP], *c0[H][NCHIP];
    b = B32_P+blk*LP;
    for (CHIP=0; CHIP<NCHIP; CHIP++) { /* will be parallelized by multi-chip (M/#chip) */
      for (k=0; k<H; k++) {
        a[k][CHIP]  = A32_P+(CHIP*M1/NCHIP+top+k)*LP;
        c[k][CHIP]  = C32_1+(CHIP*M1/NCHIP+top+k)*M2+blk;
        c0[k][CHIP] = c[k][CHIP]+0;
      }
    }

#define sparse_core1(r, h) \
  mex(OP_CMPA_LE,  &b0[h], INIT0?b:b0[h], INIT0?0:8, OP_CMPA_GE, &a0[h][CHIP], INIT0?a[h][CHIP]:a0[h][CHIP], INIT0?0:8, 0LL, BR[r][2][1], BR[r][2][0]);\
  mop(OP_LDR,   3, &BR[r][2][1], b0[h],                        bofs,        MSK_W1,      b,          2*LP*RMGRP,  0, 0,      NULL,      2*LP*RMGRP);/*LMM[2] col2*/\
  mop(OP_LDR,   3, &BR[r][2][0], a0[h][CHIP],                  bofs,        MSK_W0,      a[h][CHIP], 2*LP,        0, 0,      NULL,      2*LP);      /*LMM[1] col2*/\
  exe(OP_NOP,      &AR[r][0],    0LL,                          EXP_H3210,   0,           EXP_H3210,  0,           EXP_H3210, OP_NOP, 0, OP_NOP, 0);\
  mop(OP_LDWR,  1, &c00,         c0[h][CHIP],                  oofs,        MSK_W0,      c[h][CHIP], RMGRP,       0, 1,      NULL,      RMGRP);\
  exe(OP_CFMA,     &c00,         INIT0?c00:c00,                EXP_H3210,   BR[r][2][1], EXP_H3210,  BR[r][2][0], EXP_H3210, OP_NOP, 0, OP_NOP, 0);\
  mop(OP_STWR,  1, &c00,         oofs,                         c0[h][CHIP], MSK_D0,      c[h][CHIP], RMGRP,       0, 1,      NULL,      RMGRP)

//EMAX5A begin imax mapdist=0
/**/for (CHIP=0; CHIP<NCHIP; CHIP++) { /* will be parallelized by multi-chip (M/#chip) */
/*2*/ for (INIT1=1,LOOP1=RMGRP,rofs=(0-LP*8)<<32|((0-4LL)&0xffffffff); LOOP1--; INIT1=0) { /* stage#0 *//* mapped to FOR() on BR[63][1][0] */
  /*1*/ for (INIT0=1,LOOP0=LP,cofs=(0LL)<<32|((0LL)&0xffffffff); LOOP0--; INIT0=0) {         /* stage#0 *//* mapped to FOR() on BR[63][0][0] */
          exe(OP_ADD,    &rofs, rofs, EXP_H3210, INIT0?(LP*8)<<32|(4LL):0, EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL,                  OP_NOP, 0LL); /* stage#0 */
          exe(OP_ADD,    &bofs, rofs, EXP_H3210, 0LL,                      EXP_H3210, 0LL, EXP_H3210, OP_AND, 0xffffffff00000000LL, OP_NOP, 0LL); /* stage#1 */
          exe(OP_ADD,    &oofs, rofs, EXP_H3210, 0LL,                      EXP_H3210, 0LL, EXP_H3210, OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL); /* stage#1 */

          sparse_core1(  2,  0);
          sparse_core1(  3,  1);
          sparse_core1(  4,  2);
          sparse_core1(  5,  3);
          sparse_core1(  6,  4);
          sparse_core1(  7,  5);
          sparse_core1(  8,  6);
          sparse_core1(  9,  7);
          sparse_core1( 10,  8);
          sparse_core1( 11,  9);
          sparse_core1( 12, 10);
          sparse_core1( 13, 11);
          sparse_core1( 14, 12);
          sparse_core1( 15, 13);
          sparse_core1( 16, 14);
          sparse_core1( 17, 15); /* H=16 */
        }
      }
    }
//EMAX5A end
  }
}
//EMAX5A drain_dirty_lmm
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\includegraphics[angle=270,origin=b,width=1.00\textwidth]{SPMM.eps}
\caption{Data path for sparse matrix multiplication}
\end{figure}

\begin{figure}[htbp]
\center
\epsfile{file=EMAX6PIP.eps,width=1.00\textwidth}
\caption{Timing chart (single flow)}
\end{figure}

\begin{figure}[htbp]
\center
\epsfile{file=test022-imax-emax6.eps,width=1.00\textwidth}
\caption{Sparse matrix multiplication (single flow)}
\end{figure}

\clearpage

\subsubsection{Dual flow}

\begin{screen}
\tiny
\begin{verbatim}
  for (blk=0; blk<M2; blk+=RMGRP) { /* 3重ループ展開の外側対象 */
    for (top=0; top<M1/NCHIP; top+=H) { /* will be parallelized by multi-chip (M/#chip) */
      packed *a[H][NCHIP], *a0[H][2][NCHIP]; /* aは共通,a0は同一行を参照(移動パターンが違うので2つ必要) */
      packed *b[2],        *b0[H][2];        /* bは共通,b0の2行を1unitにマルチスレッド化すればcが連続 */
      float  *c[H][NCHIP], *c0[H][2][NCHIP]; /* cは共通,c0は連続 */
      b[0] = B32_P+(blk+0)*LP;
      b[1] = B32_P+(blk+1)*LP;
      for (CHIP=0; CHIP<NCHIP; CHIP++) { /* will be parallelized by multi-chip (M/#chip) */
        for (k=0; k<H; k++) {
          a[k][CHIP]  = A32_P+(CHIP*M1/NCHIP+top+k)*LP;
          c[k][CHIP]  = C32_1+(CHIP*M1/NCHIP+top+k)*M2+blk;
          c0[k][0][CHIP] = c[k][CHIP]+0;
          c0[k][1][CHIP] = c[k][CHIP]+1;
      } }
#define sparse_core1(r, h) \
  mex(OP_CMPA_LE, &b0[h][0], INIT0?b[0]:b0[h][0], INIT0?0:8, OP_CMPA_GE, &a0[h][0][CHIP], INIT0?a[h][CHIP]:a0[h][0][CHIP], INIT0?0:8, 0LL, BR[r][2][1], BR[r][2][0]);\
  mop(OP_LDR,   3, &BR[r][2][1],    b0[h][0],                        bofs,           MSK_W1,      b[0],          2*LP*RMGRP,  0, 0,      NULL,      2*LP*RMGRP);\
  mop(OP_LDR,   3, &BR[r][2][0],    a0[h][0][CHIP],                  bofs,           MSK_W0,      a[h][CHIP],    2*LP,        0, 0,      NULL,      2*LP);\
  mex(OP_CMPA_LE, &b0[h][1], INIT0?b[1]:b0[h][1], INIT0?0:8, OP_CMPA_GE, &a0[h][1][CHIP], INIT0?a[h][CHIP]:a0[h][1][CHIP], INIT0?0:8, 0LL, BR[r][3][1], BR[r][3][0]);\
  mop(OP_LDR,   3, &BR[r][3][1],    b0[h][1],                        bofs,           MSK_W1,      b[0],          2*LP*RMGRP,  0, 0,      NULL,      2*LP*RMGRP);\
  mop(OP_LDR,   3, &BR[r][3][0],    a0[h][1][CHIP],                  bofs,           MSK_W0,      a[h][CHIP],    2*LP,        0, 0,      NULL,      2*LP);\
  exe(OP_NOP,      &AR[r][0],       0LL,                             EXP_H3210,      0,           EXP_H3210,     0,           EXP_H3210, OP_NOP, 0, OP_NOP, 0);\
  mop(OP_LDWR,  1, &c00,            c0[h][0][CHIP],                  oofs,           MSK_W0,      c[h][CHIP],    RMGRP,       0, 1,      NULL,      RMGRP);\
  exe(OP_CFMA,     &c00,            INIT0?c00:c00,                   EXP_H3210,      BR[r][2][1], EXP_H3210,     BR[r][2][0], EXP_H3210, OP_NOP, 0, OP_NOP, 0);\
  mop(OP_STWR,  1, &c00,            oofs,                            c0[h][0][CHIP], MSK_D0,      c[h][CHIP],    RMGRP,       0, 1,      NULL,      RMGRP);\
  mop(OP_LDWR,  1, &c01,            c0[h][1][CHIP],                  oofs,           MSK_W0,      c[h][CHIP],    RMGRP,       0, 1,      NULL,      RMGRP);\
  exe(OP_CFMA,     &c01,            INIT0?c01:c01,                   EXP_H3210,      BR[r][3][1], EXP_H3210,     BR[r][3][0], EXP_H3210, OP_NOP, 0, OP_NOP, 0);\
  mop(OP_STWR,  1, &c01,            oofs,                            c0[h][1][CHIP], MSK_D0,      c[h][CHIP],    RMGRP,       0, 1,      NULL,      RMGRP)
//EMAX5A begin imax mapdist=0
/*3*/ for (CHIP=0; CHIP<NCHIP; CHIP++) { /* will be parallelized by multi-chip (M/#chip) */
  /*2*/ for (INIT1=1,LOOP1=RMGRP/2,rofs=(0-8*LP*2)<<32|((0-8LL)&0xffffffff); LOOP1--; INIT1=0) { /* stage#0 *//* mapped to FOR() on BR[63][1][0] */
    /*1*/ for (INIT0=1,LOOP0=LP,cofs=(0LL)<<32|((0LL)&0xffffffff); LOOP0--; INIT0=0) {         /* stage#0 *//* mapped to FOR() on BR[63][0][0] */
            exe(OP_ADD,    &rofs, rofs,            EXP_H3210, INIT0?(8*LP*2)<<32|(8LL):0, EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL,                  OP_NOP, 0LL);
            exe(OP_ADD,    &bofs, rofs,            EXP_H3210, 0LL,                        EXP_H3210, 0LL, EXP_H3210, OP_AND, 0xffffffff00000000LL, OP_NOP, 0LL);
            exe(OP_ADD,    &oofs, rofs,            EXP_H3210, 0LL,                        EXP_H3210, 0LL, EXP_H3210, OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL);
            sparse_core1(  2,  0);
            sparse_core1(  3,  1); /* H=2 */
            sparse_core1(  4,  2);
            sparse_core1(  5,  3); /* H=4 */
            sparse_core1(  6,  4);
            sparse_core1(  7,  5);
            sparse_core1(  8,  6);
            sparse_core1(  9,  7); /* H=8 */
            sparse_core1( 10,  8);
            sparse_core1( 11,  9);
            sparse_core1( 12, 10);
            sparse_core1( 13, 11);
            sparse_core1( 14, 12);
            sparse_core1( 15, 13);
            sparse_core1( 16, 14);
            sparse_core1( 17, 15); /* H=16 */
      } } }
//EMAX5A end
  } }
//EMAX5A drain_dirty_lmm
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\epsfile{file=EMAX6PIP2.eps,width=1.00\textwidth}
\caption{Timing chart (dual flow)}
\end{figure}

\begin{figure}[htbp]
\center
\epsfile{file=test022-imax-emax62.eps,width=1.00\textwidth}
\caption{Sparse matrix multiplication (dual flow)}
\end{figure}

\clearpage

\subsection{Sparse matrix compression}

\shabox{
\leftline{cent\% make -f Makefile-csim.emax6+dma test024-csim.emax6+dma clean}
\leftline{cent\% ../../src/csim/csim -x test024-csim.emax6+dma}
}

\shabox{
\leftline{zynq\% make -f Makefile-zynq.emax6+dma test024-zynq.emax6+dma clean}
\leftline{zynq\% ./test024-zynq.emax6+dma}
}

\vskip .1in

密行列を疎行列圧縮表現に変換する．mapdist=0のまま，同一LMMの前半と後半を交互
に使って，ダブルバッファリングする．前回実行結果のdrainと，圧縮演算と，次回
実行に必要な密行列のロードを同時に実行することで，高速化している．mop()中で
f=1にすることで，BasIPの毎回のDDRへの書き戻しを抑制している(最初の1回だけ
loadが増えるのは仕方ない)．

\begin{screen}
\tiny
\begin{verbatim}
  *Bas1P = B32_P-1; /* end of B32_0 */
  for (i=0; i<M1; i+=RMGRP) {
    r1     = (Ull)(i*M2-1)<<32;
    ibase0 = B32_0+i*M2;
    itop0  = B32_0+i*M2;
    itop1  = itop0+RMGRP*M2;
    obase0 = *Bas1P;   /* end of B32_0 */
    otop1  = otop0;
    otop0  = *Bas1P+8; /* top of B32_P */

//with-prefetch/post-drain
//EMAX5A begin imax mapdist=0
/*3*/for (CHIP=0; CHIP<NCHIP; CHIP++) {
  /*2*/for (INIT1=1,LOOP1=RMGRP,rofs=0; LOOP1--; INIT1=0) {
    /*1*/for (INIT0=1,LOOP0=M2,cofs=0; LOOP0--; INIT0=0) {
           mop(OP_LDWR, 1,   &r0,       ibase0++,          0,             MSK_D0,    itop0, M2*RMGRP,    0,       0,    itop1,  M2*RMGRP);
           exe(OP_ADD,       &r1,       r1,     EXP_H3210, 0x100000000LL, EXP_H3210, 0,     EXP_H3210,   OP_NOP,  0,    OP_NOP, 0LL);
           exe(OP_NOP,       &std,      r1,     EXP_H3210, 0,             EXP_H3210, 0,     EXP_H3210,   OP_OR,   r0,   OP_NOP, 0LL);
           exe(OP_CMP_EQ,    &cc0,      r0,     EXP_H1010, 0x00000000LL,  EXP_H1010, 0,     EXP_H3210,   OP_NOP,  0,    OP_NOP, 0LL);
           exe(OP_CMP_EQ,    &cc1,      r0,     EXP_H1010, 0x80000000LL,  EXP_H1010, 0,     EXP_H3210,   OP_NOP,  0,    OP_NOP, 0LL);
           exe(OP_NOP,       &cc2,      cc0,    EXP_H3210, 0,             EXP_H3210, 0,     EXP_H1010,   OP_OR,   cc1,  OP_NOP, 0LL);
           exe(OP_CMOV,      &oofs,     cc2,    EXP_H3210, 0,             EXP_H3210, 8,     EXP_H3210,   OP_NOP,  0,    OP_NOP, 0LL);
           exe(OP_ADD,       &obase0,   obase0, EXP_H3210, oofs,          EXP_H3210, 0,     EXP_H3210,   OP_NOP,  0,    OP_NOP, 0LL);
           mop(OP_STR,  3,   &obase0,   Bas1P,             0,             MSK_D0,    Bas1P, 2,           0,       0,    NULL,   2);
           exe(OP_NOP,       &AR[5][0], 0,   EXP_H3210,    0,             EXP_H3210, 0,     EXP_H1010,   OP_NOP,  0,    OP_NOP, 0LL);
           cex(OP_CEXE,      &ex0,      0, 0, 0, cc2, 0x0001);
           mop(OP_STR,  ex0, &std,      obase0,            0,             MSK_D0,    otop0, LP*2*RMGRP,  0,       0,    otop1,  LP*2*RMGRP);
         }
       }
     }
//EMAX5A end
//EMAX5A drain_dirty_lmm
  }
  count1 = (packed*)*Bas1P-(packed*)B32_P+1;
  printf("Bas1P=%08.8x_%08.8x Packed=%d\n", (Uint)(*Bas1P>>32), (Uint)*Bas1P, count1);
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\epsfile{file=test024-imax-emax6.eps,width=1.00\textwidth}
\caption{Sparse matrix compression}
\end{figure}

\clearpage

\section{2D-imaging}

\shabox{
\leftline{cent\% make -f Makefile-csim.emax6+dma all clean}
\leftline{cent\% ../../src/csim/csim -x filter-csim.emax6+dma -f 81.ppm 82.ppm}
}

\shabox{
\leftline{zynq\% make -f Makefile-zynq.emax6+dma all clean}
\leftline{zynq\% ./filter-zynq.emax6+dma -f 81.ppm 82.ppm}
}

\subsection{Tone\_curve}

\begin{figure}[htbp]
\center
\includegraphics[angle=270,origin=b,width=0.75\textwidth]{tone_curve.eps}
\caption{Tone curve}
\end{figure}

RGB各色の変換テーブルに基づき，画像を色変換する．一度のバースト演算により，
10箇所（OMAP=10）の各々について，6行分の演算を行う（RMGRP=6）．ステンシル計
算ではないためmapdist=0である．なお，未使用stageを使用したPLOADにより性能向
上が可能である．

\begin{screen}
\tiny
\begin{verbatim}
void tone_curve(Uint *r, Uint *d, Uchar *t) /* R, D, lut */
#if !defined(EMAX5) && !defined(EMAX6)
  for (top=PAD; top<HT-PAD; top++) { /* will be parallelized by multi-chip (M/#chip) */
    for (cofs=PAD; cofs<WD-PAD; cofs++) {
      Uint pix = *(r+top*WD+cofs);
      *(d+top*WD+cofs) = ((t)[pix>>24])<<24 | (t[256+((pix>>16)&255)])<<16 | (t[512+((pix>>8)&255)])<<8;
    }
  }
#endif
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
  for (top=0; top<RRANGE; top+=RMGRP) { /* will be parallelized by multi-chip (M/#chip) */
    for (CHIP=0; CHIP<NCHIP; CHIP++) { /* will be parallelized by multi-chip (M/#chip) */
      for (rofs=0; rofs<RMGRP; rofs++) { /* will be parallelized by multi-chip (M/#chip) */
        int idx = (CHIP*RRANGE*OMAP+top+rofs)*WD;
        for (cofs=PAD; cofs<WD-PAD; cofs++) {
          for (oc=0; oc<OMAP; oc++) {
            Uint pix = *(r+idx+oc*RRANGE*WD+cofs);
            *(d+idx+oc*RRANGE*WD+cofs) = ((t)[pix>>24])<<24 | (t[256+((pix>>16)&255)])<<16 | (t[512+((pix>>8)&255)])<<8;
          }
        }
      }
    }
  }
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
  Ull  LOOP1, LOOP0;
  Ull  INIT1, INIT0;
  Ull  AR[64][4];                     /* output of EX     in each unit */
  Ull  BR[64][4][4];                  /* output registers in each unit */
  Ull  r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15;
  Ull  r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31;
  Ull  cc0, cc1, cc2, cc3, ex0, ex1;
  for (top=0; top<RRANGE; top+=RMGRP) {
    Ull  rtop0[NCHIP], dtop0[NCHIP];
    Ull  rtop1[NCHIP], dtop1[NCHIP];
    Ull  rtop2[NCHIP], dtop2[NCHIP];
    Ull  rtop3[NCHIP], dtop3[NCHIP];
    Ull  rtop4[NCHIP], dtop4[NCHIP];
    Ull  rtop5[NCHIP], dtop5[NCHIP];
    Ull  rtop6[NCHIP], dtop6[NCHIP];
    Ull  rtop7[NCHIP], dtop7[NCHIP];
    Ull  rtop8[NCHIP], dtop8[NCHIP];
    Ull  rtop9[NCHIP], dtop9[NCHIP];
    for (CHIP=0; CHIP<NCHIP; CHIP++) { /* output channels are parallelized by multi-chip (OC/#chip) */
      rtop0[CHIP] = r+(CHIP*RRANGE*OMAP+RRANGE*0+top)*WD; dtop0[CHIP] = d+(CHIP*RRANGE*OMAP+RRANGE*0+top)*WD;
        :
      rtop9[CHIP] = r+(CHIP*RRANGE*OMAP+RRANGE*9+top)*WD; dtop9[CHIP] = d+(CHIP*RRANGE*OMAP+RRANGE*9+top)*WD;
    }
//EMAX5A begin tone_curve mapdist=0
    for (CHIP=0; CHIP<NCHIP; CHIP++) { /* output channels are parallelized by multi-chip (OC/#chip) */
 /*2*/for (INIT1=1,LOOP1=RMGRP,rofs=0-WD*4; LOOP1--; INIT1=0) {      /* stage#0 *//* mapped to FOR() on BR[63][1][0] */
   /*1*/for (INIT0=1,LOOP0=WD,cofs=0-4; LOOP0--; INIT0=0) {          /* stage#0 *//* mapped to FOR() on BR[63][0][0] */
          exe(OP_ADD,  &cofs, INIT0?cofs:cofs, EXP_H3210, 4, EXP_H3210, 0LL, EXP_H3210, OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL);  /* stage#0 */
          exe(OP_ADD,  &rofs, rofs, EXP_H3210, INIT0?WD*4:0, EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);                   /* stage#0 */
          exe(OP_ADD,  &pofs, rofs, EXP_H3210, cofs, EXP_H3210, 0LL, EXP_H3210, OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL);          /* stage#1 */
          /*map0*/
          mop(OP_LDWR,  1, &BR[2][1][1], (Ull)rtop0[CHIP], pofs,  MSK_D0, (Ull)rtop0[CHIP], WD*RMGRP, 0, 0, (Ull)NULL, WD*RMGRP);    /* stage#2 */
          mop(OP_LDBR,  1, &BR[3][1][1], (Ull)t1,    BR[2][1][1], MSK_B3, (Ull)t1, 256/4,  0,  0, (Ull)NULL, 256/4);                 /* stage#3 */
          mop(OP_LDBR,  1, &BR[3][2][1], (Ull)t2,    BR[2][1][1], MSK_B2, (Ull)t2, 256/4,  0,  0, (Ull)NULL, 256/4);                 /* stage#3 */
          mop(OP_LDBR,  1, &BR[3][3][1], (Ull)t3,    BR[2][1][1], MSK_B1, (Ull)t3, 256/4,  0,  0, (Ull)NULL, 256/4);                 /* stage#3 */
          exe(OP_MMRG, &r1, BR[3][1][1], EXP_H3210,  BR[3][2][1], EXP_H3210, BR[3][3][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#3 */
          mop(OP_STWR,  3, &r1,          (Ull)dtop0[CHIP], pofs,  MSK_D0, (Ull)dtop0[CHIP], WD*RMGRP, 0, 0, (Ull)NULL, WD*RMGRP);    /* stage#3 */
             :
          /*map5*/
          mop(OP_LDWR,  1, &BR[12][1][1],(Ull)rtop5[CHIP], pofs,  MSK_D0, (Ull)rtop5[CHIP], WD*RMGRP, 0, 0, (Ull)NULL, WD*RMGRP);    /* stage#12 */
          mop(OP_LDBR,  1, &BR[13][1][1],(Ull)t1,    BR[12][1][1],MSK_B3, (Ull)t1, 256/4,  0,  0, (Ull)NULL, 256/4);                 /* stage#13 */
          mop(OP_LDBR,  1, &BR[13][2][1],(Ull)t2,    BR[12][1][1],MSK_B2, (Ull)t2, 256/4,  0,  0, (Ull)NULL, 256/4);                 /* stage#13 */
          mop(OP_LDBR,  1, &BR[13][3][1],(Ull)t3,    BR[12][1][1],MSK_B1, (Ull)t3, 256/4,  0,  0, (Ull)NULL, 256/4);                 /* stage#13 */
          exe(OP_MMRG, &r1, BR[13][1][1],EXP_H3210,  BR[13][2][1],EXP_H3210, BR[13][3][1],EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#13 */
          mop(OP_STWR,  3, &r1,          (Ull)dtop5[CHIP], pofs,  MSK_D0, (Ull)dtop5[CHIP], WD*RMGRP, 0, 0, (Ull)NULL, WD*RMGRP);    /* stage#13 */
          /*map6*/
          mop(OP_LDWR,  1, &BR[14][1][1],(Ull)rtop6[CHIP], pofs,  MSK_D0, (Ull)rtop6[CHIP], WD*RMGRP, 0, 0, (Ull)NULL, WD*RMGRP);    /* stage#14 */
          mop(OP_LDBR,  1, &BR[15][1][1],(Ull)t1,    BR[14][1][1],MSK_B3, (Ull)t1, 256/4,  0,  0, (Ull)NULL, 256/4);                 /* stage#15 */
          mop(OP_LDBR,  1, &BR[15][2][1],(Ull)t2,    BR[14][1][1],MSK_B2, (Ull)t2, 256/4,  0,  0, (Ull)NULL, 256/4);                 /* stage#15 */
          mop(OP_LDBR,  1, &BR[15][3][1],(Ull)t3,    BR[14][1][1],MSK_B1, (Ull)t3, 256/4,  0,  0, (Ull)NULL, 256/4);                 /* stage#15 */
          exe(OP_MMRG, &r1, BR[15][1][1],EXP_H3210,  BR[15][2][1],EXP_H3210, BR[15][3][1],EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#15 */
          mop(OP_STWR,  3, &r1,          (Ull)dtop6[CHIP], pofs,  MSK_D0, (Ull)dtop6[CHIP], WD*RMGRP, 0, 0, (Ull)NULL, WD*RMGRP);    /* stage#15 */
          /*map7*/
          mop(OP_LDWR,  1, &BR[16][1][1],(Ull)rtop7[CHIP], pofs,  MSK_D0, (Ull)rtop7[CHIP], WD*RMGRP, 0, 0, (Ull)NULL, WD*RMGRP);    /* stage#16 */
          mop(OP_LDBR,  1, &BR[17][1][1],(Ull)t1,    BR[16][1][1],MSK_B3, (Ull)t1, 256/4,  0,  0, (Ull)NULL, 256/4);                 /* stage#17 */
          mop(OP_LDBR,  1, &BR[17][2][1],(Ull)t2,    BR[16][1][1],MSK_B2, (Ull)t2, 256/4,  0,  0, (Ull)NULL, 256/4);                 /* stage#17 */
          mop(OP_LDBR,  1, &BR[17][3][1],(Ull)t3,    BR[16][1][1],MSK_B1, (Ull)t3, 256/4,  0,  0, (Ull)NULL, 256/4);                 /* stage#17 */
          exe(OP_MMRG, &r1, BR[17][1][1],EXP_H3210,  BR[17][2][1],EXP_H3210, BR[17][3][1],EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#17 */
          mop(OP_STWR,  3, &r1,          (Ull)dtop7[CHIP], pofs,  MSK_D0, (Ull)dtop7[CHIP], WD*RMGRP, 0, 0, (Ull)NULL, WD*RMGRP);    /* stage#17 */
          /*map8*/
          mop(OP_LDWR,  1, &BR[18][1][1],(Ull)rtop8[CHIP], pofs,  MSK_D0, (Ull)rtop8[CHIP], WD*RMGRP, 0, 0, (Ull)NULL, WD*RMGRP);    /* stage#18 */
          mop(OP_LDBR,  1, &BR[19][1][1],(Ull)t1,    BR[18][1][1],MSK_B3, (Ull)t1, 256/4,  0,  0, (Ull)NULL, 256/4);                 /* stage#19 */
          mop(OP_LDBR,  1, &BR[19][2][1],(Ull)t2,    BR[18][1][1],MSK_B2, (Ull)t2, 256/4,  0,  0, (Ull)NULL, 256/4);                 /* stage#19 */
          mop(OP_LDBR,  1, &BR[19][3][1],(Ull)t3,    BR[18][1][1],MSK_B1, (Ull)t3, 256/4,  0,  0, (Ull)NULL, 256/4);                 /* stage#19 */
          exe(OP_MMRG, &r1, BR[19][1][1],EXP_H3210,  BR[19][2][1],EXP_H3210, BR[19][3][1],EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#19 */
          mop(OP_STWR,  3, &r1,          (Ull)dtop8[CHIP], pofs,  MSK_D0, (Ull)dtop8[CHIP], WD*RMGRP, 0, 0, (Ull)NULL, WD*RMGRP);    /* stage#19 */
          /*map9*/
          mop(OP_LDWR,  1, &BR[20][1][1],(Ull)rtop9[CHIP], pofs,  MSK_D0, (Ull)rtop9[CHIP], WD*RMGRP, 0, 0, (Ull)NULL, WD*RMGRP);    /* stage#20 */
          mop(OP_LDBR,  1, &BR[21][1][1],(Ull)t1,    BR[20][1][1],MSK_B3, (Ull)t1, 256/4,  0,  0, (Ull)NULL, 256/4);                 /* stage#21 */
          mop(OP_LDBR,  1, &BR[21][2][1],(Ull)t2,    BR[20][1][1],MSK_B2, (Ull)t2, 256/4,  0,  0, (Ull)NULL, 256/4);                 /* stage#21 */
          mop(OP_LDBR,  1, &BR[21][3][1],(Ull)t3,    BR[20][1][1],MSK_B1, (Ull)t3, 256/4,  0,  0, (Ull)NULL, 256/4);                 /* stage#21 */
          exe(OP_MMRG, &r1, BR[21][1][1],EXP_H3210,  BR[21][2][1],EXP_H3210, BR[21][3][1],EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#21 */
          mop(OP_STWR,  3, &r1,          (Ull)dtop9[CHIP], pofs,  MSK_D0, (Ull)dtop9[CHIP], WD*RMGRP, 0, 0, (Ull)NULL, WD*RMGRP);    /* stage#21 */
    } } }
//EMAX5A end
  }
//EMAX5A drain_dirty_lmm
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\epsfile{file=filter+rmm-tone_curve-emax6.eps,width=1.00\textwidth}
\caption{Tone curve}
\end{figure}

\clearpage

\subsection{Hokan1 with stencil}

\begin{figure}[htbp]
\center
\includegraphics[angle=270,origin=b,width=0.50\textwidth]{hokan.eps}
\caption{Hokan}
\end{figure}

フレーム補間の第1段階である．12x12の領域と4x4の領域のSAD値（4x4個）を求める．
一度のバースト演算により8行分のSAD計算を行う（RMGRP=8）．ステンシル計算であ
りmapdist=7である．

\begin{screen}
\tiny
\begin{verbatim}
void hokan1(Uint *c, Uint *p, struct SAD1 *s) /* W, R, SAD1 */
#if !defined(EMAX5) && !defined(EMAX6)
  for (top=PAD; top<HT-PAD; top++) { /* scan-lines */
    for (pofs=-4; pofs<4; pofs++) {
      Ushort *t = s->SAD1[top/4][pofs+4];
      for (cofs=0; cofs<WD; cofs++) {
        int j = cofs/4*4;
        int k = cofs%4*2;
        Uint *c2 = c+top*WD;
        Uint *p2 = p+(top+pofs)*WD;
        * t    += df(c2[j],p2[j+k-4]) + df(c2[j+1],p2[j+k-3]) + df(c2[j+2],p2[j+k-2]) + df(c2[j+3],p2[j+k-1]); /* p[-4],p[-3],p[-2],p[-1] -> p[-2],p[-1],p[0],p[1] */
        *(t+1) += df(c2[j],p2[j+k-3]) + df(c2[j+1],p2[j+k-2]) + df(c2[j+2],p2[j+k-1]) + df(c2[j+3],p2[j+k  ]); /* p[-3],p[-2],p[-1],p[ 0] -> p[-1],p[ 0],p[1],p[2] */
        t += 2;
  } } }
#endif
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
  for (top=0; top<RRANGE; top+=RMGRP) {  /* will be parallelized by multi-chip (M/#chip) */
    for (rofs=0; rofs<RMGRP; rofs++) { /* will be parallelized by multi-chip (M/#chip) */
      for (CHIP=0; CHIP<NCHIP; CHIP++) {   /* will be parallelized by multi-chip (M/#chip) */
        int idx = CHIP*RRANGE+PAD+top+rofs;
        Uint *c0 = c+ idx   *WD;
        Uint *p0 = p+(idx-4)*WD;                                                                            /* j+k: 0,2,4,6; 4,6,8,10; 8,10,12,14; 12,14,16,18; */
        Uint *p1 = p+(idx-3)*WD;                                                                            /* j+k: 0,2,4,6; 4,6,8,10; 8,10,12,14; 12,14,16,18; */
        Uint *p2 = p+(idx-2)*WD;                                                                            /* j+k: 0,2,4,6; 4,6,8,10; 8,10,12,14; 12,14,16,18; */
        Uint *p3 = p+(idx-1)*WD;                                                                            /* j+k: 0,2,4,6; 4,6,8,10; 8,10,12,14; 12,14,16,18; */
        Uint *p4 = p+(idx+0)*WD;                                                                            /* j+k: 0,2,4,6; 4,6,8,10; 8,10,12,14; 12,14,16,18; */
        Uint *p5 = p+(idx+1)*WD;                                                                            /* j+k: 0,2,4,6; 4,6,8,10; 8,10,12,14; 12,14,16,18; */
        Uint *p6 = p+(idx+2)*WD;                                                                            /* j+k: 0,2,4,6; 4,6,8,10; 8,10,12,14; 12,14,16,18; */
        Uint *p7 = p+(idx+3)*WD;                                                                            /* j+k: 0,2,4,6; 4,6,8,10; 8,10,12,14; 12,14,16,18; */
        Ushort *t0 = s->SAD1[idx/4][0];
        Ushort *t1 = s->SAD1[idx/4][1];
        Ushort *t2 = s->SAD1[idx/4][2];
        Ushort *t3 = s->SAD1[idx/4][3];
        Ushort *t4 = s->SAD1[idx/4][4];
        Ushort *t5 = s->SAD1[idx/4][5];
        Ushort *t6 = s->SAD1[idx/4][6];
        Ushort *t7 = s->SAD1[idx/4][7];
        for (cofs=0; cofs<WD; cofs++) {
          int j = cofs/4*4;
          int k = cofs%4*2;
          * t0    += df(c0[j],p0[j+k-4]) + df(c0[j+1],p0[j+k-3]) + df(c0[j+2],p0[j+k-2]) + df(c0[j+3],p0[j+k-1]); /* p[-4],p[-3],p[-2],p[-1] -> p[-2],p[-1],p[0],p[1] */
          *(t0+1) += df(c0[j],p0[j+k-3]) + df(c0[j+1],p0[j+k-2]) + df(c0[j+2],p0[j+k-1]) + df(c0[j+3],p0[j+k  ]); /* p[-3],p[-2],p[-1],p[ 0] -> p[-1],p[ 0],p[1],p[2] */
          t0 += 2;
          * t1    += df(c0[j],p1[j+k-4]) + df(c0[j+1],p1[j+k-3]) + df(c0[j+2],p1[j+k-2]) + df(c0[j+3],p1[j+k-1]); /* p[-4],p[-3],p[-2],p[-1] -> p[-2],p[-1],p[0],p[1] */
          *(t1+1) += df(c0[j],p1[j+k-3]) + df(c0[j+1],p1[j+k-2]) + df(c0[j+2],p1[j+k-1]) + df(c0[j+3],p1[j+k  ]); /* p[-3],p[-2],p[-1],p[ 0] -> p[-1],p[ 0],p[1],p[2] */
          t1 += 2;
          * t2    += df(c0[j],p2[j+k-4]) + df(c0[j+1],p2[j+k-3]) + df(c0[j+2],p2[j+k-2]) + df(c0[j+3],p2[j+k-1]); /* p[-4],p[-3],p[-2],p[-1] -> p[-2],p[-1],p[0],p[1] */
          *(t2+1) += df(c0[j],p2[j+k-3]) + df(c0[j+1],p2[j+k-2]) + df(c0[j+2],p2[j+k-1]) + df(c0[j+3],p2[j+k  ]); /* p[-3],p[-2],p[-1],p[ 0] -> p[-1],p[ 0],p[1],p[2] */
          t2 += 2;
          * t3    += df(c0[j],p3[j+k-4]) + df(c0[j+1],p3[j+k-3]) + df(c0[j+2],p3[j+k-2]) + df(c0[j+3],p3[j+k-1]); /* p[-4],p[-3],p[-2],p[-1] -> p[-2],p[-1],p[0],p[1] */
          *(t3+1) += df(c0[j],p3[j+k-3]) + df(c0[j+1],p3[j+k-2]) + df(c0[j+2],p3[j+k-1]) + df(c0[j+3],p3[j+k  ]); /* p[-3],p[-2],p[-1],p[ 0] -> p[-1],p[ 0],p[1],p[2] */
          t3 += 2;
          * t4    += df(c0[j],p4[j+k-4]) + df(c0[j+1],p4[j+k-3]) + df(c0[j+2],p4[j+k-2]) + df(c0[j+3],p4[j+k-1]); /* p[-4],p[-3],p[-2],p[-1] -> p[-2],p[-1],p[0],p[1] */
          *(t4+1) += df(c0[j],p4[j+k-3]) + df(c0[j+1],p4[j+k-2]) + df(c0[j+2],p4[j+k-1]) + df(c0[j+3],p4[j+k  ]); /* p[-3],p[-2],p[-1],p[ 0] -> p[-1],p[ 0],p[1],p[2] */
          t4 += 2;
          * t5    += df(c0[j],p5[j+k-4]) + df(c0[j+1],p5[j+k-3]) + df(c0[j+2],p5[j+k-2]) + df(c0[j+3],p5[j+k-1]); /* p[-4],p[-3],p[-2],p[-1] -> p[-2],p[-1],p[0],p[1] */
          *(t5+1) += df(c0[j],p5[j+k-3]) + df(c0[j+1],p5[j+k-2]) + df(c0[j+2],p5[j+k-1]) + df(c0[j+3],p5[j+k  ]); /* p[-3],p[-2],p[-1],p[ 0] -> p[-1],p[ 0],p[1],p[2] */
          t5 += 2;
          * t6    += df(c0[j],p6[j+k-4]) + df(c0[j+1],p6[j+k-3]) + df(c0[j+2],p6[j+k-2]) + df(c0[j+3],p6[j+k-1]); /* p[-4],p[-3],p[-2],p[-1] -> p[-2],p[-1],p[0],p[1] */
          *(t6+1) += df(c0[j],p6[j+k-3]) + df(c0[j+1],p6[j+k-2]) + df(c0[j+2],p6[j+k-1]) + df(c0[j+3],p6[j+k  ]); /* p[-3],p[-2],p[-1],p[ 0] -> p[-1],p[ 0],p[1],p[2] */
          t6 += 2;
          * t7    += df(c0[j],p7[j+k-4]) + df(c0[j+1],p7[j+k-3]) + df(c0[j+2],p7[j+k-2]) + df(c0[j+3],p7[j+k-1]); /* p[-4],p[-3],p[-2],p[-1] -> p[-2],p[-1],p[0],p[1] */
          *(t7+1) += df(c0[j],p7[j+k-3]) + df(c0[j+1],p7[j+k-2]) + df(c0[j+2],p7[j+k-1]) + df(c0[j+3],p7[j+k  ]); /* p[-3],p[-2],p[-1],p[ 0] -> p[-1],p[ 0],p[1],p[2] */
          t7 += 2;
  } } } }
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
  Ull  LOOP1, LOOP0;
  Ull  INIT1, INIT0;
  Ull  AR[64][4];                     /* output of EX     in each unit */
  Ull  BR[64][4][4];                  /* output registers in each unit */
  Ull  r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15;
  Ull  r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31;
  Ull  cc0, cc1, cc2, cc3, ex0, ex1;
  for (top=0; top<RRANGE; top+=RMGRP) {  /* will be parallelized by multi-chip (M/#chip) */
    for (rofs=0; rofs<RMGRP; rofs++) {      /* stage#0 *//* mapped to FOR() on BR[63][1][0] */
      Ull    jw, kw;
      Uint   *c0[NCHIP];
      Uint   *p0[NCHIP], *p1[NCHIP], *p2[NCHIP], *p3[NCHIP], *p4[NCHIP], *p5[NCHIP], *p6[NCHIP], *p7[NCHIP];
      Ushort *t0[NCHIP], *t1[NCHIP], *t2[NCHIP], *t3[NCHIP], *t4[NCHIP], *t5[NCHIP], *t6[NCHIP], *t7[NCHIP];
      for (CHIP=0; CHIP<NCHIP; CHIP++) {
        int idx = CHIP*RRANGE+PAD+top+rofs;
        c0[CHIP] = c+ idx   *WD;
        p0[CHIP] = p+(idx-4)*WD; /* j+k: 0,2,4,6; 4,6,8,10; 8,10,12,14; 12,14,16,18; */
        p1[CHIP] = p+(idx-3)*WD; /* j+k: 0,2,4,6; 4,6,8,10; 8,10,12,14; 12,14,16,18; */
        p2[CHIP] = p+(idx-2)*WD; /* j+k: 0,2,4,6; 4,6,8,10; 8,10,12,14; 12,14,16,18; */
        p3[CHIP] = p+(idx-1)*WD; /* j+k: 0,2,4,6; 4,6,8,10; 8,10,12,14; 12,14,16,18; */
        p4[CHIP] = p+(idx+0)*WD; /* j+k: 0,2,4,6; 4,6,8,10; 8,10,12,14; 12,14,16,18; */
        p5[CHIP] = p+(idx+1)*WD; /* j+k: 0,2,4,6; 4,6,8,10; 8,10,12,14; 12,14,16,18; */
        p6[CHIP] = p+(idx+2)*WD; /* j+k: 0,2,4,6; 4,6,8,10; 8,10,12,14; 12,14,16,18; */
        p7[CHIP] = p+(idx+3)*WD; /* j+k: 0,2,4,6; 4,6,8,10; 8,10,12,14; 12,14,16,18; */
        t0[CHIP] = s->SAD1[idx/4][0]; /* SAD1[HT/4][8][WD/4][8] ... [8][WD/4][8]=5120(2B) 0x1400 */
        t1[CHIP] = s->SAD1[idx/4][1];
        t2[CHIP] = s->SAD1[idx/4][2];
        t3[CHIP] = s->SAD1[idx/4][3];
        t4[CHIP] = s->SAD1[idx/4][4];
        t5[CHIP] = s->SAD1[idx/4][5];
        t6[CHIP] = s->SAD1[idx/4][6];
        t7[CHIP] = s->SAD1[idx/4][7];
      }
//EMAX5A begin hokan1 mapdist=7
 /*2*/for (CHIP=0; CHIP<NCHIP; CHIP++) { /* output channels are parallelized by multi-chip (OC/#chip) */
   /*1*/for (INIT0=1,LOOP0=WD,cofs=0-4; LOOP0--; INIT0=0) {       /* stage#0 *//* mapped to FOR() on BR[63][0][0] */
 /*@0,1*/ exe(OP_ADD,  &cofs, INIT0?cofs:cofs, EXP_H3210, 4, EXP_H3210, 0LL, EXP_H3210, OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL); /* stage#0 */
          /*int j = cofs/4 /4*4 *4;*/
          /*int k = cofs/4 %4*2 *4;*/
 /*@1,0*/ exe(OP_NOP,     &jw,          cofs,     EXP_H3210, 0LL, EXP_H3210, 0LL, EXP_H3210, OP_AND,~15LL, OP_SLL, 0LL);
 /*@1,1*/ exe(OP_NOP,     &kw,          cofs,     EXP_H3210, 0LL, EXP_H3210, 0LL, EXP_H3210, OP_AND, 12LL, OP_SLL, 1LL);
          /*k=-4*/
 /*@2,0*/ exe(OP_ADD,     &r12,         c0[CHIP], EXP_H3210, jw,  EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@2,1*/ exe(OP_ADD3,    &r13,         p0[CHIP], EXP_H3210, jw,  EXP_H3210, kw,  EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@3,0*/ mop(OP_LDWR, 1, &r0,          r12,    0LL,  MSK_D0,  (Ull)c0[CHIP], WD, 0, 0, (Ull)NULL, WD);
 /*@3,1*/ mop(OP_LDWR, 1, &r1,          r12,    4LL,  MSK_D0,  (Ull)c0[CHIP], WD, 0, 0, (Ull)NULL, WD);
 /*@3,2*/ mop(OP_LDWR, 1, &r2,          r12,    8LL,  MSK_D0,  (Ull)c0[CHIP], WD, 0, 0, (Ull)NULL, WD);
 /*@3,3*/ mop(OP_LDWR, 1, &r3,          r12,   12LL,  MSK_D0,  (Ull)c0[CHIP], WD, 0, 0, (Ull)NULL, WD);
 /*@4,0*/ mop(OP_LDWR, 1, &BR[4][0][1], r13,  -16LL,  MSK_D0,  (Ull)p0[CHIP], WD, 0, 0, (Ull)NULL, WD);
 /*@4,1*/ mop(OP_LDWR, 1, &r25,         r13,  -12LL,  MSK_D0,  (Ull)p0[CHIP], WD, 0, 0, (Ull)NULL, WD);
 /*@4,2*/ mop(OP_LDWR, 1, &r26,         r13,   -8LL,  MSK_D0,  (Ull)p0[CHIP], WD, 0, 0, (Ull)NULL, WD);
 /*@4,3*/ mop(OP_LDWR, 1, &r27,         r13,   -4LL,  MSK_D0,  (Ull)p0[CHIP], WD, 0, 0, (Ull)NULL, WD);
 /*@4,3*/ mop(OP_LDWR, 1, &r28,         r13,    0LL,  MSK_D0,  (Ull)p0[CHIP], WD, 0, 0, (Ull)NULL, WD);
 /*@5,0*/ exe(OP_MSSAD,   &r11,         0LL,    EXP_H3210, r0,  EXP_H3210, r25, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@5,1*/ exe(OP_MSSAD,   &r13,         0LL,    EXP_H3210, r1,  EXP_H3210, r26, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@5,2*/ exe(OP_MSSAD,   &r15,         0LL,    EXP_H3210, r2,  EXP_H3210, r27, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@5,3*/ exe(OP_MSSAD,   &r17,         0LL,    EXP_H3210, r3,  EXP_H3210, r28, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@6,0*/ exe(OP_MSSAD,   &r10,         0LL,    EXP_H3210, r0,  EXP_H3210, BR[4][0][1], EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@6,1*/ exe(OP_MSSAD,   &r12,         0LL,    EXP_H3210, r1,  EXP_H3210, r25, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@6,2*/ exe(OP_MSSAD,   &r14,         0LL,    EXP_H3210, r2,  EXP_H3210, r26, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@6,3*/ exe(OP_MSSAD,   &r16,         0LL,    EXP_H3210, r3,  EXP_H3210, r27, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@7,0*/ exe(OP_MAUH,    &r20,         r10,    EXP_H3210, r12, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@7,1*/ exe(OP_MAUH,    &r21,         r11,    EXP_H3210, r13, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@7,2*/ exe(OP_MAUH,    &r24,         r14,    EXP_H3210, r16, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@7,3*/ exe(OP_MAUH,    &r25,         r15,    EXP_H3210, r17, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@8,0*/ exe(OP_MAUH,    &r10,         r20,    EXP_H3210, r24, EXP_H3210, 0LL, EXP_H3210, OP_SUMHL,0LL, OP_NOP, 0LL);
 /*@8,1*/ exe(OP_MAUH,    &r11,         r21,    EXP_H3210, r25, EXP_H3210, 0LL, EXP_H3210, OP_SUMHH,0LL, OP_NOP, 0LL);
 /*@9,0*/ mop(OP_LDWR, 1, &BR[9][0][1], t0[CHIP],  cofs, MSK_D0, (Ull)t0[CHIP], WD, 0, 1, (Ull)NULL, WD);
 /*@9,0*/ exe(OP_MAUH3,   &AR[9][0],    BR[9][0][1],     EXP_H3210, r10, EXP_H3210, r11, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);
 /*@9,0*/ mop(OP_STWR, 3, &AR[9][0],    cofs,  t0[CHIP], MSK_D0, (Ull)t0[CHIP], WD, 0, 1, (Ull)NULL, WD);
     :
          /*k=+3*/
 /*@51,2*/exe(OP_ADD,     &r12,         c0[CHIP], EXP_H3210, jw,  EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@51,3*/exe(OP_ADD3,    &r13,         p7[CHIP], EXP_H3210, jw,  EXP_H3210, kw,  EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@52,0*/mop(OP_LDWR, 1, &r0,          r12,    0LL,  MSK_D0,  (Ull)c0[CHIP], WD, 0, 0, (Ull)NULL, WD);
 /*@52,1*/mop(OP_LDWR, 1, &r1,          r12,    4LL,  MSK_D0,  (Ull)c0[CHIP], WD, 0, 0, (Ull)NULL, WD);
 /*@52,2*/mop(OP_LDWR, 1, &r2,          r12,    8LL,  MSK_D0,  (Ull)c0[CHIP], WD, 0, 0, (Ull)NULL, WD);
 /*@52,3*/mop(OP_LDWR, 1, &r3,          r12,   12LL,  MSK_D0,  (Ull)c0[CHIP], WD, 0, 0, (Ull)NULL, WD);
 /*@53,0*/mop(OP_LDWR, 1, &BR[53][0][1],r13,  -16LL,  MSK_D0,  (Ull)p7[CHIP], WD, 0, 0, (Ull)NULL, WD);
 /*@53,1*/mop(OP_LDWR, 1, &r25,         r13,  -12LL,  MSK_D0,  (Ull)p7[CHIP], WD, 0, 0, (Ull)NULL, WD);
 /*@53,2*/mop(OP_LDWR, 1, &r26,         r13,   -8LL,  MSK_D0,  (Ull)p7[CHIP], WD, 0, 0, (Ull)NULL, WD);
 /*@53,3*/mop(OP_LDWR, 1, &r27,         r13,   -4LL,  MSK_D0,  (Ull)p7[CHIP], WD, 0, 0, (Ull)NULL, WD);
 /*@53,3*/mop(OP_LDWR, 1, &r28,         r13,    0LL,  MSK_D0,  (Ull)p7[CHIP], WD, 0, 0, (Ull)NULL, WD);
 /*@54,0*/exe(OP_MSSAD,   &r11,         0LL,    EXP_H3210, r0,  EXP_H3210, r25, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@54,1*/exe(OP_MSSAD,   &r13,         0LL,    EXP_H3210, r1,  EXP_H3210, r26, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@54,2*/exe(OP_MSSAD,   &r15,         0LL,    EXP_H3210, r2,  EXP_H3210, r27, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@54,3*/exe(OP_MSSAD,   &r17,         0LL,    EXP_H3210, r3,  EXP_H3210, r28, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@55,0*/exe(OP_MSSAD,   &r10,         0LL,    EXP_H3210, r0,  EXP_H3210, BR[53][0][1], EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@55,1*/exe(OP_MSSAD,   &r12,         0LL,    EXP_H3210, r1,  EXP_H3210, r25, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@55,2*/exe(OP_MSSAD,   &r14,         0LL,    EXP_H3210, r2,  EXP_H3210, r26, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@55,3*/exe(OP_MSSAD,   &r16,         0LL,    EXP_H3210, r3,  EXP_H3210, r27, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@56,0*/exe(OP_MAUH,    &r20,         r10,    EXP_H3210, r12, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@56,1*/exe(OP_MAUH,    &r21,         r11,    EXP_H3210, r13, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@56,2*/exe(OP_MAUH,    &r24,         r14,    EXP_H3210, r16, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@56,3*/exe(OP_MAUH,    &r25,         r15,    EXP_H3210, r17, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@57,0*/exe(OP_MAUH,    &r10,         r20,    EXP_H3210, r24, EXP_H3210, 0LL, EXP_H3210, OP_SUMHL,0LL, OP_NOP, 0LL);
 /*@57,1*/exe(OP_MAUH,    &r11,         r21,    EXP_H3210, r25, EXP_H3210, 0LL, EXP_H3210, OP_SUMHH,0LL, OP_NOP, 0LL);
 /*@58,0*/mop(OP_LDWR, 1, &BR[58][0][1],t7[CHIP],  cofs, MSK_D0, (Ull)t7[CHIP], WD, 0, 1, (Ull)NULL, WD);
 /*@58,0*/exe(OP_MAUH3,   &AR[58][0],   BR[58][0][1],    EXP_H3210, r10, EXP_H3210, r11, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);
 /*@58,0*/mop(OP_STWR, 3, &AR[58][0],   cofs,  t7[CHIP], MSK_D0, (Ull)t7[CHIP], WD, 0, 1, (Ull)NULL, WD);
        }
      }
//EMAX5A end
    }
  }
//EMAX5A drain_dirty_lmm
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\epsfile{file=filter+rmm-hokan1-emax6.eps,width=1.00\textwidth}
\caption{Hokan1}
\end{figure}

\clearpage

\subsection{Hokan2 with stencil}

フレーム補間の第2段階である．4x4個のSAD値から最も小さいSAD値を探し，対応する
xy相対座標を求める．一度のバースト演算により12行分の座標計算を行う（RMGRP=12）．
ステンシル計算ではなくmapdist=0である．

\begin{screen}
\tiny
\begin{verbatim}
void hokan2(struct SAD1 *s, Uint *minxy) /* [WD/4][8] */
#if !defined(EMAX5) && !defined(EMAX6)
  for (top=PAD; top<HT-PAD; top+=4) { /* scan-lines */
    Uint *xy = minxy+top*WD;
    for (pofs=-4; pofs<4; pofs++) {
      Ushort *t  = s->SAD1[top/4][pofs+4];
      int    idx = ((pofs/2)&0xff)<<16;
      for (cofs=0; cofs<WD; cofs++) { /* j%4==0の時のみminxy[j]に有効値．他はゴミ */
        int l1 = ((-2)<<24)|idx|*(t  ); if ((xy[cofs]&HM) > *(t  )) xy[cofs] = l1;
        int l2 = ((-1)<<24)|idx|*(t+1); if ((xy[cofs]&HM) > *(t+1)) xy[cofs] = l2;
        int l3 = ((-1)<<24)|idx|*(t+2); if ((xy[cofs]&HM) > *(t+2)) xy[cofs] = l3;
        int l4 = (( 0)<<24)|idx|*(t+3); if ((xy[cofs]&HM) > *(t+3)) xy[cofs] = l4;
        int l5 = (( 0)<<24)|idx|*(t+4); if ((xy[cofs]&HM) > *(t+4)) xy[cofs] = l5;
        int l6 = (( 0)<<24)|idx|*(t+5); if ((xy[cofs]&HM) > *(t+5)) xy[cofs] = l6;
        int l7 = (( 1)<<24)|idx|*(t+6); if ((xy[cofs]&HM) > *(t+6)) xy[cofs] = l7;
        int l8 = (( 1)<<24)|idx|*(t+7); if ((xy[cofs]&HM) > *(t+7)) xy[cofs] = l8;
        t += 2;
      }
    }
  }
#endif
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
  Uint ix0 = ((-4/2)&0xff)<<16; /* -2,-1,-1,0,0,0,1,1 */
  Uint ix1 = ((-3/2)&0xff)<<16; /* -2,-1,-1,0,0,0,1,1 */
  Uint ix2 = ((-2/2)&0xff)<<16; /* -2,-1,-1,0,0,0,1,1 */
  Uint ix3 = ((-1/2)&0xff)<<16; /* -2,-1,-1,0,0,0,1,1 */
  Uint ix4 = (( 0/2)&0xff)<<16; /* -2,-1,-1,0,0,0,1,1 */
  Uint ix5 = ((+1/2)&0xff)<<16; /* -2,-1,-1,0,0,0,1,1 */
  Uint ix6 = ((+2/2)&0xff)<<16; /* -2,-1,-1,0,0,0,1,1 */
  Uint ix7 = ((+3/2)&0xff)<<16; /* -2,-1,-1,0,0,0,1,1 */
  for (top=0; top<RRANGE; top+=RMGRP) {  /* will be parallelized by multi-chip (M/#chip) */
    for (rofs=0; rofs<RMGRP; rofs+=4) { /* will be parallelized by multi-chip (M/#chip) */
      for (CHIP=0; CHIP<NCHIP; CHIP++) {   /* will be parallelized by multi-chip (M/#chip) */
        Ushort *t0 = s->SAD1[(CHIP*RRANGE+top+rofs)/4][0];
        Ushort *t1 = s->SAD1[(CHIP*RRANGE+top+rofs)/4][1];
        Ushort *t2 = s->SAD1[(CHIP*RRANGE+top+rofs)/4][2];
        Ushort *t3 = s->SAD1[(CHIP*RRANGE+top+rofs)/4][3];
        Ushort *t4 = s->SAD1[(CHIP*RRANGE+top+rofs)/4][4];
        Ushort *t5 = s->SAD1[(CHIP*RRANGE+top+rofs)/4][5];
        Ushort *t6 = s->SAD1[(CHIP*RRANGE+top+rofs)/4][6];
        Ushort *t7 = s->SAD1[(CHIP*RRANGE+top+rofs)/4][7];
        Uint   *xy = minxy+(CHIP*RRANGE+top+rofs)*WD;
        for (cofs=0; cofs<WD; cofs++) { /* j%4==0の時のみminxy[j]に有効値．他はゴミ */
          int l1, l2, l3, l4, l5, l6, l7, l8;
          l1=((-2)<<24)|ix0|*(t0  ); if((xy[cofs]&HM)>*(t0  ))xy[cofs]=l1;
          l2=((-1)<<24)|ix0|*(t0+1); if((xy[cofs]&HM)>*(t0+1))xy[cofs]=l2;
          l3=((-1)<<24)|ix0|*(t0+2); if((xy[cofs]&HM)>*(t0+2))xy[cofs]=l3;
          l4=           ix0|*(t0+3); if((xy[cofs]&HM)>*(t0+3))xy[cofs]=l4;
          l5=           ix0|*(t0+4); if((xy[cofs]&HM)>*(t0+4))xy[cofs]=l5;
          l6=           ix0|*(t0+5); if((xy[cofs]&HM)>*(t0+5))xy[cofs]=l6;
          l7=(( 1)<<24)|ix0|*(t0+6); if((xy[cofs]&HM)>*(t0+6))xy[cofs]=l7;
          l8=(( 1)<<24)|ix0|*(t0+7); if((xy[cofs]&HM)>*(t0+7))xy[cofs]=l8;
          t0 += 2;
          l1=((-2)<<24)|ix1|*(t1  ); if((xy[cofs]&HM)>*(t1  ))xy[cofs]=l1;
          l2=((-1)<<24)|ix1|*(t1+1); if((xy[cofs]&HM)>*(t1+1))xy[cofs]=l2;
          l3=((-1)<<24)|ix1|*(t1+2); if((xy[cofs]&HM)>*(t1+2))xy[cofs]=l3;
          l4=           ix1|*(t1+3); if((xy[cofs]&HM)>*(t1+3))xy[cofs]=l4;
          l5=           ix1|*(t1+4); if((xy[cofs]&HM)>*(t1+4))xy[cofs]=l5;
          l6=           ix1|*(t1+5); if((xy[cofs]&HM)>*(t1+5))xy[cofs]=l6;
          l7=(( 1)<<24)|ix1|*(t1+6); if((xy[cofs]&HM)>*(t1+6))xy[cofs]=l7;
          l8=(( 1)<<24)|ix1|*(t1+7); if((xy[cofs]&HM)>*(t1+7))xy[cofs]=l8;
             :
          t5 += 2;
          l1=((-2)<<24)|ix6|*(t6  ); if((xy[cofs]&HM)>*(t6  ))xy[cofs]=l1;
          l2=((-1)<<24)|ix6|*(t6+1); if((xy[cofs]&HM)>*(t6+1))xy[cofs]=l2;
          l3=((-1)<<24)|ix6|*(t6+2); if((xy[cofs]&HM)>*(t6+2))xy[cofs]=l3;
          l4=           ix6|*(t6+3); if((xy[cofs]&HM)>*(t6+3))xy[cofs]=l4;
          l5=           ix6|*(t6+4); if((xy[cofs]&HM)>*(t6+4))xy[cofs]=l5;
          l6=           ix6|*(t6+5); if((xy[cofs]&HM)>*(t6+5))xy[cofs]=l6;
          l7=(( 1)<<24)|ix6|*(t6+6); if((xy[cofs]&HM)>*(t6+6))xy[cofs]=l7;
          l8=(( 1)<<24)|ix6|*(t6+7); if((xy[cofs]&HM)>*(t6+7))xy[cofs]=l8;
          t6 += 2;
          l1=((-2)<<24)|ix7|*(t7  ); if((xy[cofs]&HM)>*(t7  ))xy[cofs]=l1;
          l2=((-1)<<24)|ix7|*(t7+1); if((xy[cofs]&HM)>*(t7+1))xy[cofs]=l2;
          l3=((-1)<<24)|ix7|*(t7+2); if((xy[cofs]&HM)>*(t7+2))xy[cofs]=l3;
          l4=           ix7|*(t7+3); if((xy[cofs]&HM)>*(t7+3))xy[cofs]=l4;
          l5=           ix7|*(t7+4); if((xy[cofs]&HM)>*(t7+4))xy[cofs]=l5;
          l6=           ix7|*(t7+5); if((xy[cofs]&HM)>*(t7+5))xy[cofs]=l6;
          l7=(( 1)<<24)|ix7|*(t7+6); if((xy[cofs]&HM)>*(t7+6))xy[cofs]=l7;
          l8=(( 1)<<24)|ix7|*(t7+7); if((xy[cofs]&HM)>*(t7+7))xy[cofs]=l8;
          t7 += 2;
        }
      }
    }
  }
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
  Ull  LOOP1, LOOP0;
  Ull  INIT1, INIT0;
  Ull  AR[64][4];                     /* output of EX     in each unit */
  Ull  BR[64][4][4];                  /* output registers in each unit */
  Ull  r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15;
  Ull  r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31;
  Ull  cc0, cc1, cc2, cc3, ex0, ex1;
  Uint ix0 = ((-4/2)&0xff)<<16; /* -2,-1,-1,0,0,0,1,1 */
  Uint ix1 = ((-3/2)&0xff)<<16; /* -2,-1,-1,0,0,0,1,1 */
  Uint ix2 = ((-2/2)&0xff)<<16; /* -2,-1,-1,0,0,0,1,1 */
  Uint ix3 = ((-1/2)&0xff)<<16; /* -2,-1,-1,0,0,0,1,1 */
  Uint ix4 = (( 0/2)&0xff)<<16; /* -2,-1,-1,0,0,0,1,1 */
  Uint ix5 = ((+1/2)&0xff)<<16; /* -2,-1,-1,0,0,0,1,1 */
  Uint ix6 = ((+2/2)&0xff)<<16; /* -2,-1,-1,0,0,0,1,1 */
  Uint ix7 = ((+3/2)&0xff)<<16; /* -2,-1,-1,0,0,0,1,1 */
  for (top=0; top<RRANGE; top+=RMGRP) {  /* will be parallelized by multi-chip (M/#chip) */
    for (rofs=0; rofs<RMGRP; rofs+=4) { /* will be parallelized by multi-chip (M/#chip) */
      Uint *xy[NCHIP];
      Uint *t00[NCHIP],*t10[NCHIP],*t20[NCHIP],*t30[NCHIP],*t40[NCHIP],*t50[NCHIP],*t60[NCHIP],*t70[NCHIP];
      Uint *t01[NCHIP],*t11[NCHIP],*t21[NCHIP],*t31[NCHIP],*t41[NCHIP],*t51[NCHIP],*t61[NCHIP],*t71[NCHIP];
      Uint *t02[NCHIP],*t12[NCHIP],*t22[NCHIP],*t32[NCHIP],*t42[NCHIP],*t52[NCHIP],*t62[NCHIP],*t72[NCHIP];
      Uint *t03[NCHIP],*t13[NCHIP],*t23[NCHIP],*t33[NCHIP],*t43[NCHIP],*t53[NCHIP],*t63[NCHIP],*t73[NCHIP];
      for (CHIP=0; CHIP<NCHIP; CHIP++) {   /* will be parallelized by multi-chip (M/#chip) */
        int idx = CHIP*RRANGE+PAD+top+rofs;
        t00[CHIP] = s->SAD1[idx/4][0]; t01[CHIP] = t00[CHIP]+1; t02[CHIP] = t00[CHIP]+2; t03[CHIP] = t00[CHIP]+3;
        t10[CHIP] = s->SAD1[idx/4][1]; t11[CHIP] = t10[CHIP]+1; t12[CHIP] = t10[CHIP]+2; t13[CHIP] = t10[CHIP]+3;
        t20[CHIP] = s->SAD1[idx/4][2]; t21[CHIP] = t20[CHIP]+1; t22[CHIP] = t20[CHIP]+2; t23[CHIP] = t20[CHIP]+3;
        t30[CHIP] = s->SAD1[idx/4][3]; t31[CHIP] = t30[CHIP]+1; t32[CHIP] = t30[CHIP]+2; t33[CHIP] = t30[CHIP]+3;
        t40[CHIP] = s->SAD1[idx/4][4]; t41[CHIP] = t40[CHIP]+1; t42[CHIP] = t40[CHIP]+2; t43[CHIP] = t40[CHIP]+3;
        t50[CHIP] = s->SAD1[idx/4][5]; t51[CHIP] = t50[CHIP]+1; t52[CHIP] = t50[CHIP]+2; t53[CHIP] = t50[CHIP]+3;
        t60[CHIP] = s->SAD1[idx/4][6]; t61[CHIP] = t60[CHIP]+1; t62[CHIP] = t60[CHIP]+2; t63[CHIP] = t60[CHIP]+3;
        t70[CHIP] = s->SAD1[idx/4][7]; t71[CHIP] = t70[CHIP]+1; t72[CHIP] = t70[CHIP]+2; t73[CHIP] = t70[CHIP]+3;
        xy[CHIP] = minxy+idx*WD;
      }
//EMAX5A begin hokan2 mapdist=0
 /*2*/for (CHIP=0; CHIP<NCHIP; CHIP++) { /* output channels are parallelized by multi-chip (OC/#chip) */
   /*1*/for (INIT0=1,LOOP0=WD,cofs=0-4; LOOP0--; INIT0=0) {       /* stage#0 *//* mapped to FOR() on BR[63][0][0] */
 /*@0,1*/ exe(OP_ADD,     &cofs,  INIT0?cofs:cofs, EXP_H3210, 4,           EXP_H3210, 0LL,  EXP_H3210, OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL);
          /*k=-4*/
 /*@1,0*/ mop(OP_LDWR, 1, &r10,         t00[CHIP], cofs,      MSK_D0,      t00[CHIP], WD, 0, 0, (Ull)NULL, WD);
 /*@1,0*/ exe(OP_NOP,     &r28,        (-2LL<<24), EXP_H3210, 0,           EXP_H3210, 0LL,  EXP_H3210, OP_OR,   ix0, OP_NOP, 0LL);
 /*@1,0*/ mop(OP_LDWR, 1, &r12,         t01[CHIP], cofs,      MSK_D0,      t00[CHIP], WD, 0, 0, (Ull)NULL, WD);
 /*@1,1*/ exe(OP_NOP,     &r29,        (-1LL<<24), EXP_H3210, 0,           EXP_H3210, 0LL,  EXP_H3210, OP_OR,   ix0, OP_NOP, 0LL);
 /*@1,1*/ mop(OP_LDWR, 1, &r14,         t02[CHIP], cofs,      MSK_D0,      t00[CHIP], WD, 0, 0, (Ull)NULL, WD);
 /*@1,2*/ exe(OP_NOP,     &r31,        ( 1LL<<24), EXP_H3210, 0,           EXP_H3210, 0LL,  EXP_H3210, OP_OR,   ix0, OP_NOP, 0LL);
 /*@1,2*/ mop(OP_LDWR, 1, &r16,         t03[CHIP], cofs,      MSK_D0,      t00[CHIP], WD, 0, 0, (Ull)NULL, WD);
 /*@2,0*/ exe(OP_MINL3,   &r10,         r29,       EXP_H3210, r28,         EXP_H3210, r10,  EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@2,1*/ exe(OP_MINL3,   &r12,         ix0,       EXP_H3210, r29,         EXP_H3210, r12,  EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@2,2*/ exe(OP_MINL3,   &r14,         ix0,       EXP_H3210, ix0,         EXP_H3210, r14,  EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@2,3*/ exe(OP_MINL3,   &r16,         r31,       EXP_H3210, r31,         EXP_H3210, r16,  EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@3,0*/ exe(OP_MINL,    &r20,         r10,       EXP_H3210, r12,         EXP_H3210, 0LL,  EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@3,1*/ exe(OP_MINL,    &r24,         r14,       EXP_H3210, r16,         EXP_H3210, 0LL,  EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@4,0*/ exe(OP_MINL,    &r0,          r20,       EXP_H3210, r24,         EXP_H3210, 0LL,  EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
          /*k=-3*/
 /*@4,0*/ mop(OP_LDWR, 1, &r10,         t10[CHIP], cofs,      MSK_D0,      t10[CHIP], WD, 0, 0, (Ull)NULL, WD);
 /*@4,1*/ exe(OP_NOP,     &r28,        (-2LL<<24), EXP_H3210, 0,           EXP_H3210, 0LL,  EXP_H3210, OP_OR,   ix1, OP_NOP, 0LL);
 /*@4,1*/ mop(OP_LDWR, 1, &r12,         t11[CHIP], cofs,      MSK_D0,      t10[CHIP], WD, 0, 0, (Ull)NULL, WD);
 /*@4,2*/ exe(OP_NOP,     &r29,        (-1LL<<24), EXP_H3210, 0,           EXP_H3210, 0LL,  EXP_H3210, OP_OR,   ix1, OP_NOP, 0LL);
 /*@4,2*/ mop(OP_LDWR, 1, &r14,         t12[CHIP], cofs,      MSK_D0,      t10[CHIP], WD, 0, 0, (Ull)NULL, WD);
 /*@4,3*/ exe(OP_NOP,     &r31,        ( 1LL<<24), EXP_H3210, 0,           EXP_H3210, 0LL,  EXP_H3210, OP_OR,   ix1, OP_NOP, 0LL);
 /*@4,3*/ mop(OP_LDWR, 1, &r16,         t13[CHIP], cofs,      MSK_D0,      t10[CHIP], WD, 0, 0, (Ull)NULL, WD);
 /*@5,0*/ exe(OP_MINL3,   &r10,         r29,       EXP_H3210, r28,         EXP_H3210, r10,  EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@5,1*/ exe(OP_MINL3,   &r12,         ix1,       EXP_H3210, r29,         EXP_H3210, r12,  EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@5,2*/ exe(OP_MINL3,   &r14,         ix1,       EXP_H3210, ix1,         EXP_H3210, r14,  EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@5,3*/ exe(OP_MINL3,   &r16,         r31,       EXP_H3210, r31,         EXP_H3210, r16,  EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@6,0*/ exe(OP_MINL,    &r20,         r10,       EXP_H3210, r12,         EXP_H3210, 0LL,  EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@6,1*/ exe(OP_MINL,    &r24,         r14,       EXP_H3210, r16,         EXP_H3210, 0LL,  EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@7,0*/ exe(OP_MINL,    &r1,          r20,       EXP_H3210, r24,         EXP_H3210, 0LL,  EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@8,0*/ exe(OP_MINL,    &r0,          r1,        EXP_H3210, r0,          EXP_H3210, 0LL,  EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
      :
          /*k=2*/
 /*@24,0*/mop(OP_LDWR, 1, &r10,         t60[CHIP], cofs,      MSK_D0,      t60[CHIP], WD, 0, 0, (Ull)NULL, WD);
 /*@24,1*/exe(OP_NOP,     &r28,        (-2LL<<24), EXP_H3210, 0,           EXP_H3210, 0LL,  EXP_H3210, OP_OR,   ix6, OP_NOP, 0LL);
 /*@24,1*/mop(OP_LDWR, 1, &r12,         t61[CHIP], cofs,      MSK_D0,      t60[CHIP], WD, 0, 0, (Ull)NULL, WD);
 /*@24,2*/exe(OP_NOP,     &r29,        (-1LL<<24), EXP_H3210, 0,           EXP_H3210, 0LL,  EXP_H3210, OP_OR,   ix6, OP_NOP, 0LL);
 /*@24,2*/mop(OP_LDWR, 1, &r14,         t62[CHIP], cofs,      MSK_D0,      t60[CHIP], WD, 0, 0, (Ull)NULL, WD);
 /*@24,3*/exe(OP_NOP,     &r31,        ( 1LL<<24), EXP_H3210, 0,           EXP_H3210, 0LL,  EXP_H3210, OP_OR,   ix6, OP_NOP, 0LL);
 /*@24,3*/mop(OP_LDWR, 1, &r16,         t63[CHIP], cofs,      MSK_D0,      t60[CHIP], WD, 0, 0, (Ull)NULL, WD);
 /*@25,0*/exe(OP_MINL3,   &r10,         r29,       EXP_H3210, r28,         EXP_H3210, r10,  EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@25,1*/exe(OP_MINL3,   &r12,         ix6,       EXP_H3210, r29,         EXP_H3210, r12,  EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@25,2*/exe(OP_MINL3,   &r14,         ix6,       EXP_H3210, ix6,         EXP_H3210, r14,  EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@25,3*/exe(OP_MINL3,   &r16,         r31,       EXP_H3210, r31,         EXP_H3210, r16,  EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@26,0*/exe(OP_MINL,    &r20,         r10,       EXP_H3210, r12,         EXP_H3210, 0LL,  EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@26,1*/exe(OP_MINL,    &r24,         r14,       EXP_H3210, r16,         EXP_H3210, 0LL,  EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@27,0*/exe(OP_MINL,    &r1,          r20,       EXP_H3210, r24,         EXP_H3210, 0LL,  EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@28,0*/exe(OP_MINL,    &r0,          r1,        EXP_H3210, r0,          EXP_H3210, 0LL,  EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
          /*k=3*/
 /*@28,0*/mop(OP_LDWR, 1, &r10,         t70[CHIP], cofs,      MSK_D0,      t70[CHIP], WD, 0, 0, (Ull)NULL, WD);
 /*@28,1*/exe(OP_NOP,     &r28,        (-2LL<<24), EXP_H3210, 0,           EXP_H3210, 0LL,  EXP_H3210, OP_OR,   ix7, OP_NOP, 0LL);
 /*@28,1*/mop(OP_LDWR, 1, &r12,         t71[CHIP], cofs,      MSK_D0,      t70[CHIP], WD, 0, 0, (Ull)NULL, WD);
 /*@28,2*/exe(OP_NOP,     &r29,        (-1LL<<24), EXP_H3210, 0,           EXP_H3210, 0LL,  EXP_H3210, OP_OR,   ix7, OP_NOP, 0LL);
 /*@28,2*/mop(OP_LDWR, 1, &r14,         t72[CHIP], cofs,      MSK_D0,      t70[CHIP], WD, 0, 0, (Ull)NULL, WD);
 /*@28,3*/exe(OP_NOP,     &r31,        ( 1LL<<24), EXP_H3210, 0,           EXP_H3210, 0LL,  EXP_H3210, OP_OR,   ix7, OP_NOP, 0LL);
 /*@28,3*/mop(OP_LDWR, 1, &r16,         t73[CHIP], cofs,      MSK_D0,      t70[CHIP], WD, 0, 0, (Ull)NULL, WD);
 /*@29,0*/exe(OP_MINL3,   &r10,         r29,       EXP_H3210, r28,         EXP_H3210, r10,  EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@29,1*/exe(OP_MINL3,   &r12,         ix7,       EXP_H3210, r29,         EXP_H3210, r12,  EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@29,2*/exe(OP_MINL3,   &r14,         ix7,       EXP_H3210, ix7,         EXP_H3210, r14,  EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@29,3*/exe(OP_MINL3,   &r16,         r31,       EXP_H3210, r31,         EXP_H3210, r16,  EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@30,0*/exe(OP_MINL,    &r20,         r10,       EXP_H3210, r12,         EXP_H3210, 0LL,  EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@30,1*/exe(OP_MINL,    &r24,         r14,       EXP_H3210, r16,         EXP_H3210, 0LL,  EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@31,0*/exe(OP_MINL,    &r1,          r20,       EXP_H3210, r24,         EXP_H3210, 0LL,  EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@32,0*/exe(OP_MINL,    &r0,          r1,        EXP_H3210, r0,          EXP_H3210, 0LL,  EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@33,0*/mop(OP_LDWR, 1, &BR[33][0][1],xy[CHIP],  cofs,      MSK_D0,      xy[CHIP],  WD, 0, 1, (Ull)NULL, WD);
 /*@33,0*/exe(OP_MINL,    &AR[33][0],   r0,        EXP_H3210, BR[33][0][1],EXP_H3210, 0LL,  EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);
 /*@33,0*/mop(OP_STWR, 3, &AR[33][0],   cofs,      xy[CHIP],  MSK_D0,      xy[CHIP],  WD, 0, 1, (Ull)NULL, WD);
        }
      }
//EMAX5A end
    }
  }
//EMAX5A drain_dirty_lmm
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\epsfile{file=filter+rmm-hokan2-emax6.eps,width=1.00\textwidth}
\caption{Hokan2}
\end{figure}

\clearpage

\subsection{Hokan3 with stencil}

フレーム補間の第3段階である．類似度が高い方向へのxy相対座標を元に，参照画像
を貼り付ける．一度のバースト演算により12行分の貼り付け処理を行う（RMGRP=12）．
ステンシル計算ではなくmapdist=0である．

\begin{screen}
\tiny
\begin{verbatim}
void hokan3(Uint *minxy, Uint *r, Uint *d)
#if !defined(EMAX5) && !defined(EMAX6)
  for (top=PAD; top<HT-PAD; top++) { /* scan-lines */
    Uint *xy = minxy+(top/4*4)*WD;
    Uint *dp = d+top*WD;
    for (pofs=-2; pofs<2; pofs++) {
      Uint *rp = r+(top+pofs)*WD;
      for (cofs=0; cofs<WD; cofs++) {
        int x = (int) xy[cofs/4*4]>>24;
        int y = (int)(xy[cofs/4*4]<<8)>>24;
        if (y == pofs) dp[cofs] = rp[cofs+x];
      }
    }
  }
#endif
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
  for (top=0; top<RRANGE; top+=RMGRP) { /* will be parallelized by multi-chip (M/#chip) */
    for (rofs=0; rofs<RMGRP; rofs++) { /* will be parallelized by multi-chip (M/#chip) */
      for (CHIP=0; CHIP<NCHIP; CHIP++) { /* will be parallelized by multi-chip (M/#chip) */
        int idx = CHIP*RRANGE+top+rofs;
        Uint *xy = minxy+(idx/4*4)*WD;
        Uint *dp = d+idx*WD;
        Uint *rp0 = r+(idx-2)*WD;
        Uint *rp1 = r+(idx-1)*WD;
        Uint *rp2 = r+(idx+0)*WD;
        Uint *rp3 = r+(idx+1)*WD;
        for (cofs=0; cofs<WD; cofs++) {
          int x = (int) xy[cofs/4*4]>>24;
          int y = (int)(xy[cofs/4*4]<<8)>>24;
          dp[cofs] = (y == -2)?rp0[cofs+x]:
                     (y == -1)?rp1[cofs+x]:
                     (y ==  0)?rp2[cofs+x]:
                     (y ==  1)?rp3[cofs+x]:0;
        }
      }
    }
  }
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
  Ull  LOOP1, LOOP0;
  Ull  INIT1, INIT0;
  Ull  AR[64][4];                     /* output of EX     in each unit */
  Ull  BR[64][4][4];                  /* output registers in each unit */
  Ull  r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15;
  Ull  r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31;
  Ull  cc0, cc1, cc2, cc3, ex0, ex1;
  for (top=0; top<RRANGE; top+=RMGRP) { /* will be parallelized by multi-chip (M/#chip) */
    for (rofs=0; rofs<RMGRP; rofs++) { /* will be parallelized by multi-chip (M/#chip) */
      Ull  jw;
      Uint *xy[NCHIP], *dp[NCHIP], *rp0[NCHIP], *rp1[NCHIP], *rp2[NCHIP], *rp3[NCHIP];
      for (CHIP=0; CHIP<NCHIP; CHIP++) { /* will be parallelized by multi-chip (M/#chip) */
        int idx   = CHIP*RRANGE+top+rofs;
        xy[CHIP]  = minxy+(idx/4*4)*WD;
        dp[CHIP]  = d+idx*WD;
        rp0[CHIP] = r+(idx-2)*WD;
        rp1[CHIP] = r+(idx-1)*WD;
        rp2[CHIP] = r+(idx+0)*WD;
        rp3[CHIP] = r+(idx+1)*WD;
      }
//EMAX5A begin hokan3 mapdist=0
 /*2*/for (CHIP=0; CHIP<NCHIP; CHIP++) { /* output channels are parallelized by multi-chip (OC/#chip) */
   /*1*/for (INIT0=1,LOOP0=WD,cofs=0-4; LOOP0--; INIT0=0) {       /* stage#0 *//* mapped to FOR() on BR[63][0][0] */
 /*@0,1*/ exe(OP_ADD,     &cofs, INIT0?cofs:cofs, EXP_H3210, 4, EXP_H3210, 0LL, EXP_H3210, OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL);
 /*@1,0*/ exe(OP_NOP,     &jw,   cofs, EXP_H3210, 0LL,  EXP_H3210, 0LL, EXP_H3210, OP_AND, ~15LL,         OP_SLL,   0LL);

 /*@2,0*/ mop(OP_LDWR, 1, &r10,  xy[CHIP],    jw, MSK_D0,   xy[CHIP],   WD,    0, 0, (Ull)NULL,       WD);
 /*@3,0*/ exe(OP_NOP,     &r2,   r10,  EXP_H3210, 0LL,  EXP_H3210, 0LL, EXP_H3210, OP_AND,  0xff000000LL, OP_SRAA, 22LL); /*x*/
 /*@3,1*/ exe(OP_NOP,     &r3,   r10,  EXP_H3210, 0LL,  EXP_H3210, 0LL, EXP_H3210, OP_AND,  0x00ff0000LL, OP_SRAB, 16LL); /*y*/
 /*@4,0*/ exe(OP_ADD,     &r4,   r2,   EXP_H3210, cofs, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,          OP_NOP,   0LL);

 /*@5,0*/ mop(OP_LDWR, 1, &r10,  rp0[CHIP],  r4,  MSK_D0,    rp0[CHIP], WD,    0, 0, (Ull)NULL,       WD);            /*rp0[cofs+x]*/
 /*@5,0*/ exe(OP_CMP_EQ,  &r5,   r3,  EXP_H3210, -2,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,          OP_NOP,   0LL);  /*y==-2?*/
 /*@6,0*/ exe(OP_CMOV,    &r0,   r5,  EXP_H3210, r10,  EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,          OP_NOP,   0LL);

 /*@6,0*/ mop(OP_LDWR, 1, &r10,  rp1[CHIP],  r4,  MSK_D0,    rp1[CHIP], WD,    0, 0, (Ull)NULL,       WD);            /*rp1[cofs+x]*/
 /*@6,1*/ exe(OP_CMP_EQ,  &r5,   r3,  EXP_H3210, -1,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,          OP_NOP,   0LL);  /*y==-1?*/
 /*@7,0*/ exe(OP_CMOV,    &r0,   r5,  EXP_H3210, r10,  EXP_H3210,  r0, EXP_H3210, OP_NOP,  0LL,          OP_NOP,   0LL);

 /*@7,0*/ mop(OP_LDWR, 1, &r10,  rp2[CHIP],  r4,  MSK_D0,    rp2[CHIP], WD,    0, 0, (Ull)NULL,       WD);            /*rp2[cofs+x]*/
 /*@7,1*/ exe(OP_CMP_EQ,  &r5,   r3,  EXP_H3210,  0,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,          OP_NOP,   0LL);  /*y== 0?*/
 /*@8,0*/ exe(OP_CMOV,    &r0,   r5,  EXP_H3210, r10,  EXP_H3210,  r0, EXP_H3210, OP_NOP,  0LL,          OP_NOP,   0LL);

 /*@8,0*/ mop(OP_LDWR, 1, &r10,  rp3[CHIP],  r4,  MSK_D0,    rp3[CHIP], WD,    0, 0, (Ull)NULL,       WD);            /*rp3[cofs+x]*/
 /*@8,1*/ exe(OP_CMP_EQ,  &r5,   r3,  EXP_H3210,  1,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,          OP_NOP,   0LL);  /*y== 1?*/
 /*@9,0*/ exe(OP_CMOV,    &r0,   r5,  EXP_H3210, r10,  EXP_H3210,  r0, EXP_H3210, OP_NOP,  0LL,          OP_NOP,   0LL);
 /*@9,0*/ mop(OP_STWR, 3, &r0,   dp[CHIP],  cofs, MSK_D0,     dp[CHIP], WD,    0, 1, (Ull)NULL,       WD);
        }
      }
//EMAX5A end
    }
  }
//EMAX5A drain_dirty_lmm
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\epsfile{file=filter+rmm-hokan3-emax6.eps,width=1.00\textwidth}
\caption{Hokan3}
\end{figure}

\clearpage

\subsection{Expand4k with stencil}

\begin{figure}[htbp]
\center
\includegraphics[angle=270,origin=b,width=0.75\textwidth]{expand4k.eps}
\caption{Expand4k}
\end{figure}

超解像処理である．低解像度画像を拡大補間して高解像度画像を生成する．一度のバー
スト演算により12行分の補間処理を行う（RMGRP=12）．入力画像の移動距離が一定で
はないためステンシル計算ではなくmapdist=0である．

\begin{screen}
\tiny
\begin{verbatim}
void expand4k(Uint *p, struct X *r)
#if !defined(EMAX5) && !defined(EMAX6)
  for (top=0; top<RRANGE; top+=RMGRP) { /* scan-lines */
    for (rofs=0; rofs<RMGRP; rofs++) { /* will be parallelized by multi-chip (M/#chip) */
      for (CHIP=0; CHIP<NCHIP; CHIP++) { /* will be parallelized by multi-chip (M/#chip) */
        int idx = CHIP*RRANGE+top+rofs;
        int k = idx*HT/768;
        int kfraq = (((idx*HT)<<4)/768)&15; /* 4bit */
        int kad = 16-ad(kfraq,8);
        int sk1 = ss(kfraq,8);
        int sk2 = ss(8,kfraq);
        Uint *pp = p+k*WD;
        Uint *rp = r->X[idx];
        for (cofs=0; cofs<1024; cofs++) { /* 本当は4095まで */
          int p1 = cofs*WD/1024;
          int lfraq = (((cofs*WD)<<4)/1024)&15; /* 4bit */
          int lad = 16-ad(lfraq,8);
          int sl1 = ss(lfraq,8);
          int sl2 = ss(8,lfraq);
          int r1 = kad*lad; /* 4bit*4bit */
          int r3 = kad*sl1; /* 4bit*4bit */
          int r2 = kad*sl2; /* 4bit*4bit */
          int r5 = sk1*lad; /* 4bit*4bit */
          int r9 = sk1*sl1; /* 4bit*4bit */
          int r8 = sk1*sl2; /* 4bit*4bit */
          int r4 = sk2*lad; /* 4bit*4bit */
          int r7 = sk2*sl1; /* 4bit*4bit */
          int r6 = sk2*sl2; /* 4bit*4bit */
          *rp = (unsigned int)((pp[p1]>>24&0xff)*r1
              +  (pp[p1   -1]>>24&0xff)*r2 + (pp[p1   +1]>>24&0xff)*r3 + (pp[p1-WD  ]>>24&0xff)*r4 + (pp[p1+WD  ]>>24&0xff)*r5
              +  (pp[p1-WD-1]>>24&0xff)*r6 + (pp[p1-WD+1]>>24&0xff)*r7 + (pp[p1+WD-1]>>24&0xff)*r8 + (pp[p1+WD+1]>>24&0xff)*r9)/256<<24
              | (unsigned int)((pp[p1]>>16&0xff)*r1
              +  (pp[p1   -1]>>16&0xff)*r2 + (pp[p1   +1]>>16&0xff)*r3 + (pp[p1-WD  ]>>16&0xff)*r4 + (pp[p1+WD  ]>>16&0xff)*r5
              +  (pp[p1-WD-1]>>16&0xff)*r6 + (pp[p1-WD+1]>>16&0xff)*r7 + (pp[p1+WD-1]>>16&0xff)*r8 + (pp[p1+WD+1]>>16&0xff)*r9)/256<<16
              | (unsigned int)((pp[p1]>> 8&0xff)*r1
              +  (pp[p1   -1]>> 8&0xff)*r2 + (pp[p1   +1]>> 8&0xff)*r3 + (pp[p1-WD  ]>> 8&0xff)*r4 + (pp[p1+WD  ]>> 8&0xff)*r5
              +  (pp[p1-WD-1]>> 8&0xff)*r6 + (pp[p1-WD+1]>> 8&0xff)*r7 + (pp[p1+WD-1]>> 8&0xff)*r8 + (pp[p1+WD+1]>> 8&0xff)*r9)/256<<8;
          rp++;
        }
      }
    }
  }
#endif
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
  for (top=0; top<RRANGE; top+=RMGRP) { /* scan-lines */
    for (rofs=0; rofs<RMGRP; rofs++) { /* will be parallelized by multi-chip (M/#chip) */
      for (CHIP=0; CHIP<NCHIP; CHIP++) { /* will be parallelized by multi-chip (M/#chip) */
        int idx = CHIP*RRANGE+top+rofs;
        int k = idx*HT/768;
        int kfraq = (((idx*HT)<<4)/768)&15; /* 4bit */
        int kad = 16-ad(kfraq,8);
        int sk1 = ss(kfraq,8);
        int sk2 = ss(8,kfraq);
        Uint *pp = p+k*WD;
        Uint *rp = r->X[idx];
        for (cofs=0; cofs<1024; cofs++) { /* 本当は4095まで */
          int p1 = cofs*WD/1024;
          int lfraq = (((cofs*WD)<<4)/1024)&15; /* 4bit */
          int lad = 16-ad(lfraq,8);
          int sl1 = ss(lfraq,8);
          int sl2 = ss(8,lfraq);
          int r1 = kad*lad; /* 4bit*4bit */
          int r3 = kad*sl1; /* 4bit*4bit */
          int r2 = kad*sl2; /* 4bit*4bit */
          int r5 = sk1*lad; /* 4bit*4bit */
          int r9 = sk1*sl1; /* 4bit*4bit */
          int r8 = sk1*sl2; /* 4bit*4bit */
          int r4 = sk2*lad; /* 4bit*4bit */
          int r7 = sk2*sl1; /* 4bit*4bit */
          int r6 = sk2*sl2; /* 4bit*4bit */
          Uint ph, pl, x;
          ph = madd(mmul(b2h(pp[p1     ], 1), r1), mmul(b2h(pp[p1-1], 1), r2));
          ph = madd(mmul(b2h(pp[p1   +1], 1), r3), ph);
          ph = madd(mmul(b2h(pp[p1-WD  ], 1), r4), ph);
          ph = madd(mmul(b2h(pp[p1+WD  ], 1), r5), ph);
          ph = madd(mmul(b2h(pp[p1-WD-1], 1), r6), ph);
          ph = madd(mmul(b2h(pp[p1-WD+1], 1), r7), ph);
          ph = madd(mmul(b2h(pp[p1+WD-1], 1), r8), ph);
          ph = madd(mmul(b2h(pp[p1+WD+1], 1), r9), ph);
          pl = madd(mmul(b2h(pp[p1     ], 0), r1), mmul(b2h(pp[p1-1], 0), r2));
          pl = madd(mmul(b2h(pp[p1   +1], 0), r3), pl);
          pl = madd(mmul(b2h(pp[p1-WD  ], 0), r4), pl);
          pl = madd(mmul(b2h(pp[p1+WD  ], 0), r5), pl);
          pl = madd(mmul(b2h(pp[p1-WD-1], 0), r6), pl);
          pl = madd(mmul(b2h(pp[p1-WD+1], 0), r7), pl);
          pl = madd(mmul(b2h(pp[p1+WD-1], 0), r8), pl);
          pl = madd(mmul(b2h(pp[p1+WD+1], 0), r9), pl);
          *rp = h2b(msrl(ph, 8), 1) | h2b(msrl(pl, 8), 0);
          rp++;
        }
      }
    }
  }
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
  Ull  LOOP1, LOOP0;
  Ull  INIT1, INIT0;
  Ull  AR[64][4];                     /* output of EX     in each unit */
  Ull  BR[64][4][4];                  /* output registers in each unit */
  Ull  r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15;
  Ull  r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31;
  Ull  cc0, cc1, cc2, cc3, ex0, ex1;
  for (top=0; top<RRANGE; top+=RMGRP) { /* will be parallelized by multi-chip (M/#chip) */
    for (rofs=0; rofs<RMGRP; rofs++) { /* will be parallelized by multi-chip (M/#chip) */
      Sll  kad[NCHIP], sk1[NCHIP], sk2[NCHIP];
      Uint *pp[NCHIP], *p0[NCHIP], *p1[NCHIP], *p2[NCHIP], *rp[NCHIP];
      for (CHIP=0; CHIP<NCHIP; CHIP++) { /* will be parallelized by multi-chip (M/#chip) */
        int  idx   = CHIP*RRANGE+top+rofs;
        int  k     = idx*HT/768;
        int  kfraq = (((idx*HT)<<4)/768)&15; /* 4bit */
        kad[CHIP]  = 16-ad(kfraq,8);
        sk1[CHIP]  = ss(kfraq,8);
        sk2[CHIP]  = ss(8,kfraq);
        pp[CHIP]   = p+k*WD;
        p0[CHIP]   = pp[CHIP]-WD;
        p1[CHIP]   = pp[CHIP];
        p2[CHIP]   = pp[CHIP]+WD;
        rp[CHIP]   = r->X[idx];
      }
//EMAX5A begin expand4k mapdist=0
 /*2*/for (CHIP=0; CHIP<NCHIP; CHIP++) { /* output channels are parallelized by multi-chip (OC/#chip) */
   /*1*/for (INIT0=1,LOOP0=1024,cofs=0-WD; LOOP0--; INIT0=0) {       /* stage#0 *//* mapped to FOR() on BR[63][0][0] */
 /*@0,1*/ exe(OP_ADD,       &cofs, cofs,      EXP_H3210, WD,    EXP_H3210, 0LL, EXP_H3210, OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL);
 /*@1,0*/ exe(OP_NOP,       &r0,   cofs,      EXP_H3210, 0LL,   EXP_H3210, 0LL, EXP_H3210, OP_AND, ~1023LL,  OP_SRL,  8LL);
 /*@1,1*/ exe(OP_NOP,       &r4,   cofs,      EXP_H3210, 0LL,   EXP_H3210, 0LL, EXP_H3210, OP_AND,  0x3c0LL, OP_SRL,  6LL);
 /*@2,0*/ exe(OP_ADD,       &r0,   pp[CHIP],  EXP_H3210, r0,    EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,     OP_NOP,  0LL);
 /*@2,1*/ exe(OP_MSUH,      &r1,   r4,        EXP_H3210, 8LL,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,     OP_NOP,  0LL);
 /*@2,2*/ exe(OP_MSUH,      &r2,   8LL,       EXP_H3210, r4,    EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,     OP_NOP,  0LL);
 /*@2,3*/ exe(OP_MSSAD,     &r3,   0LL,       EXP_H3210, r4,    EXP_H3210, 8LL, EXP_H3210, OP_NOP,  0LL,     OP_NOP,  0LL);
 /*@3,3*/ exe(OP_MSUH,      &r3,   16LL,      EXP_H3210, r3,    EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,     OP_NOP,  0LL);

 /*@4,1*/ exe(OP_MLUH,      &r21,  sk2[CHIP], EXP_H3210, r1,    EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,     OP_NOP,  0LL);
 /*@4,1*/ mop(OP_LDWR, 1,   &r10,  r0, -1276, MSK_D0,    (Ull)p0[CHIP],    WD,    0, 0, (Ull)NULL,       WD);
 /*@4,2*/ exe(OP_MLUH,      &r22,  sk2[CHIP], EXP_H3210, r2,    EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,     OP_NOP,  0LL);
 /*@4,2*/ mop(OP_LDWR, 1,   &r11,  r0, -1284, MSK_D0,    (Ull)p0[CHIP],    WD,    0, 0, (Ull)NULL,       WD);
 /*@4,3*/ exe(OP_MLUH,      &r23,  sk2[CHIP], EXP_H3210, r3,    EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,     OP_NOP,  0LL);
 /*@4,3*/ mop(OP_LDWR, 1,   &r12,  r0, -1280, MSK_D0,    (Ull)p0[CHIP],    WD,    0, 0, (Ull)NULL,       WD);

 /*@5,1*/ exe(OP_MLUH,      &r13,  r10,       EXP_B5410, r21,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,     OP_NOP,  0LL);
 /*@5,2*/ exe(OP_MLUH,      &r14,  r11,       EXP_B5410, r22,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,     OP_NOP,  0LL);
 /*@5,3*/ exe(OP_MLUH,      &r15,  r12,       EXP_B5410, r23,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,     OP_NOP,  0LL);

 /*@6,0*/ exe(OP_MAUH3,     &r16,  r13,       EXP_H3210, r14,   EXP_H3210, r15, EXP_H3210, OP_NOP,  0LL,     OP_NOP,  0LL);
 /*@6,1*/ exe(OP_MLUH,      &r13,  r10,       EXP_B7632, r21,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,     OP_NOP,  0LL);
 /*@6,2*/ exe(OP_MLUH,      &r14,  r11,       EXP_B7632, r22,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,     OP_NOP,  0LL);
 /*@6,3*/ exe(OP_MLUH,      &r15,  r12,       EXP_B7632, r23,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,     OP_NOP,  0LL);

 /*@7,0*/ exe(OP_MAUH3,     &r17,  r13,       EXP_H3210, r14,   EXP_H3210, r15, EXP_H3210, OP_NOP,  0LL,     OP_NOP,  0LL);
 /*@7,1*/ exe(OP_MLUH,      &r21,  kad[CHIP], EXP_H3210, r1,    EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,     OP_NOP,  0LL);
 /*@7,1*/ mop(OP_LDWR, 1,   &r10,  r0,     4, MSK_D0,    (Ull)p1[CHIP],    WD,    0, 0, (Ull)NULL,       WD);
 /*@7,2*/ exe(OP_MLUH,      &r22,  kad[CHIP], EXP_H3210, r2,    EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,     OP_NOP,  0LL);
 /*@7,2*/ mop(OP_LDWR, 1,   &r11,  r0,    -4, MSK_D0,    (Ull)p1[CHIP],    WD,    0, 0, (Ull)NULL,       WD);
 /*@7,3*/ exe(OP_MLUH,      &r23,  kad[CHIP], EXP_H3210, r3,    EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,     OP_NOP,  0LL);
 /*@7,3*/ mop(OP_LDWR, 1,   &r12,  r0,     0, MSK_D0,    (Ull)p1[CHIP],    WD,    0, 0, (Ull)NULL,       WD);

 /*@8,1*/ exe(OP_MLUH,      &r13,  r10,       EXP_B5410, r21,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,     OP_NOP,  0LL);
 /*@8,2*/ exe(OP_MLUH,      &r14,  r11,       EXP_B5410, r22,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,     OP_NOP,  0LL);
 /*@8,3*/ exe(OP_MLUH,      &r15,  r12,       EXP_B5410, r23,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,     OP_NOP,  0LL);

 /*@9,0*/ exe(OP_MAUH3,     &r18,  r13,       EXP_H3210, r14,   EXP_H3210, r15, EXP_H3210, OP_NOP,  0LL,     OP_NOP,  0LL);
 /*@9,1*/ exe(OP_MLUH,      &r13,  r10,       EXP_B7632, r21,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,     OP_NOP,  0LL);
 /*@9,2*/ exe(OP_MLUH,      &r14,  r11,       EXP_B7632, r22,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,     OP_NOP,  0LL);
 /*@9,3*/ exe(OP_MLUH,      &r15,  r12,       EXP_B7632, r23,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,     OP_NOP,  0LL);

 /*@10,0*/exe(OP_MAUH3,     &r19,  r13,       EXP_H3210, r14,   EXP_H3210, r15, EXP_H3210, OP_NOP,  0LL,     OP_NOP,  0LL);
 /*@10,1*/exe(OP_MLUH,      &r21,  sk1[CHIP], EXP_H3210, r1,    EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,     OP_NOP,  0LL);
 /*@10,1*/mop(OP_LDWR, 1,   &r10,  r0,  1284, MSK_D0,    (Ull)p2[CHIP],    WD,    0, 0, (Ull)NULL,       WD);
 /*@10,2*/exe(OP_MLUH,      &r22,  sk1[CHIP], EXP_H3210, r2,    EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,     OP_NOP,  0LL);
 /*@10,2*/mop(OP_LDWR, 1,   &r11,  r0,  1276, MSK_D0,    (Ull)p2[CHIP],    WD,    0, 0, (Ull)NULL,       WD);
 /*@10,3*/exe(OP_MLUH,      &r23,  sk1[CHIP], EXP_H3210, r3,    EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,     OP_NOP,  0LL);
 /*@10,3*/mop(OP_LDWR, 1,   &r12,  r0,  1280, MSK_D0,    (Ull)p2[CHIP],    WD,    0, 0, (Ull)NULL,       WD);

 /*@11,1*/exe(OP_MLUH,      &r13,  r10,       EXP_B5410, r21,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,     OP_NOP,  0LL);
 /*@11,2*/exe(OP_MLUH,      &r14,  r11,       EXP_B5410, r22,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,     OP_NOP,  0LL);
 /*@11,3*/exe(OP_MLUH,      &r15,  r12,       EXP_B5410, r23,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,     OP_NOP,  0LL);

 /*@12,0*/exe(OP_MAUH3,     &r20,  r13,       EXP_H3210, r14,   EXP_H3210, r15, EXP_H3210, OP_NOP,  0LL,     OP_NOP,  0LL);
 /*@12,1*/exe(OP_MLUH,      &r13,  r10,       EXP_B7632, r21,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,     OP_NOP,  0LL);
 /*@12,2*/exe(OP_MLUH,      &r14,  r11,       EXP_B7632, r22,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,     OP_NOP,  0LL);
 /*@12,3*/exe(OP_MLUH,      &r15,  r12,       EXP_B7632, r23,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,     OP_NOP,  0LL);

 /*@13,0*/exe(OP_MAUH3,     &r21,  r13,       EXP_H3210, r14,   EXP_H3210, r15, EXP_H3210, OP_NOP,  0LL,     OP_NOP,  0LL);

 /*@14,0*/exe(OP_MAUH3,     &r21,  r17,       EXP_H3210, r19,   EXP_H3210, r21, EXP_H3210, OP_OR,   0LL,     OP_SRLM, 8LL);
 /*@14,1*/exe(OP_MAUH3,     &r20,  r16,       EXP_H3210, r18,   EXP_H3210, r20, EXP_H3210, OP_OR,   0LL,     OP_SRLM, 8LL);

 /*@15,0*/exe(OP_MH2BW,     &r31,  r21,       EXP_H3210, r20,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,     OP_NOP,  0LL);
 /*@15,0*/mop(OP_STWR, 3,   &r31,  (Ull)(rp[CHIP]++),    0LL,   MSK_D0, (Ull)rp[CHIP],  1024, 0, 0, (Ull)NULL, 1024);
        }
      }
//EMAX5A end
    }
  }
//EMAX5A drain_dirty_lmm
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\epsfile{file=filter+rmm-expand4k-emax6.eps,width=1.00\textwidth}
\caption{Expand4k}
\end{figure}

\clearpage

\subsection{Unsharp with stencil}

\begin{figure}[htbp]
\center
\includegraphics[angle=270,origin=b,width=0.75\textwidth]{unsharp.eps}
\caption{Unsharp}
\end{figure}

エッジを強調する3x3の鮮鋭化フィルタである．一度のバースト演算により，6箇所
（OMAP=6）の各々について，10行分のフィルタ処理を行う（RMGRP=10）．ステンシル
計算でありmapdist=1である．

\begin{screen}
\tiny
\begin{verbatim}
void unsharp(Uchar *p, Uchar *r)
#if !defined(EMAX5) && !defined(EMAX6)
  for (top=PAD; top<HT-PAD; top++) { /* scan-lines */
    Uchar *p0 = p+((top  )*WD+(0  ))*4;  // p1 p5 p2
    Uchar *p1 = p+((top-1)*WD+(0-1))*4;  // p6 p0 p7
    Uchar *p2 = p+((top-1)*WD+(0+1))*4;  // p3 p8 p4
    Uchar *p3 = p+((top+1)*WD+(0-1))*4;
    Uchar *p4 = p+((top+1)*WD+(0+1))*4;
    Uchar *p5 = p+((top-1)*WD+(0  ))*4;
    Uchar *p6 = p+((top  )*WD+(0-1))*4;
    Uchar *p7 = p+((top  )*WD+(0+1))*4;
    Uchar *p8 = p+((top+1)*WD+(0  ))*4;
    Uchar *rp = r+((top  )*WD+(0  ))*4;
    for (cofs=0; cofs<WD; cofs++) {
      int t0,t1,t2;
      rp[0] = 0;
      t0 = p0[1]; t1 = p1[1]+p2[1]+p3[1]+p4[1]; t2 = p5[1]+p6[1]+p7[1]+p8[1];
      rp[1] = limitRGB(( t0 * 239 - t1 * 13 - t2 * 15 - t2/4) >> 7);
      t0 = p0[2]; t1 = p1[2]+p2[2]+p3[2]+p4[2]; t2 = p5[2]+p6[2]+p7[2]+p8[2];
      rp[2] = limitRGB(( t0 * 239 - t1 * 13 - t2 * 15 - t2/4) >> 7);
      t0 = p0[3]; t1 = p1[3]+p2[3]+p3[3]+p4[3]; t2 = p5[3]+p6[3]+p7[3]+p8[3];
      rp[3] = limitRGB(( t0 * 239 - t1 * 13 - t2 * 15 - t2/4) >> 7);
      p0+=4; p1+=4; p2+=4; p3+=4; p4+=4; p5+=4; p6+=4; p7+=4; p8+=4; rp+=4;
    }
  }
#endif
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
  for (top=0; top<RRANGE; top+=RMGRP) { /* scan-lines */
    for (rofs=0; rofs<RMGRP; rofs++) { /* will be parallelized by multi-chip (M/#chip) */
      for (CHIP=0; CHIP<NCHIP; CHIP++) { /* will be parallelized by multi-chip (M/#chip) */
        int idx = (CHIP*RRANGE*OMAP+top+rofs)*WD;
        Uchar *p0 = p+(idx   +(0  ))*4;  // p1 p5 p2
        Uchar *p1 = p+(idx-WD+(0-1))*4;  // p6 p0 p7
        Uchar *p2 = p+(idx-WD+(0+1))*4;  // p3 p8 p4
        Uchar *p3 = p+(idx+WD+(0-1))*4;
        Uchar *p4 = p+(idx+WD+(0+1))*4;
        Uchar *p5 = p+(idx-WD+(0  ))*4;
        Uchar *p6 = p+(idx   +(0-1))*4;
        Uchar *p7 = p+(idx   +(0+1))*4;
        Uchar *p8 = p+(idx+WD+(0  ))*4;
        Uchar *rp = r+(idx   +(0  ))*4;
        for (cofs=0; cofs<WD; cofs++) {
          for (oc=0; oc<OMAP; oc++) {
            Uint pix0 = (oc*RRANGE*WD+cofs)*4+0;
            Uint pix1 = (oc*RRANGE*WD+cofs)*4+1;
            Uint pix2 = (oc*RRANGE*WD+cofs)*4+2;
            Uint pix3 = (oc*RRANGE*WD+cofs)*4+3;
            int t0,t1,t2;
            rp[pix0] = 0;
            t0 = p0[pix1]; t1 = p1[pix1]+p2[pix1]+p3[pix1]+p4[pix1]; t2 = p5[pix1]+p6[pix1]+p7[pix1]+p8[pix1];
            rp[pix1] = limitRGB(( t0 * 239 - t1 * 13 - t2 * 15 - t2/4) >> 7);
            t0 = p0[pix2]; t1 = p1[pix2]+p2[pix2]+p3[pix2]+p4[pix2]; t2 = p5[pix2]+p6[pix2]+p7[pix2]+p8[pix2];
            rp[pix2] = limitRGB(( t0 * 239 - t1 * 13 - t2 * 15 - t2/4) >> 7);
            t0 = p0[pix3]; t1 = p1[pix3]+p2[pix3]+p3[pix3]+p4[pix3]; t2 = p5[pix3]+p6[pix3]+p7[pix3]+p8[pix3];
            rp[pix3] = limitRGB(( t0 * 239 - t1 * 13 - t2 * 15 - t2/4) >> 7);
          }
        }
      }
    }
  }
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
  Ull  LOOP1, LOOP0;
  Ull  INIT1, INIT0;
  Ull  AR[64][4];                     /* output of EX     in each unit */
  Ull  BR[64][4][4];                  /* output registers in each unit */
  Ull  r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15;
  Ull  r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31;
  Ull  cc0, cc1, cc2, cc3, ex0, ex1;
  for (top=0; top<RRANGE; top+=RMGRP) { /* scan-lines */
    for (rofs=0; rofs<RMGRP; rofs++) { /* will be parallelized by multi-chip (M/#chip) */
      Uchar *pp0[NCHIP], *pc0[NCHIP], *pn0[NCHIP], *rc0[NCHIP];
      Uchar *pp1[NCHIP], *pc1[NCHIP], *pn1[NCHIP], *rc1[NCHIP];
      Uchar *pp2[NCHIP], *pc2[NCHIP], *pn2[NCHIP], *rc2[NCHIP];
      Uchar *pp3[NCHIP], *pc3[NCHIP], *pn3[NCHIP], *rc3[NCHIP];
      Uchar *pp4[NCHIP], *pc4[NCHIP], *pn4[NCHIP], *rc4[NCHIP];
      Uchar *pp5[NCHIP], *pc5[NCHIP], *pn5[NCHIP], *rc5[NCHIP];
      for (CHIP=0; CHIP<NCHIP; CHIP++) { /* will be parallelized by multi-chip (M/#chip) */
        int idx = (CHIP*RRANGE*OMAP+top+rofs)*WD*4;
        pp0[CHIP] = p+idx+RRANGE*WD* 0-1280;  pc0[CHIP] = p+idx+RRANGE*WD* 0; pn0[CHIP] = p+idx+RRANGE*WD* 0+1280; rc0[CHIP] = r+idx+RRANGE*WD* 0;
        pp1[CHIP] = p+idx+RRANGE*WD* 4-1280;  pc1[CHIP] = p+idx+RRANGE*WD* 4; pn1[CHIP] = p+idx+RRANGE*WD* 4+1280; rc1[CHIP] = r+idx+RRANGE*WD* 4;
        pp2[CHIP] = p+idx+RRANGE*WD* 8-1280;  pc2[CHIP] = p+idx+RRANGE*WD* 8; pn2[CHIP] = p+idx+RRANGE*WD* 8+1280; rc2[CHIP] = r+idx+RRANGE*WD* 8;
        pp3[CHIP] = p+idx+RRANGE*WD*12-1280;  pc3[CHIP] = p+idx+RRANGE*WD*12; pn3[CHIP] = p+idx+RRANGE*WD*12+1280; rc3[CHIP] = r+idx+RRANGE*WD*12;
        pp4[CHIP] = p+idx+RRANGE*WD*16-1280;  pc4[CHIP] = p+idx+RRANGE*WD*16; pn4[CHIP] = p+idx+RRANGE*WD*16+1280; rc4[CHIP] = r+idx+RRANGE*WD*16;
        pp5[CHIP] = p+idx+RRANGE*WD*20-1280;  pc5[CHIP] = p+idx+RRANGE*WD*20; pn5[CHIP] = p+idx+RRANGE*WD*20+1280; rc5[CHIP] = r+idx+RRANGE*WD*20;
      }
//EMAX5A begin unsharp mapdist=1
 /*2*/for (CHIP=0; CHIP<NCHIP; CHIP++) { /* output channels are parallelized by multi-chip (OC/#chip) */
   /*1*/for (INIT0=1,LOOP0=WD,cofs=0-4; LOOP0--; INIT0=0) {       /* stage#0 *//* mapped to FOR() on BR[63][0][0] */
 /*@0,1*/ exe(OP_ADD,       &cofs, cofs,      EXP_H3210, 4LL,  EXP_H3210, 0LL, EXP_H3210, OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL);
          /*map0*/
 /*@1,0*/ exe(OP_ADD,       &pofs, pc0[CHIP], EXP_H3210, cofs, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@2,0*/ mop(OP_LDWR, 1,   &r1,   pofs,     -1276, MSK_D0,    (Ull)pp0[CHIP], WD,    0, 0, (Ull)NULL,   WD);
 /*@2,0*/ mop(OP_LDWR, 1,   &r2,   pofs,     -1284, MSK_D0,    (Ull)pp0[CHIP], WD,    0, 0, (Ull)NULL,   WD);
 /*@2,1*/ mop(OP_LDWR, 1,   &r5,   pofs,     -1280, MSK_D0,    (Ull)pp0[CHIP], WD,    0, 0, (Ull)NULL,   WD);
 /*@3,0*/ exe(OP_MAUH,      &r11,  r1,        EXP_B5410, r2,   EXP_B5410, 0LL, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@3,0*/ mop(OP_LDWR, 1,   &r6,   pofs,      4,    MSK_D0,    (Ull)pc0[CHIP], WD,    0, 0, (Ull)NULL,   WD);
 /*@3,0*/ mop(OP_LDWR, 1,   &r7,   pofs,     -4,    MSK_D0,    (Ull)pc0[CHIP], WD,    0, 0, (Ull)NULL,   WD);
 /*@3,1*/ exe(OP_MAUH,      &r12,  r1,        EXP_B7632, r2,   EXP_B7632, 0LL, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@3,1*/ mop(OP_LDWR, 1,   &r0,   pofs,      0,    MSK_D0,    (Ull)pc0[CHIP], WD,    0, 0, (Ull)NULL,   WD);
 /*@4,0*/ exe(OP_MLUH,      &r20,  r0,        EXP_B5410, 239,  EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@4,0*/ mop(OP_LDWR, 1,   &r3,   pofs,      1284, MSK_D0,    (Ull)pn0[CHIP], WD,    0, 0, (Ull)NULL,   WD);
 /*@4,0*/ mop(OP_LDWR, 1,   &r4,   pofs,      1276, MSK_D0,    (Ull)pn0[CHIP], WD,    0, 0, (Ull)NULL,   WD);
 /*@4,1*/ exe(OP_MLUH,      &r21,  r0,        EXP_B7632, 239,  EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@4,1*/ mop(OP_LDWR, 1,   &r8,   pofs,      1280, MSK_D0,    (Ull)pn0[CHIP], WD,    0, 0, (Ull)NULL,   WD);
 /*@4,2*/ exe(OP_MAUH,      &r15,  r5,        EXP_B5410, r6,   EXP_B5410, 0LL, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@4,3*/ exe(OP_MAUH,      &r16,  r5,        EXP_B7632, r6,   EXP_B7632, 0LL, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@5,0*/ exe(OP_MAUH3,     &r11,  r3,        EXP_B5410, r4,   EXP_B5410, r11, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@5,1*/ exe(OP_MAUH3,     &r12,  r3,        EXP_B7632, r4,   EXP_B7632, r12, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@6,0*/ exe(OP_MLUH,      &r13,  r11,       EXP_H3210, 13,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@6,1*/ exe(OP_MLUH,      &r14,  r12,       EXP_H3210, 13,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@6,2*/ exe(OP_MAUH3,     &r15,  r7,        EXP_B5410, r8,   EXP_B5410, r15, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@6,3*/ exe(OP_MAUH3,     &r16,  r7,        EXP_B7632, r8,   EXP_B7632, r16, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@7,0*/ exe(OP_NOP,       &r7,   r15,       EXP_H3210, 0LL,  EXP_H3210, 0LL, EXP_H3210, OP_OR,   0LL,    OP_SRLM, 2LL);
 /*@7,1*/ exe(OP_MLUH,      &r17,  r15,       EXP_H3210, 15,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@7,2*/ exe(OP_NOP,       &r8,   r16,       EXP_H3210, 0LL,  EXP_H3210, 0LL, EXP_H3210, OP_OR,   0LL,    OP_SRLM, 2LL);
 /*@7,3*/ exe(OP_MLUH,      &r18,  r16,       EXP_H3210, 15,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@8,0*/ exe(OP_MSUH3,     &r10,  r20,       EXP_H3210, r7,   EXP_H3210, r17, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@8,1*/ exe(OP_MSUH3,     &r11,  r21,       EXP_H3210, r8,   EXP_H3210, r18, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@9,0*/ exe(OP_MSUH,      &r20,  r10,       EXP_H3210, r13,  EXP_H3210, 0LL, EXP_H3210, OP_OR,   0LL,    OP_SRLM, 7LL);
 /*@9,1*/ exe(OP_MSUH,      &r21,  r11,       EXP_H3210, r14,  EXP_H3210, 0LL, EXP_H3210, OP_OR,   0LL,    OP_SRLM, 7LL);
 /*@10,0*/exe(OP_MH2BW,     &r31,  r21,       EXP_H3210, r20,  EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@10,0*/mop(OP_STWR, 3,   &r31,  rc0[CHIP], cofs, MSK_D0,    rc0[CHIP],      WD,    0, 0, (Ull)NULL,   WD);
       :
          /*map5*/
 /*@46,1*/exe(OP_ADD,       &pofs, pc5[CHIP], EXP_H3210, cofs, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@47,0*/mop(OP_LDWR, 1,   &r1,   pofs,     -1276, MSK_D0,    (Ull)pp5[CHIP], WD,    0, 0, (Ull)NULL,   WD);
 /*@47,0*/mop(OP_LDWR, 1,   &r2,   pofs,     -1284, MSK_D0,    (Ull)pp5[CHIP], WD,    0, 0, (Ull)NULL,   WD);
 /*@47,1*/mop(OP_LDWR, 1,   &r5,   pofs,     -1280, MSK_D0,    (Ull)pp5[CHIP], WD,    0, 0, (Ull)NULL,   WD);
 /*@48,0*/exe(OP_MAUH,      &r11,  r1,        EXP_B5410, r2,   EXP_B5410, 0LL, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@48,0*/mop(OP_LDWR, 1,   &r6,   pofs,      4,    MSK_D0,    (Ull)pc5[CHIP], WD,    0, 0, (Ull)NULL,   WD);
 /*@48,0*/mop(OP_LDWR, 1,   &r7,   pofs,     -4,    MSK_D0,    (Ull)pc5[CHIP], WD,    0, 0, (Ull)NULL,   WD);
 /*@48,1*/exe(OP_MAUH,      &r12,  r1,        EXP_B7632, r2,   EXP_B7632, 0LL, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@48,1*/mop(OP_LDWR, 1,   &r0,   pofs,      0,    MSK_D0,    (Ull)pc5[CHIP], WD,    0, 0, (Ull)NULL,   WD);
 /*@49,0*/exe(OP_MLUH,      &r20,  r0,        EXP_B5410, 239,  EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@49,0*/mop(OP_LDWR, 1,   &r3,   pofs,      1284, MSK_D0,    (Ull)pn5[CHIP], WD,    0, 0, (Ull)NULL,   WD);
 /*@49,0*/mop(OP_LDWR, 1,   &r4,   pofs,      1276, MSK_D0,    (Ull)pn5[CHIP], WD,    0, 0, (Ull)NULL,   WD);
 /*@49,1*/exe(OP_MLUH,      &r21,  r0,        EXP_B7632, 239,  EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@49,1*/mop(OP_LDWR, 1,   &r8,   pofs,      1280, MSK_D0,    (Ull)pn5[CHIP], WD,    0, 0, (Ull)NULL,   WD);
 /*@49,2*/exe(OP_MAUH,      &r15,  r5,        EXP_B5410, r6,   EXP_B5410, 0LL, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@49,3*/exe(OP_MAUH,      &r16,  r5,        EXP_B7632, r6,   EXP_B7632, 0LL, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@50,0*/exe(OP_MAUH3,     &r11,  r3,        EXP_B5410, r4,   EXP_B5410, r11, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@50,1*/exe(OP_MAUH3,     &r12,  r3,        EXP_B7632, r4,   EXP_B7632, r12, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@51,0*/exe(OP_MLUH,      &r13,  r11,       EXP_H3210, 13,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@51,1*/exe(OP_MLUH,      &r14,  r12,       EXP_H3210, 13,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@51,2*/exe(OP_MAUH3,     &r15,  r7,        EXP_B5410, r8,   EXP_B5410, r15, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@51,3*/exe(OP_MAUH3,     &r16,  r7,        EXP_B7632, r8,   EXP_B7632, r16, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@52,0*/exe(OP_NOP,       &r7,   r15,       EXP_H3210, 0LL,  EXP_H3210, 0LL, EXP_H3210, OP_OR,   0LL,    OP_SRLM, 2LL);
 /*@52,1*/exe(OP_MLUH,      &r17,  r15,       EXP_H3210, 15,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@52,2*/exe(OP_NOP,       &r8,   r16,       EXP_H3210, 0LL,  EXP_H3210, 0LL, EXP_H3210, OP_OR,   0LL,    OP_SRLM, 2LL);
 /*@52,3*/exe(OP_MLUH,      &r18,  r16,       EXP_H3210, 15,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@53,0*/exe(OP_MSUH3,     &r10,  r20,       EXP_H3210, r7,   EXP_H3210, r17, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@53,1*/exe(OP_MSUH3,     &r11,  r21,       EXP_H3210, r8,   EXP_H3210, r18, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@54,0*/exe(OP_MSUH,      &r20,  r10,       EXP_H3210, r13,  EXP_H3210, 0LL, EXP_H3210, OP_OR,   0LL,    OP_SRLM, 7LL);
 /*@54,1*/exe(OP_MSUH,      &r21,  r11,       EXP_H3210, r14,  EXP_H3210, 0LL, EXP_H3210, OP_OR,   0LL,    OP_SRLM, 7LL);
 /*@55,0*/exe(OP_MH2BW,     &r31,  r21,       EXP_H3210, r20,  EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@55,0*/mop(OP_STWR, 3,   &r31,  rc5[CHIP], cofs, MSK_D0,    rc5[CHIP],      WD,    0, 0, (Ull)NULL,   WD);
        }
      }
//EMAX5A end
    }
  }
//EMAX5A drain_dirty_lmm
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\epsfile{file=filter+rmm-unsharp-emax6.eps,width=1.00\textwidth}
\caption{Unsharp}
\end{figure}

\clearpage

\subsection{Blur with stencil}

\begin{figure}[htbp]
\center
\includegraphics[angle=270,origin=b,width=0.55\textwidth]{blur.eps}
\caption{Blur}
\end{figure}

3x3のパイプライン化メディアンフィルタである．一度のバースト演算により，4箇所
（OMAP=4）の各々について，15行分のフィルタ処理を行う（RMGRP=15）．ステンシル
計算でありmapdist=1である．

\begin{screen}
\tiny
\begin{verbatim}
void blur(Uint *p, Uint *r)
#if !defined(EMAX5) && !defined(EMAX6)
  for (top=PAD; top<HT-PAD; top++) { /* scan-lines */
    Uint *p0 = p+(top  )*WD  ;
    Uint *p1 = p+(top  )*WD  ;
    Uint *p2 = p+(top  )*WD-1;
    Uint *p3 = p+(top  )*WD+1;
    Uint *p4 = p+(top-1)*WD  ;
    Uint *p5 = p+(top+1)*WD  ;
    Uint *p6 = p+(top-1)*WD-1;
    Uint *p7 = p+(top-1)*WD+1;
    Uint *p8 = p+(top+1)*WD-1;
    Uint *p9 = p+(top+1)*WD+1;
    Uint *rp = r+(top  )*WD  ;
    for (cofs=0; cofs<WD; cofs++) {
      *rp = (Uint)((*p1>>24&0xff)*20
          +  (*p2>>24&0xff)*12 + (*p3>>24&0xff)*12 + (*p4>>24&0xff)*12 + (*p5>>24&0xff)*12
          +  (*p6>>24&0xff)* 8 + (*p7>>24&0xff)* 8 + (*p8>>24&0xff)* 8 + (*p9>>24&0xff)* 8)/100<<24
          | (Uint)((*p1>>16&0xff)*20
          +  (*p2>>16&0xff)*12 + (*p3>>16&0xff)*12 + (*p4>>16&0xff)*12 + (*p5>>16&0xff)*12
          +  (*p6>>16&0xff)* 8 + (*p7>>16&0xff)* 8 + (*p8>>16&0xff)* 8 + (*p9>>16&0xff)* 8)/100<<16
          | (Uint)((*p1>> 8&0xff)*20
          +  (*p2>> 8&0xff)*12 + (*p3>> 8&0xff)*12 + (*p4>> 8&0xff)*12 + (*p5>> 8&0xff)*12
          +  (*p6>> 8&0xff)* 8 + (*p7>> 8&0xff)* 8 + (*p8>> 8&0xff)* 8 + (*p9>> 8&0xff)* 8)/100<<8;
      p0++; p1++; p2++; p3++; p4++; p5++; p6++; p7++; p8++; p9++; rp++;
    }
  }
#endif
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
  for (top=PAD; top<HT-PAD; top++) { /* scan-lines */
    Uint *p0 = p+(top  )*WD  ;
    Uint *p1 = p+(top  )*WD  ;
    Uint *p2 = p+(top  )*WD-1;
    Uint *p3 = p+(top  )*WD+1;
    Uint *p4 = p+(top-1)*WD  ;
    Uint *p5 = p+(top+1)*WD  ;
    Uint *p6 = p+(top-1)*WD-1;
    Uint *p7 = p+(top-1)*WD+1;
    Uint *p8 = p+(top+1)*WD-1;
    Uint *p9 = p+(top+1)*WD+1;
    Uint *rp = r+(top  )*WD  ;
    for (cofs=0; cofs<WD; cofs++) {
      Uint s0,s1,s2,s3,s4,s5,s6,s7,s8;
      Uint t0,t1,t2;
      s0=*p1;s1=*p2;s2=*p3;s3=*p4;s4=*p5;s5=*p6;s6=*p7;s7=*p8;s8=*p9;
      /*┌─┬─┬─┐  ┌─┬─┬─┐  ┌─┬─┬─┐  ┌─┬─┬─┐  ┌─┬─┬─┐  ┌─┬─┬─┐  ┌─┐
        │５│３│６│  │５＜３＜★│  │５│３│２│  │５＜３＜★│  │５│  │３│  │５＜  ＜★│  │５│
        ├∨┼∨┼∨┤  ├─┼─┼─┤  ├∨┼∨┼∨┤  ├─┼─┼─┤  ├∨┼─┼∨┤  ├─┼─┼─┤  ├∨┤
        │１│０│２│  │１＜０＜２│  │−│０│−│  │    ０    │  │  │  │０│  │  │  │０│  │０│中間値確定
        ├∨┼∨┼∨┤  ├─┼─┼─┤  ├∨┼∨┼∨┤  ├─┼─┼─┤  ├∨┼─┼∨┤  ├─┼─┼─┤  ├∨┤
        │７│４│８│  │★＜４＜８│  │１│４│８│  │★＜４＜８│  │４│  │８│  │★＜  ＜８│  │８│
        └─┴─┴─┘  └─┴─┴─┘  └─┴─┴─┘  └─┴─┴─┘  └─┴─┴─┘  └─┴─┴─┘  └─┘*/
      t0 = pmax3(s5,s1,s7); t1 = pmid3(s5,s1,s7); t2 = pmin3(s5,s1,s7);      s5 = t0; s1 = t1; s7 = t2;
      t0 = pmax3(s3,s0,s4); t1 = pmid3(s3,s0,s4); t2 = pmin3(s3,s0,s4);      s3 = t0; s0 = t1; s4 = t2;
      t0 = pmax3(s6,s2,s8); t1 = pmid3(s6,s2,s8); t2 = pmin3(s6,s2,s8);      s6 = t0; s2 = t1; s8 = t2;

      t0 = pmin3(s5,s3,s6); t1 = pmid3(s5,s3,s6);                            s5 = t0; s3 = t1;
      t0 = pmin3(s1,s0,s2); t1 = pmid3(s1,s0,s2); t2 = pmax3(s1,s0,s2);      s1 = t0; s0 = t1; s2 = t2;
      t0 = pmid3(s7,s4,s8); t1 = pmax3(s7,s4,s8);                            s4 = t0; s8 = t1;

      t0 = pmax2(s5,s1);    t1 = pmin2(s5,s1);                               s5 = t0; s1 = t1;
      t0 = pmax3(s3,s0,s4); t1 = pmid3(s3,s0,s4); t2 = pmin3(s3,s0,s4);      s3 = t0; s0 = t1; s4 = t2;
      t0 = pmax2(s2,s8);    t1 = pmin2(s2,s8);                               s2 = t0; s8 = t1;

      t0 = pmin3(s5,s3,s2); t1 = pmid3(s5,s3,s2);                            s5 = t0; s3 = t1;
      t0 = pmid3(s1,s4,s8); t1 = pmax3(s1,s4,s8);                            s4 = t0; s8 = t1;

      t0 = pmax2(s5,s4);    t1 = pmin2(s5,s4);                               s5 = t0; s4 = t1;
      t0 = pmax3(s3,s0,s8); t1 = pmid3(s3,s0,s8); t2 = pmin3(s3,s0,s8);      s3 = t0; s0 = t1; s8 = t2;

      s5 = pmin2(s5,s3);    s8 = pmax2(s4,s8);

      *rp = pmid3(s5,s0,s8);
      p0++; p1++; p2++; p3++; p4++; p5++; p6++; p7++; p8++; p9++; rp++;
    }
  }
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
  Ull  LOOP1, LOOP0;
  Ull  INIT1, INIT0;
  Ull  AR[64][4];                     /* output of EX     in each unit */
  Ull  BR[64][4][4];                  /* output registers in each unit */
  Ull  r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15;
  Ull  r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31;
  Ull  cc0, cc1, cc2, cc3, ex0, ex1;
  for (top=0; top<RRANGE; top+=RMGRP) { /* scan-lines */
    for (rofs=0; rofs<RMGRP; rofs++) { /* will be parallelized by multi-chip (M/#chip) */
      Uint *pp0[NCHIP], *pc0[NCHIP], *pn0[NCHIP], *rc0[NCHIP];
      Uint *pp1[NCHIP], *pc1[NCHIP], *pn1[NCHIP], *rc1[NCHIP];
      Uint *pp2[NCHIP], *pc2[NCHIP], *pn2[NCHIP], *rc2[NCHIP];
      Uint *pp3[NCHIP], *pc3[NCHIP], *pn3[NCHIP], *rc3[NCHIP];
      for (CHIP=0; CHIP<NCHIP; CHIP++) { /* will be parallelized by multi-chip (M/#chip) */
        int idx = (CHIP*RRANGE*OMAP+top+rofs)*WD;
        pp0[CHIP] = p+idx+RRANGE*WD*0-WD;  pc0[CHIP] = p+idx+RRANGE*WD*0; pn0[CHIP] = p+idx+RRANGE*WD*0+WD; rc0[CHIP] = r+idx+RRANGE*WD*0;
        pp1[CHIP] = p+idx+RRANGE*WD*1-WD;  pc1[CHIP] = p+idx+RRANGE*WD*1; pn1[CHIP] = p+idx+RRANGE*WD*1+WD; rc1[CHIP] = r+idx+RRANGE*WD*1;
        pp2[CHIP] = p+idx+RRANGE*WD*2-WD;  pc2[CHIP] = p+idx+RRANGE*WD*2; pn2[CHIP] = p+idx+RRANGE*WD*2+WD; rc2[CHIP] = r+idx+RRANGE*WD*2;
        pp3[CHIP] = p+idx+RRANGE*WD*3-WD;  pc3[CHIP] = p+idx+RRANGE*WD*3; pn3[CHIP] = p+idx+RRANGE*WD*3+WD; rc3[CHIP] = r+idx+RRANGE*WD*3;
      }
//EMAX5A begin blur mapdist=1
 /*2*/for (CHIP=0; CHIP<NCHIP; CHIP++) { /* output channels are parallelized by multi-chip (OC/#chip) */
   /*1*/for (INIT0=1,LOOP0=WD,cofs=0-4; LOOP0--; INIT0=0) {       /* stage#0 *//* mapped to FOR() on BR[63][0][0] */
 /*@0,1*/ exe(OP_ADD,       &cofs, cofs,      EXP_H3210, 4LL,  EXP_H3210, 0LL, EXP_H3210, OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL);
          /*map0*/
 /*@1,0*/ exe(OP_ADD,       &pofs, pc0[CHIP], EXP_H3210, cofs, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@2,0*/ mop(OP_LDWR, 1,   &r7,   pofs,     -1276, MSK_D0,    pp0[CHIP],      WD,   0, 0, (Ull)NULL,    WD);
 /*@2,0*/ mop(OP_LDWR, 1,   &r1,   pofs,     -1280, MSK_D0,    pp0[CHIP],      WD,   0, 0, (Ull)NULL,    WD);
 /*@2,1*/ mop(OP_LDWR, 1,   &r5,   pofs,     -1284, MSK_D0,    pp0[CHIP],      WD,   0, 0, (Ull)NULL,    WD);
 /*@3,0*/ exe(OP_MMIN3,     &r17,  r7,        EXP_H3210, r1,   EXP_H3210, r5,  EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@3,0*/ mop(OP_LDWR, 1,   &r4,   pofs,         4, MSK_D0,    pc0[CHIP],      WD,   0, 0, (Ull)NULL,    WD);
 /*@3,0*/ mop(OP_LDWR, 1,   &r0,   pofs,         0, MSK_D0,    pc0[CHIP],      WD,   0, 0, (Ull)NULL,    WD);
 /*@3,1*/ exe(OP_MMID3,     &r11,  r7,        EXP_H3210, r1,   EXP_H3210, r5,  EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@3,1*/ mop(OP_LDWR, 1,   &r3,   pofs,        -4, MSK_D0,    pc0[CHIP],      WD,   0, 0, (Ull)NULL,    WD);
 /*@3,2*/ exe(OP_MMAX3,     &r15,  r7,        EXP_H3210, r1,   EXP_H3210, r5,  EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@4,0*/ exe(OP_MMIN3,     &r14,  r4,        EXP_H3210, r0,   EXP_H3210, r3,  EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@4,0*/ mop(OP_LDWR, 1,   &r8,   pofs,      1284, MSK_D0,    pn0[CHIP],      WD,   0, 0, (Ull)NULL,    WD);
 /*@4,0*/ mop(OP_LDWR, 1,   &r2,   pofs,      1280, MSK_D0,    pn0[CHIP],      WD,   0, 0, (Ull)NULL,    WD);
 /*@4,1*/ exe(OP_MMID3,     &r10,  r4,        EXP_H3210, r0,   EXP_H3210, r3,  EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@4,1*/ mop(OP_LDWR, 1,   &r6,   pofs,      1276, MSK_D0,    pn0[CHIP],      WD,   0, 0, (Ull)NULL,    WD);
 /*@4,2*/ exe(OP_MMAX3,     &r13,  r4,        EXP_H3210, r0,   EXP_H3210, r3,  EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@5,0*/ exe(OP_MMIN3,     &r18,  r8,        EXP_H3210, r2,   EXP_H3210, r6,  EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@5,1*/ exe(OP_MMID3,     &r12,  r8,        EXP_H3210, r2,   EXP_H3210, r6,  EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@5,2*/ exe(OP_MMAX3,     &r16,  r8,        EXP_H3210, r2,   EXP_H3210, r6,  EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*step-2*/
 /*@6,0*/ exe(OP_MMAX3,     &r2,   r11,       EXP_H3210, r10,  EXP_H3210, r12, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@6,1*/ exe(OP_MMID3,     &r0,   r11,       EXP_H3210, r10,  EXP_H3210, r12, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@6,2*/ exe(OP_MMIN3,     &r1,   r11,       EXP_H3210, r10,  EXP_H3210, r12, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@6,3*/ exe(OP_MMAX3,     &r8,   r17,       EXP_H3210, r14,  EXP_H3210, r18, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@7,0*/ exe(OP_MMID3,     &r4,   r17,       EXP_H3210, r14,  EXP_H3210, r18, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@7,1*/ exe(OP_MMID3,     &r3,   r15,       EXP_H3210, r13,  EXP_H3210, r16, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@7,2*/ exe(OP_MMIN3,     &r5,   r15,       EXP_H3210, r13,  EXP_H3210, r16, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*step-3*/
 /*@8,0*/ exe(OP_MMIN3,     &r14,  r3,        EXP_H3210, r0,   EXP_H3210, r4,  EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@8,1*/ exe(OP_MMID3,     &r10,  r3,        EXP_H3210, r0,   EXP_H3210, r4,  EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@8,2*/ exe(OP_MMAX3,     &r13,  r3,        EXP_H3210, r0,   EXP_H3210, r4,  EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@8,3*/ exe(OP_MMIN,      &r18,  r2,        EXP_H3210, r8,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@9,0*/ exe(OP_MMAX,      &r12,  r2,        EXP_H3210, r8,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@9,1*/ exe(OP_MMIN,      &r11,  r5,        EXP_H3210, r1,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@9,2*/ exe(OP_MMAX,      &r15,  r5,        EXP_H3210, r1,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*step-4*/
 /*@10,0*/exe(OP_MMID3,     &r4,   r11,       EXP_H3210, r14,  EXP_H3210, r18, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@10,1*/exe(OP_MMIN3,     &r5,   r15,       EXP_H3210, r13,  EXP_H3210, r12, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*step-5*/
 /*@10,2*/exe(OP_MMAX3,     &r8,   r11,       EXP_H3210, r14,  EXP_H3210, r18, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@10,3*/exe(OP_MMID3,     &r3,   r15,       EXP_H3210, r13,  EXP_H3210, r12, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@11,0*/exe(OP_MMIN,      &r14,  r5,        EXP_H3210, r4,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@11,1*/exe(OP_MMAX,      &r15,  r5,        EXP_H3210, r4,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@11,2*/exe(OP_MMIN3,     &r18,  r3,        EXP_H3210, r10,  EXP_H3210, r8,  EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@11,3*/exe(OP_MMID3,     &r10,  r3,        EXP_H3210, r10,  EXP_H3210, r8,  EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@12,0*/exe(OP_MMAX3,     &r13,  r3,        EXP_H3210, r10,  EXP_H3210, r8,  EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*step-6*/
 /*@12,1*/exe(OP_MMAX,      &r8,   r14,       EXP_H3210, r18,  EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@13,0*/exe(OP_MMIN,      &r5,   r15,       EXP_H3210, r13,  EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@14,0*/exe(OP_MMID3,     &r31,  r5,        EXP_H3210, r10,  EXP_H3210, r8,  EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@14,0*/mop(OP_STWR, 3,   &r31,  rc0[CHIP], cofs, MSK_D0,    rc0[CHIP],      WD,   0, 0, (Ull)NULL,    WD);
     :
          /*map3*/
 /*@40,1*/exe(OP_ADD,       &pofs, pc3[CHIP], EXP_H3210, cofs, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@41,0*/mop(OP_LDWR, 1,   &r7,   pofs,     -1276, MSK_D0,    pp3[CHIP],      WD,   0, 0, (Ull)NULL,    WD);
 /*@41,0*/mop(OP_LDWR, 1,   &r1,   pofs,     -1280, MSK_D0,    pp3[CHIP],      WD,   0, 0, (Ull)NULL,    WD);
 /*@41,1*/mop(OP_LDWR, 1,   &r5,   pofs,     -1284, MSK_D0,    pp3[CHIP],      WD,   0, 0, (Ull)NULL,    WD);
 /*@42,0*/exe(OP_MMIN3,     &r17,  r7,        EXP_H3210, r1,   EXP_H3210, r5,  EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@42,0*/mop(OP_LDWR, 1,   &r4,   pofs,         4, MSK_D0,    pc3[CHIP],      WD,   0, 0, (Ull)NULL,    WD);
 /*@42,0*/mop(OP_LDWR, 1,   &r0,   pofs,         0, MSK_D0,    pc3[CHIP],      WD,   0, 0, (Ull)NULL,    WD);
 /*@42,1*/exe(OP_MMID3,     &r11,  r7,        EXP_H3210, r1,   EXP_H3210, r5,  EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@42,1*/mop(OP_LDWR, 1,   &r3,   pofs,        -4, MSK_D0,    pc3[CHIP],      WD,   0, 0, (Ull)NULL,    WD);
 /*@42,2*/exe(OP_MMAX3,     &r15,  r7,        EXP_H3210, r1,   EXP_H3210, r5,  EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@43,0*/exe(OP_MMIN3,     &r14,  r4,        EXP_H3210, r0,   EXP_H3210, r3,  EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@43,0*/mop(OP_LDWR, 1,   &r8,   pofs,      1284, MSK_D0,    pn3[CHIP],      WD,   0, 0, (Ull)NULL,    WD);
 /*@43,0*/mop(OP_LDWR, 1,   &r2,   pofs,      1280, MSK_D0,    pn3[CHIP],      WD,   0, 0, (Ull)NULL,    WD);
 /*@43,1*/exe(OP_MMID3,     &r10,  r4,        EXP_H3210, r0,   EXP_H3210, r3,  EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@43,1*/mop(OP_LDWR, 1,   &r6,   pofs,      1276, MSK_D0,    pn3[CHIP],      WD,   0, 0, (Ull)NULL,    WD);
 /*@43,2*/exe(OP_MMAX3,     &r13,  r4,        EXP_H3210, r0,   EXP_H3210, r3,  EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@44,0*/exe(OP_MMIN3,     &r18,  r8,        EXP_H3210, r2,   EXP_H3210, r6,  EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@44,1*/exe(OP_MMID3,     &r12,  r8,        EXP_H3210, r2,   EXP_H3210, r6,  EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@44,2*/exe(OP_MMAX3,     &r16,  r8,        EXP_H3210, r2,   EXP_H3210, r6,  EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*step-2*/
    :
 /*step-5*/
 /*@49,2*/exe(OP_MMAX3,     &r8,   r11,       EXP_H3210, r14,  EXP_H3210, r18, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@49,3*/exe(OP_MMID3,     &r3,   r15,       EXP_H3210, r13,  EXP_H3210, r12, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@50,0*/exe(OP_MMIN,      &r14,  r5,        EXP_H3210, r4,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@50,1*/exe(OP_MMAX,      &r15,  r5,        EXP_H3210, r4,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@50,2*/exe(OP_MMIN3,     &r18,  r3,        EXP_H3210, r10,  EXP_H3210, r8,  EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@50,3*/exe(OP_MMID3,     &r10,  r3,        EXP_H3210, r10,  EXP_H3210, r8,  EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@51,0*/exe(OP_MMAX3,     &r13,  r3,        EXP_H3210, r10,  EXP_H3210, r8,  EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*step-6*/
 /*@51,1*/exe(OP_MMAX,      &r8,   r14,       EXP_H3210, r18,  EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@52,0*/exe(OP_MMIN,      &r5,   r15,       EXP_H3210, r13,  EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@53,0*/exe(OP_MMID3,     &r31,  r5,        EXP_H3210, r10,  EXP_H3210, r8,  EXP_H3210, OP_NOP,  0LL,    OP_NOP,  0LL);
 /*@53,0*/mop(OP_STWR, 3,   &r31,  rc3[CHIP], cofs, MSK_D0,    rc3[CHIP],      WD,   0, 0, (Ull)NULL,    WD);
        }
      }
//EMAX5A end
    }
  }
//EMAX5A drain_dirty_lmm
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\epsfile{file=filter+rmm-blur-emax6.eps,width=1.00\textwidth}
\caption{Blur}
\end{figure}

\clearpage

\subsection{Edge with stencil}

\begin{figure}[htbp]
\center
\includegraphics[angle=270,origin=b,width=0.75\textwidth]{edge.eps}
\caption{Edge}
\end{figure}

3x3のエッジ検出フィルタである．一度のバースト演算により，6箇所（OMAP=6）の各々
について，10行分のフィルタ処理を行う（RMGRP=10）．ステンシル計算であり
mapdist=1である．

\begin{screen}
\tiny
\begin{verbatim}
void edge(Uint *p, struct E *r)
#if !defined(EMAX5) && !defined(EMAX6)
  for (top=PAD; top<HT-PAD; top++) { /* scan-lines */
    Uint  *p0 = p+(top  )*WD  ;
    Uint  *p1 = p+(top-1)*WD-1;
    Uint  *p2 = p+(top+1)*WD+1;
    Uint  *p3 = p+(top-1)*WD  ;
    Uint  *p4 = p+(top+1)*WD  ;
    Uint  *p5 = p+(top-1)*WD+1;
    Uint  *p6 = p+(top+1)*WD-1;
    Uint  *p7 = p+(top  )*WD-1;
    Uint  *p8 = p+(top  )*WD+1;
    Uchar *rp = r->E[top];
    for (cofs=0; cofs<WD; cofs++) {
      int d1 = df(*p1&MASK,*p2&MASK)+df(*p3&MASK,*p4&MASK)+df(*p5&MASK,*p6&MASK)+df(*p7&MASK,*p8&MASK);
      /* 0 < d1(42) < 256*2*4 */
      *rp = d1 < EDGEDET ? 0 : PIXMAX;
      p0++; p1++; p2++; p3++; p4++; p5++; p6++; p7++; p8++; rp++;
    }
  }
#endif
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
  Ull  LOOP1, LOOP0;
  Ull  INIT1, INIT0;
  Ull  AR[64][4];                     /* output of EX     in each unit */
  Ull  BR[64][4][4];                  /* output registers in each unit */
  Ull  r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15;
  Ull  r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31;
  Ull  cc0, cc1, cc2, cc3, ex0, ex1;
  for (top=0; top<RRANGE; top+=RMGRP) { /* scan-lines */
    for (rofs=0; rofs<RMGRP; rofs++) { /* will be parallelized by multi-chip (M/#chip) */
      Uint *pp0[NCHIP], *pc0[NCHIP], *pn0[NCHIP]; Uchar *rc0[NCHIP];
      Uint *pp1[NCHIP], *pc1[NCHIP], *pn1[NCHIP]; Uchar *rc1[NCHIP];
      Uint *pp2[NCHIP], *pc2[NCHIP], *pn2[NCHIP]; Uchar *rc2[NCHIP];
      Uint *pp3[NCHIP], *pc3[NCHIP], *pn3[NCHIP]; Uchar *rc3[NCHIP];
      Uint *pp4[NCHIP], *pc4[NCHIP], *pn4[NCHIP]; Uchar *rc4[NCHIP];
      Uint *pp5[NCHIP], *pc5[NCHIP], *pn5[NCHIP]; Uchar *rc5[NCHIP];
      for (CHIP=0; CHIP<NCHIP; CHIP++) { /* will be parallelized by multi-chip (M/#chip) */
        int idx = (CHIP*RRANGE*OMAP+top+rofs)*WD;
        pp0[CHIP] = p+idx+RRANGE*WD*0-WD;  pc0[CHIP] = p+idx+RRANGE*WD*0; pn0[CHIP] = p+idx+RRANGE*WD*0+WD; rc0[CHIP] = (Uchar*)(r->E)+idx+RRANGE*WD*0;
        pp1[CHIP] = p+idx+RRANGE*WD*1-WD;  pc1[CHIP] = p+idx+RRANGE*WD*1; pn1[CHIP] = p+idx+RRANGE*WD*1+WD; rc1[CHIP] = (Uchar*)(r->E)+idx+RRANGE*WD*1;
        pp2[CHIP] = p+idx+RRANGE*WD*2-WD;  pc2[CHIP] = p+idx+RRANGE*WD*2; pn2[CHIP] = p+idx+RRANGE*WD*2+WD; rc2[CHIP] = (Uchar*)(r->E)+idx+RRANGE*WD*2;
        pp3[CHIP] = p+idx+RRANGE*WD*3-WD;  pc3[CHIP] = p+idx+RRANGE*WD*3; pn3[CHIP] = p+idx+RRANGE*WD*3+WD; rc3[CHIP] = (Uchar*)(r->E)+idx+RRANGE*WD*3;
        pp4[CHIP] = p+idx+RRANGE*WD*4-WD;  pc4[CHIP] = p+idx+RRANGE*WD*4; pn4[CHIP] = p+idx+RRANGE*WD*4+WD; rc4[CHIP] = (Uchar*)(r->E)+idx+RRANGE*WD*4;
        pp5[CHIP] = p+idx+RRANGE*WD*5-WD;  pc5[CHIP] = p+idx+RRANGE*WD*5; pn5[CHIP] = p+idx+RRANGE*WD*5+WD; rc5[CHIP] = (Uchar*)(r->E)+idx+RRANGE*WD*5;
      }
//EMAX5A begin edge mapdist=1
 /*2*/for (CHIP=0; CHIP<NCHIP; CHIP++) { /* output channels are parallelized by multi-chip (OC/#chip) */
   /*1*/for (INIT0=1,LOOP0=WD,cofs=0-4; LOOP0--; INIT0=0) {       /* stage#0 *//* mapped to FOR() on BR[63][0][0] */
 /*@0,1*/ exe(OP_ADD,       &cofs, cofs,        EXP_H3210, 4LL,  EXP_H3210, 0LL, EXP_H3210, OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL);
          /*map0*/
 /*@1,0*/ exe(OP_ADD,       &pofs, pc0[CHIP],   EXP_H3210, cofs, EXP_H3210, 0LL, EXP_H3210, OP_NOP,   0LL,    OP_NOP,  0LL);
 /*@2,0*/ mop(OP_LDWR, 1,   &r5,   pofs,       -1276, MSK_D0,    (Ull)pp0[CHIP],       WD,     0,   0,   (Ull)NULL,  WD);
 /*@2,0*/ mop(OP_LDWR, 1,   &r3,   pofs,       -1280, MSK_D0,    (Ull)pp0[CHIP],       WD,     0,   0,   (Ull)NULL,  WD);
 /*@2,1*/ mop(OP_LDWR, 1,   &r1,   pofs,       -1284, MSK_D0,    (Ull)pp0[CHIP],       WD,     0,   0,   (Ull)NULL,  WD);
 /*@3,0*/ exe(OP_NOP,    &AR[3][0],0LL,         EXP_H3210, 0LL,  EXP_H3210, 0LL, EXP_H3210, OP_OR,    0LL,    OP_NOP,  0LL);
 /*@3,0*/ mop(OP_LDWR, 1,   &r8,   pofs,           4, MSK_D0,    (Ull)pc0[CHIP],       WD,     0,   0,   (Ull)NULL,  WD);
 /*@3,0*/ mop(OP_LDWR, 1,   &r7,   pofs,          -4, MSK_D0,    (Ull)pc0[CHIP],       WD,     0,   0,   (Ull)NULL,  WD);
 /*@4,0*/ exe(OP_NOP,    &AR[4][0],0LL,         EXP_H3210, 0LL,  EXP_H3210, 0LL, EXP_H3210, OP_OR,    0LL,    OP_NOP,  0LL);
 /*@4,0*/ mop(OP_LDWR, 1,   &r2,   pofs,        1284, MSK_D0,    (Ull)pn0[CHIP],       WD,     0,   0,   (Ull)NULL,  WD);
 /*@4,0*/ mop(OP_LDWR, 1,   &r4,   pofs,        1280, MSK_D0,    (Ull)pn0[CHIP],       WD,     0,   0,   (Ull)NULL,  WD);
 /*@4,1*/ mop(OP_LDWR, 1,   &r6,   pofs,        1276, MSK_D0,    (Ull)pn0[CHIP],       WD,     0,   0,   (Ull)NULL,  WD);
 /*@4,1*/ exe(OP_MSSAD,     &r7,   0LL,         EXP_H3210, r7,   EXP_H3210, r8,  EXP_H3210, OP_NOP,   0LL,    OP_NOP,  0LL);
 /*@5,0*/ exe(OP_MSSAD,     &r1,   0LL,         EXP_H3210, r1,   EXP_H3210, r2,  EXP_H3210, OP_NOP,   0LL,    OP_NOP,  0LL);
 /*@5,1*/ exe(OP_MSSAD,     &r3,   0LL,         EXP_H3210, r3,   EXP_H3210, r4,  EXP_H3210, OP_NOP,   0LL,    OP_NOP,  0LL);
 /*@5,2*/ exe(OP_MSSAD,     &r5,   0LL,         EXP_H3210, r5,   EXP_H3210, r6,  EXP_H3210, OP_NOP,   0LL,    OP_NOP,  0LL);
 /*@6,0*/ exe(OP_MAUH,      &r1,   r3,          EXP_H3210, r1,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,   0LL,    OP_NOP,  0LL);
 /*@6,1*/ exe(OP_MAUH,      &r5,   r7,          EXP_H3210, r5,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,   0LL,    OP_NOP,  0LL);
 /*@7,0*/ exe(OP_MAUH,      &r1,   r5,          EXP_H3210, r1,   EXP_H3210, 0LL, EXP_H3210, OP_SUMHL, 0LL,    OP_NOP,  0LL);
 /*@8,0*/ exe(OP_MCAS,      &r31,  r1,          EXP_H3210, 64,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,   0LL,    OP_NOP,  0LL);
 /*@8,0*/ mop(OP_STBR, 3,   &r31,  rc0[CHIP]++,    0, MSK_D0,    (Ull)rc0[CHIP],     WD/4,     0,   0,   (Ull)NULL,  WD/4);
     :
          /*map5*/
 /*@36,1*/exe(OP_ADD,       &pofs, pc5[CHIP],   EXP_H3210, cofs, EXP_H3210, 0LL, EXP_H3210, OP_NOP,   0LL,    OP_NOP,  0LL);
 /*@37,0*/mop(OP_LDWR, 1,   &r5,   pofs,       -1276, MSK_D0,    (Ull)pp5[CHIP],       WD,     0,   0,   (Ull)NULL,  WD);
 /*@37,0*/mop(OP_LDWR, 1,   &r3,   pofs,       -1280, MSK_D0,    (Ull)pp5[CHIP],       WD,     0,   0,   (Ull)NULL,  WD);
 /*@37,1*/mop(OP_LDWR, 1,   &r1,   pofs,       -1284, MSK_D0,    (Ull)pp5[CHIP],       WD,     0,   0,   (Ull)NULL,  WD);
 /*@38,0*/exe(OP_NOP,    &AR[38][0],0LL,        EXP_H3210, 0LL,  EXP_H3210, 0LL, EXP_H3210, OP_OR,    0LL,    OP_NOP,  0LL);
 /*@38,0*/mop(OP_LDWR, 1,   &r8,   pofs,           4, MSK_D0,    (Ull)pc5[CHIP],       WD,     0,   0,   (Ull)NULL,  WD);
 /*@38,0*/mop(OP_LDWR, 1,   &r7,   pofs,          -4, MSK_D0,    (Ull)pc5[CHIP],       WD,     0,   0,   (Ull)NULL,  WD);
 /*@39,0*/exe(OP_NOP,    &AR[39][0],0LL,        EXP_H3210, 0LL,  EXP_H3210, 0LL, EXP_H3210, OP_OR,    0LL,    OP_NOP,  0LL);
 /*@39,0*/mop(OP_LDWR, 1,   &r2,   pofs,        1284, MSK_D0,    (Ull)pn5[CHIP],       WD,     0,   0,   (Ull)NULL,  WD);
 /*@39,0*/mop(OP_LDWR, 1,   &r4,   pofs,        1280, MSK_D0,    (Ull)pn5[CHIP],       WD,     0,   0,   (Ull)NULL,  WD);
 /*@39,1*/mop(OP_LDWR, 1,   &r6,   pofs,        1276, MSK_D0,    (Ull)pn5[CHIP],       WD,     0,   0,   (Ull)NULL,  WD);
 /*@39,1*/exe(OP_MSSAD,     &r7,   0LL,         EXP_H3210, r7,   EXP_H3210, r8,  EXP_H3210, OP_NOP,   0LL,    OP_NOP,  0LL);
 /*@40,0*/exe(OP_MSSAD,     &r1,   0LL,         EXP_H3210, r1,   EXP_H3210, r2,  EXP_H3210, OP_NOP,   0LL,    OP_NOP,  0LL);
 /*@40,1*/exe(OP_MSSAD,     &r3,   0LL,         EXP_H3210, r3,   EXP_H3210, r4,  EXP_H3210, OP_NOP,   0LL,    OP_NOP,  0LL);
 /*@40,2*/exe(OP_MSSAD,     &r5,   0LL,         EXP_H3210, r5,   EXP_H3210, r6,  EXP_H3210, OP_NOP,   0LL,    OP_NOP,  0LL);
 /*@41,0*/exe(OP_MAUH,      &r1,   r3,          EXP_H3210, r1,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,   0LL,    OP_NOP,  0LL);
 /*@41,1*/exe(OP_MAUH,      &r5,   r7,          EXP_H3210, r5,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,   0LL,    OP_NOP,  0LL);
 /*@42,0*/exe(OP_MAUH,      &r1,   r5,          EXP_H3210, r1,   EXP_H3210, 0LL, EXP_H3210, OP_SUMHL, 0LL,    OP_NOP,  0LL);
 /*@43,0*/exe(OP_MCAS,      &r31,  r1,          EXP_H3210, 64,   EXP_H3210, 0LL, EXP_H3210, OP_NOP,   0LL,    OP_NOP,  0LL);
 /*@43,0*/mop(OP_STBR, 3,   &r31,  rc5[CHIP]++,    0, MSK_D0,    (Ull)rc5[CHIP],     WD/4,     0,   0,   (Ull)NULL,  WD/4);
        }
      }
//EMAX5A end
    }
  }
//EMAX5A drain_dirty_lmm
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\epsfile{file=filter+rmm-edge-emax6.eps,width=1.00\textwidth}
\caption{Edge}
\end{figure}

\clearpage

\subsection{Stereo with stencil}

\begin{figure}[htbp]
\center
\includegraphics[angle=270,origin=b,width=0.75\textwidth]{stereo.eps}
\caption{Stereo}
\end{figure}

探索サイズ12x16のステレオマッチングである．一度のバースト演算により8行分の
SADを更新する．ステンシル計算ではなく，mapdist=0である．

\begin{screen}
\tiny
\begin{verbatim}
void wdifline(Uint *l, Uint *r, struct SAD2 *d, int k)
#if !defined(EMAX5) && !defined(EMAX6)
  for (top=DWIN; top<HT-DWIN; top++) { /* scan-lines */
    for (cofs=DWIN+k/2; cofs<WD-DWIN-k/2; cofs++) /* one scan-line */
      d->SAD2[top][cofs] = 0;
  }

  for (top=DWIN; top<HT-DWIN; top++) { /* scan-lines */
    Uint *lp = l + top*WD+k; /* L */
    Uint *rp = r + top*WD; /* R */
    for (pofs1=-DWIN; pofs1<DWIN; pofs1++) {
      Uint *dp = &d->SAD2[top+pofs1][DWIN+k/2];
      for (cofs=0; cofs<WD-DWIN*2; cofs++) { /* one scan-line */
        int x, retval = 0;
        for (x=0; x<DWIN*2; x++)
          retval += df((*(lp+cofs+x))&MASK, (*(rp+cofs+x))&MASK);
        *(dp+cofs) += retval;
      }
    }
  }
#endif
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
  for (top=0; top<RRANGE; top++) { /* will be parallelized by multi-chip (M/#chip) */
    for (CHIP=0; CHIP<NCHIP; CHIP++) { /* will be parallelized by multi-chip (M/#chip) */
      int idx = CHIP*RRANGE+DWIN+top;
      for (cofs=DWIN+k/2; cofs<WD-DWIN-k/2; cofs++) /* one scan-line */
        d->SAD2[idx][cofs] = 0;
    }
  }

  for (top=0; top<RRANGE; top++) { /* will be parallelized by multi-chip (M/#chip) */
    for (CHIP=0; CHIP<NCHIP; CHIP++) { /* will be parallelized by multi-chip (M/#chip) */
      int  idx = CHIP*RRANGE+DWIN+top;
      Uint *lp = l + idx*WD+k; /* L */
      Uint *rp = r + idx*WD; /* R */
      for (pofs1=-DWIN; pofs1<DWIN; pofs1++) {
        Uint *dp = &d->SAD2[idx+pofs1][DWIN+k/2];
        for (cofs=0; cofs<WD-DWIN*2; cofs++) { /* one scan-line */
          int x, retval = 0;
          for (x=0; x<DWIN*2; x++)
            retval += df((*(lp+cofs+x))&MASK, (*(rp+cofs+x))&MASK);
          *(dp+cofs) += retval;
        }
      }
    }
  }
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
  Ull  LOOP1, LOOP0;  Ull  INIT1, INIT0;
  Ull  AR[64][4];                     /* output of EX     in each unit */
  Ull  BR[64][4][4];                  /* output registers in each unit */
  Ull  r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15;
  Ull  r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31;
  Ull  cc0, cc1, cc2, cc3, ex0, ex1;
  for (top=0; top<RRANGE; top++) { /* will be parallelized by multi-chip (M/#chip) */
    for (CHIP=0; CHIP<NCHIP; CHIP++) { /* will be parallelized by multi-chip (M/#chip) */
      int idx = CHIP*RRANGE+DWIN+top;
      for (cofs=DWIN+k/2; cofs<WD-DWIN-k/2; cofs++) /* one scan-line */
        d->SAD2[idx][cofs] = 0;
  } }
  for (top=0; top<RRANGE; top++) { /* scan-lines */
    Uint *lp[NCHIP],  *rp[NCHIP];
    Uint *dp0[NCHIP], *dp1[NCHIP], *dp2[NCHIP], *dp3[NCHIP], *dp4[NCHIP], *dp5[NCHIP], *dp6[NCHIP], *dp7[NCHIP];
    Uint *dp8[NCHIP], *dp9[NCHIP], *dpa[NCHIP], *dpb[NCHIP], *dpc[NCHIP], *dpd[NCHIP], *dpe[NCHIP], *dpf[NCHIP];
    for (CHIP=0; CHIP<NCHIP; CHIP++) { /* will be parallelized by multi-chip (M/#chip) */
      int idx = CHIP*RRANGE+DWIN+top;
      lp[CHIP] = l+idx*WD+k; rp[CHIP] = r+idx*WD;
      dp0[CHIP] = &d->SAD2[idx-8][DWIN+k/2];
      dp1[CHIP] = &d->SAD2[idx-7][DWIN+k/2];
      dp2[CHIP] = &d->SAD2[idx-6][DWIN+k/2];
        :
      dpf[CHIP] = &d->SAD2[idx+7][DWIN+k/2];
    }
//EMAX5A begin wdifline mapdist=0
 /*2*/for (CHIP=0; CHIP<NCHIP; CHIP++) { /* output channels are parallelized by multi-chip (OC/#chip) */
   /*1*/for (INIT0=1,LOOP0=WD,cofs=0-4; LOOP0--; INIT0=0) {       /* stage#0 *//* mapped to FOR() on BR[63][0][0] */
 /*@0,1*/ exe(OP_ADD,      &cofs,        cofs,        EXP_H3210, 4LL,  EXP_H3210, 0LL, EXP_H3210, OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL);
          /*map0*/
 /*@1,0*/ exe(OP_ADD,      &rofs1,       lp[CHIP],   EXP_H3210, cofs, EXP_H3210,    0, EXP_H3210, OP_NOP,  0LL,  OP_NOP,  0LL);
 /*@1,1*/ exe(OP_ADD,      &rofs2,       rp[CHIP],   EXP_H3210, cofs, EXP_H3210,    0, EXP_H3210, OP_NOP,  0LL,  OP_NOP,  0LL);
 /*@2,0*/ mop(OP_LDWR, 1,  &r2,          rofs1,   0,  MSK_D0,    lp[CHIP],       WD, 0, 0, (Ull)NULL,    WD);
 /*@2,0*/ mop(OP_LDWR, 1,  &r3,          rofs1,   4,  MSK_D0,    lp[CHIP],       WD, 0, 0, (Ull)NULL,    WD);
 /*@2,1*/ mop(OP_LDWR, 1,  &r4,          rofs1,   8,  MSK_D0,    lp[CHIP],       WD, 0, 0, (Ull)NULL,    WD);
 /*@2,1*/ mop(OP_LDWR, 1,  &r5,          rofs1,   12, MSK_D0,    lp[CHIP],       WD, 0, 0, (Ull)NULL,    WD);
 /*@2,2*/ mop(OP_LDWR, 1,  &r6,          rofs2,   0,  MSK_D0,    rp[CHIP],       WD, 0, 0, (Ull)NULL,    WD);
 /*@2,2*/ mop(OP_LDWR, 1,  &r7,          rofs2,   4,  MSK_D0,    rp[CHIP],       WD, 0, 0, (Ull)NULL,    WD);
 /*@2,3*/ mop(OP_LDWR, 1,  &r8,          rofs2,   8,  MSK_D0,    rp[CHIP],       WD, 0, 0, (Ull)NULL,    WD);
 /*@2,3*/ mop(OP_LDWR, 1,  &r9,          rofs2,   12, MSK_D0,    rp[CHIP],       WD, 0, 0, (Ull)NULL,    WD);
 /*@3,0*/ exe(OP_MSAD,     &r22,         r2,          EXP_H3210, r6,   EXP_H3210,    0, EXP_H3210, OP_NOP,  0LL,  OP_NOP,  0LL);
 /*@3,0*/ mop(OP_LDWR, 1,  &r12,         rofs1,   16, MSK_D0,    lp[CHIP],       WD, 0, 0, (Ull)NULL,    WD);
 /*@3,0*/ mop(OP_LDWR, 1,  &r13,         rofs1,   20, MSK_D0,    lp[CHIP],       WD, 0, 0, (Ull)NULL,    WD);
 /*@3,1*/ exe(OP_MSAD,     &r23,         r3,          EXP_H3210, r7,   EXP_H3210,    0, EXP_H3210, OP_NOP,  0LL,  OP_NOP,  0LL);
 /*@3,1*/ mop(OP_LDWR, 1,  &r14,         rofs1,   24, MSK_D0,    lp[CHIP],       WD, 0, 0, (Ull)NULL,    WD);
 /*@3,1*/ mop(OP_LDWR, 1,  &r15,         rofs1,   28, MSK_D0,    lp[CHIP],       WD, 0, 0, (Ull)NULL,    WD);
 /*@3,2*/ exe(OP_MSAD,     &r24,         r4,          EXP_H3210, r8,   EXP_H3210,    0, EXP_H3210, OP_NOP,  0LL,  OP_NOP,  0LL);
 /*@3,2*/ mop(OP_LDWR, 1,  &r16,         rofs2,   16, MSK_D0,    rp[CHIP],       WD, 0, 0, (Ull)NULL,    WD);
 /*@3,2*/ mop(OP_LDWR, 1,  &r17,         rofs2,   20, MSK_D0,    rp[CHIP],       WD, 0, 0, (Ull)NULL,    WD);
 /*@3,3*/ exe(OP_MSAD,     &r25,         r5,          EXP_H3210, r9,   EXP_H3210,    0, EXP_H3210, OP_NOP,  0LL,  OP_NOP,  0LL);
 /*@3,3*/ mop(OP_LDWR, 1,  &r18,         rofs2,   24, MSK_D0,    rp[CHIP],       WD, 0, 0, (Ull)NULL,    WD);
 /*@3,3*/ mop(OP_LDWR, 1,  &r19,         rofs2,   28, MSK_D0,    rp[CHIP],       WD, 0, 0, (Ull)NULL,    WD);
 /*@4,0*/ exe(OP_MSSAD,    &r12,         r22,         EXP_H3210, r12,  EXP_H3210,  r16, EXP_H3210, OP_NOP,  0LL,  OP_NOP,  0LL);
 /*@4,0*/ mop(OP_LDWR, 1,  &r2,          rofs1,   32, MSK_D0,    lp[CHIP],       WD, 0, 0, (Ull)NULL,    WD);
 /*@4,0*/ mop(OP_LDWR, 1,  &r3,          rofs1,   36, MSK_D0,    lp[CHIP],       WD, 0, 0, (Ull)NULL,    WD);
 /*@4,1*/ exe(OP_MSSAD,    &r13,         r23,         EXP_H3210, r13,  EXP_H3210,  r17, EXP_H3210, OP_NOP,  0LL,  OP_NOP,  0LL);
 /*@4,1*/ mop(OP_LDWR, 1,  &r4,          rofs1,   40, MSK_D0,    lp[CHIP],       WD, 0, 0, (Ull)NULL,    WD);
 /*@4,1*/ mop(OP_LDWR, 1,  &r5,          rofs1,   44, MSK_D0,    lp[CHIP],       WD, 0, 0, (Ull)NULL,    WD);
 /*@4,2*/ exe(OP_MSSAD,    &r14,         r24,         EXP_H3210, r14,  EXP_H3210,  r18, EXP_H3210, OP_NOP,  0LL,  OP_NOP,  0LL);
 /*@4,2*/ mop(OP_LDWR, 1,  &r6,          rofs2,   32, MSK_D0,    rp[CHIP],       WD, 0, 0, (Ull)NULL,    WD);
 /*@4,2*/ mop(OP_LDWR, 1,  &r7,          rofs2,   36, MSK_D0,    rp[CHIP],       WD, 0, 0, (Ull)NULL,    WD);
 /*@4,3*/ exe(OP_MSSAD,    &r15,         r25,         EXP_H3210, r15,  EXP_H3210,  r19, EXP_H3210, OP_NOP,  0LL,  OP_NOP,  0LL);
 /*@4,3*/ mop(OP_LDWR, 1,  &r8,          rofs2,   40, MSK_D0,    rp[CHIP],       WD, 0, 0, (Ull)NULL,    WD);
 /*@4,3*/ mop(OP_LDWR, 1,  &r9,          rofs2,   44, MSK_D0,    rp[CHIP],       WD, 0, 0, (Ull)NULL,    WD);
 /*@5,0*/ exe(OP_MSSAD,    &r22,         r12,         EXP_H3210, r2,   EXP_H3210,  r6, EXP_H3210, OP_NOP,  0LL,  OP_NOP,  0LL);
 /*@5,1*/ exe(OP_MSSAD,    &r23,         r13,         EXP_H3210, r3,   EXP_H3210,  r7, EXP_H3210, OP_NOP,  0LL,  OP_NOP,  0LL);
 /*@5,2*/ exe(OP_MSSAD,    &r24,         r14,         EXP_H3210, r4,   EXP_H3210,  r8, EXP_H3210, OP_NOP,  0LL,  OP_NOP,  0LL);
 /*@5,3*/ exe(OP_MSSAD,    &r25,         r15,         EXP_H3210, r5,   EXP_H3210,  r9, EXP_H3210, OP_NOP,  0LL,  OP_NOP,  0LL);
 /*@6,0*/ exe(OP_MAUH3,    &r31,         r22,         EXP_H3210, r23,  EXP_H3210, r24, EXP_H3210, OP_NOP,  0LL,  OP_NOP,  0LL);
 /*@7,0*/ exe(OP_MAUH3,    &r1,          r31,         EXP_H3210, r25,  EXP_H3210,   0, EXP_H3210, OP_SUMHL,0LL,  OP_NOP,  0LL);
 /*@8,0*/ mop(OP_LDWR, 1,  &BR[8][0][1], dp0[CHIP], cofs, MSK_D0, (Ull)dp0[CHIP], WD, 0, 1, (Ull)NULL,    WD);
 /*@8,0*/ exe(OP_ADD,      &AR[8][0],    BR[8][0][1], EXP_H3210, r1,   EXP_H3210,    0, EXP_H3210, OP_NOP,  0LL,  OP_NOP,  0LL);
 /*@8,0*/ mop(OP_STWR, 3,  &AR[8][0],    cofs, dp0[CHIP], MSK_D0, (Ull)dp0[CHIP], WD, 0, 1, (Ull)NULL,    WD);
          /*map1*/
 /*@9,0*/ mop(OP_LDWR, 1,  &BR[9][0][1], dp1[CHIP], cofs, MSK_D0, (Ull)dp1[CHIP], WD, 0, 1, (Ull)NULL,    WD);
 /*@9,0*/ exe(OP_ADD,      &AR[9][0],    BR[9][0][1], EXP_H3210, r1,   EXP_H3210,    0, EXP_H3210, OP_NOP,  0LL,  OP_NOP,  0LL);
 /*@9,0*/ mop(OP_STWR, 3,  &AR[9][0],    cofs, dp1[CHIP], MSK_D0, (Ull)dp1[CHIP], WD, 0, 1, (Ull)NULL,    WD);
          /*map2*/
 /*@10,0*/mop(OP_LDWR, 1,  &BR[10][0][1],dp2[CHIP], cofs, MSK_D0, (Ull)dp2[CHIP], WD, 0, 1, (Ull)NULL,    WD);
 /*@10,0*/exe(OP_ADD,      &AR[10][0],   BR[10][0][1], EXP_H3210,r1,   EXP_H3210,    0, EXP_H3210, OP_NOP,  0LL,  OP_NOP,  0LL);
 /*@10,0*/mop(OP_STWR, 3,  &AR[10][0],   cofs, dp2[CHIP], MSK_D0, (Ull)dp2[CHIP], WD, 0, 1, (Ull)NULL,    WD);
          :
          /*map9*/
 /*@17,0*/mop(OP_LDWR, 1,  &BR[17][0][1],dp9[CHIP], cofs, MSK_D0, (Ull)dp9[CHIP], WD, 0, 1, (Ull)NULL,    WD);
 /*@17,0*/exe(OP_ADD,      &AR[17][0],   BR[17][0][1], EXP_H3210,r1,   EXP_H3210,    0, EXP_H3210, OP_NOP,  0LL,  OP_NOP,  0LL);
 /*@17,0*/mop(OP_STWR, 3,  &AR[17][0],   cofs, dp9[CHIP], MSK_D0, (Ull)dp9[CHIP], WD, 0, 1, (Ull)NULL,    WD);
          /*map10*/
 /*@18,0*/mop(OP_LDWR, 1,  &BR[18][0][1],dpa[CHIP], cofs, MSK_D0, (Ull)dpa[CHIP], WD, 0, 1, (Ull)NULL,    WD);
 /*@18,0*/exe(OP_ADD,      &AR[18][0],   BR[18][0][1], EXP_H3210,r1,   EXP_H3210,    0, EXP_H3210, OP_NOP,  0LL,  OP_NOP,  0LL);
 /*@18,0*/mop(OP_STWR, 3,  &AR[18][0],   cofs, dpa[CHIP], MSK_D0, (Ull)dpa[CHIP], WD, 0, 1, (Ull)NULL,    WD);
          /*map11*/
 /*@19,0*/mop(OP_LDWR, 1,  &BR[19][0][1],dpb[CHIP], cofs, MSK_D0, (Ull)dpb[CHIP], WD, 0, 1, (Ull)NULL,    WD);
 /*@19,0*/exe(OP_ADD,      &AR[19][0],   BR[19][0][1], EXP_H3210,r1,   EXP_H3210,    0, EXP_H3210, OP_NOP,  0LL,  OP_NOP,  0LL);
 /*@19,0*/mop(OP_STWR, 3,  &AR[19][0],   cofs, dpb[CHIP], MSK_D0, (Ull)dpb[CHIP], WD, 0, 1, (Ull)NULL,    WD);
          /*map12*/
 /*@20,0*/mop(OP_LDWR, 1,  &BR[20][0][1],dpc[CHIP], cofs, MSK_D0, (Ull)dpc[CHIP], WD, 0, 1, (Ull)NULL,    WD);
 /*@20,0*/exe(OP_ADD,      &AR[20][0],   BR[20][0][1], EXP_H3210,r1,   EXP_H3210,    0, EXP_H3210, OP_NOP,  0LL,  OP_NOP,  0LL);
 /*@20,0*/mop(OP_STWR, 3,  &AR[20][0],   cofs, dpc[CHIP], MSK_D0, (Ull)dpc[CHIP], WD, 0, 1, (Ull)NULL,    WD);
          /*map13*/
 /*@21,0*/mop(OP_LDWR, 1,  &BR[21][0][1],dpd[CHIP], cofs, MSK_D0, (Ull)dpd[CHIP], WD, 0, 1, (Ull)NULL,    WD);
 /*@21,0*/exe(OP_ADD,      &AR[21][0],   BR[21][0][1], EXP_H3210,r1,   EXP_H3210,    0, EXP_H3210, OP_NOP,  0LL,  OP_NOP,  0LL);
 /*@21,0*/mop(OP_STWR, 3,  &AR[21][0],   cofs, dpd[CHIP], MSK_D0, (Ull)dpd[CHIP], WD, 0, 1, (Ull)NULL,    WD);
          /*map14*/
 /*@22,0*/mop(OP_LDWR, 1,  &BR[22][0][1],dpe[CHIP], cofs, MSK_D0, (Ull)dpe[CHIP], WD, 0, 1, (Ull)NULL,    WD);
 /*@22,0*/exe(OP_ADD,      &AR[22][0],   BR[22][0][1], EXP_H3210,r1,   EXP_H3210,    0, EXP_H3210, OP_NOP,  0LL,  OP_NOP,  0LL);
 /*@22,0*/mop(OP_STWR, 3,  &AR[22][0],   cofs, dpe[CHIP], MSK_D0, (Ull)dpe[CHIP], WD, 0, 1, (Ull)NULL,    WD);
          /*map15*/
 /*@23,0*/mop(OP_LDWR, 1,  &BR[23][0][1],dpf[CHIP], cofs, MSK_D0, (Ull)dpf[CHIP], WD, 0, 1, (Ull)NULL,    WD);
 /*@23,0*/exe(OP_ADD,      &AR[23][0],   BR[23][0][1], EXP_H3210,r1,   EXP_H3210,    0, EXP_H3210, OP_NOP,  0LL,  OP_NOP,  0LL);
 /*@23,0*/mop(OP_STWR, 3,  &AR[23][0],   cofs, dpf[CHIP], MSK_D0, (Ull)dpf[CHIP], WD, 0, 1, (Ull)NULL,    WD);
      } }
//EMAX5A end
  }
//EMAX5A drain_dirty_lmm
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\epsfile{file=filter+rmm-wdifline-emax6.eps,width=1.00\textwidth}
\caption{Stereo with stencil}
\end{figure}

\clearpage

\section{3D-floating-point}

\shabox{
\leftline{cent\% make -f Makefile-csim.emax6+dma all clean}
\leftline{cent\% ../../src/csim/csim -x stencil-csim.emax6+dma}
}

\shabox{
\leftline{zynq\% make -f Makefile-zynq.emax6+dma all clean}
\leftline{zynq\% ./stencil-zynq.emax6+dma}
}

\subsection{Grapes with stencil}

\begin{figure}[htbp]
\center
\includegraphics[angle=270,origin=b,width=0.30\textwidth]{grapes.eps}
\caption{Grapes}
\end{figure}

19点浮動小数点ステンシル計算である．配列Aにステンシル性がないものの，起動回
数削減のため，一度のバースト演算により12行分を計算する（RMGRP=12）．配列Bは
再利用可能であるためmapdist=1である．

\begin{screen}
\tiny
\begin{verbatim}
grapes( float *c, float *a, float *b )
     /*C3D[DP][HT][WD]*/
     /*GrA[XC][DP][HT][WD]*/
     /*B3D[DP][HT][WD]*/
#define NCHIP     1
#define RMGRP     12
#define OMAP      1
#define PAD       1
#define RRANGE   ((HT-PAD*2)/NCHIP/OMAP)
  Ull  CHIP;
  Ull  LOOP1, LOOP0;
  Ull  INIT1, INIT0;
  Ull  AR[64][4];                     /* output of EX     in each unit */
  Ull  BR[64][4][4];                  /* output registers in each unit */
  Ull  r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15;
  Ull  r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31;
  Ull  cc0, cc1, cc2, cc3, ex0, ex1;
  int  x, y, z;
  int  row, col, n;
  Ull  roofs, coofs, aofs, bofs, cofs;

#if !defined(EMAX5) && !defined(EMAX6)
  for (z=PAD; z<DP-PAD; z++) {
    for (y=PAD; y<HT-PAD; y++) {
      for (x=PAD; x<WD-PAD; x++) {
        *(c+z*WDHT+y*WD+x) = *(b+(z-1)*WDHT+(y-1)*WD+x  ) * *(a+(MID-6)*WDHTDP+(z-1)*WDHT+(y-1)*WD+x  ) /* braw00 */ /* araw00 */
                           + *(b+(z-1)*WDHT+(y  )*WD+x-1) * *(a+(MID-5)*WDHTDP+(z-1)*WDHT+(y  )*WD+x-1) /* braw01 */ /* araw01 */
                           + *(b+(z-1)*WDHT+(y  )*WD+x  ) * *(a+(MID-4)*WDHTDP+(z-1)*WDHT+(y  )*WD+x  ) /* braw01 */ /* araw02 */
                           + *(b+(z-1)*WDHT+(y  )*WD+x+1) * *(a+(MID-5)*WDHTDP+(z-1)*WDHT+(y  )*WD+x+1) /* braw01 */ /* araw01 */
                           + *(b+(z-1)*WDHT+(y+1)*WD+x  ) * *(a+(MID-3)*WDHTDP+(z-1)*WDHT+(y+1)*WD+x  ) /* braw02 */ /* araw03 */
                           + *(b+(z  )*WDHT+(y-1)*WD+x-1) * *(a+(MID-2)*WDHTDP+(z  )*WDHT+(y-1)*WD+x-1) /* braw03 */ /* araw04 */
                           + *(b+(z  )*WDHT+(y-1)*WD+x  ) * *(a+(MID-1)*WDHTDP+(z  )*WDHT+(y-1)*WD+x  ) /* braw03 */ /* araw05 */
                           + *(b+(z  )*WDHT+(y-1)*WD+x+1) * *(a+(MID-2)*WDHTDP+(z  )*WDHT+(y-1)*WD+x+1) /* braw03 */ /* araw04 */
                           + *(b+(z  )*WDHT+(y  )*WD+x-1) * *(a+(MID  )*WDHTDP+(z  )*WDHT+(y  )*WD+x-1) /* braw04 */ /* araw06 */
                           + *(b+(z  )*WDHT+(y  )*WD+x  )                                               /* braw04 */
                           + *(b+(z  )*WDHT+(y  )*WD+x+1) * *(a+(MID  )*WDHTDP+(z  )*WDHT+(y  )*WD+x+1) /* braw04 */ /* araw06 */
                           + *(b+(z  )*WDHT+(y+1)*WD+x-1) * *(a+(MID+2)*WDHTDP+(z  )*WDHT+(y+1)*WD+x-1) /* braw05 */ /* araw08 */
                           + *(b+(z  )*WDHT+(y+1)*WD+x  ) * *(a+(MID+1)*WDHTDP+(z  )*WDHT+(y+1)*WD+x  ) /* braw05 */ /* araw07 */
                           + *(b+(z  )*WDHT+(y+1)*WD+x+1) * *(a+(MID+2)*WDHTDP+(z  )*WDHT+(y+1)*WD+x+1) /* braw05 */ /* araw08 */
                           + *(b+(z+1)*WDHT+(y-1)*WD+x  ) * *(a+(MID+3)*WDHTDP+(z+1)*WDHT+(y-1)*WD+x  ) /* braw06 */ /* araw09 */
                           + *(b+(z+1)*WDHT+(y  )*WD+x-1) * *(a+(MID+5)*WDHTDP+(z+1)*WDHT+(y  )*WD+x-1) /* braw07 */ /* araw0b */
                           + *(b+(z+1)*WDHT+(y  )*WD+x  ) * *(a+(MID+4)*WDHTDP+(z+1)*WDHT+(y  )*WD+x  ) /* braw07 */ /* araw0a */
                           + *(b+(z+1)*WDHT+(y  )*WD+x+1) * *(a+(MID+5)*WDHTDP+(z+1)*WDHT+(y  )*WD+x+1) /* braw07 */ /* araw0b */
                           + *(b+(z+1)*WDHT+(y+1)*WD+x  ) * *(a+(MID+6)*WDHTDP+(z+1)*WDHT+(y+1)*WD+x  );/* braw08 */ /* araw0c */
      }
    }
  }
#endif
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
  for (z=PAD; z<DP-PAD; z++) {
    for (y=0; y<RRANGE; y+=RMGRP) {
      Ull  atop[NCHIP], btop[NCHIP], ctop[NCHIP];
      Ull  arow00[NCHIP], arow01[NCHIP], arow02[NCHIP], arow03[NCHIP], arow04[NCHIP], arow05[NCHIP], arow06[NCHIP], arow07[NCHIP], arow08[NCHIP],
           arow09[NCHIP], arow0a[NCHIP], arow0b[NCHIP], arow0c[NCHIP];
      Ull  brow00[NCHIP], brow01[NCHIP], brow02[NCHIP], brow03[NCHIP], brow04[NCHIP], brow05[NCHIP], brow06[NCHIP], brow07[NCHIP], brow08[NCHIP];
      Ull  crow0[NCHIP];
      for (CHIP=0; CHIP<NCHIP; CHIP++) { /* output channels are parallelized by multi-chip (OC/#chip) */
        atop[CHIP]   = a               +(z  )*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;
        btop[CHIP]   = b               +(z  )*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;
        ctop[CHIP]   = c               +(z  )*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;
        arow00[CHIP] = a+(MID-6)*WDHTDP+(z-1)*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y-1)*WD;
        arow01[CHIP] = a+(MID-5)*WDHTDP+(z-1)*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;
        arow02[CHIP] = a+(MID-4)*WDHTDP+(z-1)*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;
        arow03[CHIP] = a+(MID-3)*WDHTDP+(z-1)*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y+1)*WD;
        arow04[CHIP] = a+(MID-2)*WDHTDP+(z  )*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y-1)*WD;
        arow05[CHIP] = a+(MID-1)*WDHTDP+(z  )*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y-1)*WD;
        arow06[CHIP] = a+(MID  )*WDHTDP+(z  )*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;
        arow07[CHIP] = a+(MID+1)*WDHTDP+(z  )*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y+1)*WD;
        arow08[CHIP] = a+(MID+2)*WDHTDP+(z  )*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y+1)*WD;
        arow09[CHIP] = a+(MID+3)*WDHTDP+(z+1)*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y-1)*WD;
        arow0a[CHIP] = a+(MID+4)*WDHTDP+(z+1)*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;
        arow0b[CHIP] = a+(MID+5)*WDHTDP+(z+1)*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;
        arow0c[CHIP] = a+(MID+6)*WDHTDP+(z+1)*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y+1)*WD;
        brow00[CHIP] = b               +(z-1)*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y-1)*WD;
        brow01[CHIP] = b               +(z-1)*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;
        brow02[CHIP] = b               +(z-1)*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y+1)*WD;
        brow03[CHIP] = b               +(z  )*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y-1)*WD;
        brow04[CHIP] = b               +(z  )*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;
        brow05[CHIP] = b               +(z  )*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y+1)*WD;
        brow06[CHIP] = b               +(z+1)*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y-1)*WD;
        brow07[CHIP] = b               +(z+1)*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;
        brow08[CHIP] = b               +(z+1)*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y+1)*WD;
        crow0[CHIP]  = c               +(z  )*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;
      }
//EMAX5A begin grapes mapdist=1
      for (CHIP=0; CHIP<NCHIP; CHIP++) { /* output channels are parallelized by multi-chip (OC/#chip) */
   /*2*/for (INIT1=1,LOOP1=RMGRP,roofs=0-WD*4; LOOP1--; INIT1=0) {      /* stage#0 *//* mapped to FOR() on BR[63][1][0] */
     /*1*/for (INIT0=1,LOOP0=WD-PAD*2,coofs=(PAD-1)*4; LOOP0--; INIT0=0) {          /* stage#0 *//* mapped to FOR() on BR[63][0][0] */
            exe(OP_ADD,  &coofs, INIT0?coofs:coofs, EXP_H3210, 4, EXP_H3210, 0LL, EXP_H3210, OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL); /* stage#0 */
            exe(OP_ADD,  &roofs, roofs,  EXP_H3210, INIT0?WD*4:0, EXP_H3210, 0LL, EXP_H3210, OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL); /* stage#0 */
            exe(OP_ADD3, &aofs,  atop[CHIP], EXP_H3210, roofs, EXP_H3210,  coofs, EXP_H3210, OP_AND, 0x000000ffffffffffLL, OP_NOP, 0LL); /* stage#1 */
            exe(OP_ADD3, &bofs,  btop[CHIP], EXP_H3210, roofs, EXP_H3210,  coofs, EXP_H3210, OP_AND, 0x000000ffffffffffLL, OP_NOP, 0LL); /* stage#1 */
            exe(OP_ADD3, &cofs,  ctop[CHIP], EXP_H3210, roofs, EXP_H3210,  coofs, EXP_H3210, OP_AND, 0x000000ffffffffffLL, OP_NOP, 0LL); /* stage#1 */
            /*map0*/
            mop(OP_LDWR, 1, &BR[2][0][1], bofs, (0               -WDHT-WD  )*4, MSK_D0, brow00[CHIP], WD*(RMGRP+PAD*2), 0, 0, (Ull)NULL, WD*(RMGRP+PAD*2));/*st#2*/
            mop(OP_LDWR, 1, &BR[2][2][1], aofs, (0+WDHTDP*(MID-6)-WDHT-WD  )*4, MSK_D0, arow00[CHIP], WD*RMGRP, 0, 0, (Ull)NULL, WD*RMGRP);/* stage#2 */
            exe(OP_FML, &r0, BR[2][0][1], EXP_H3210,  BR[2][2][1], EXP_H3210, 0,           EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);         /* stage#3 */
            mop(OP_LDWR, 1, &BR[3][0][1], bofs, (0               -WDHT   -1)*4, MSK_D0, brow00[CHIP], WD*(RMGRP+PAD*2), 0, 0, (Ull)NULL, WD*(RMGRP+PAD*2));/*st#3*/
            mop(OP_LDWR, 1, &BR[3][0][0], bofs, (0               -WDHT   +1)*4, MSK_D0, brow00[CHIP], WD*(RMGRP+PAD*2), 0, 0, (Ull)NULL, WD*(RMGRP+PAD*2));/*st#3*/
            mop(OP_LDWR, 1, &BR[3][1][1], bofs, (0               -WDHT     )*4, MSK_D0, brow00[CHIP], WD*(RMGRP+PAD*2), 0, 0, (Ull)NULL, WD*(RMGRP+PAD*2));/*st#3*/
            mop(OP_LDWR, 1, &BR[3][2][1], aofs, (0+WDHTDP*(MID-5)-WDHT   -1)*4, MSK_D0, arow01[CHIP], WD*RMGRP, 0, 0, (Ull)NULL, WD*RMGRP);/* stage#3 */
            mop(OP_LDWR, 1, &BR[3][2][0], aofs, (0+WDHTDP*(MID-5)-WDHT   +1)*4, MSK_D0, arow01[CHIP], WD*RMGRP, 0, 0, (Ull)NULL, WD*RMGRP);/* stage#3 */
            mop(OP_LDWR, 1, &BR[3][3][1], aofs, (0+WDHTDP*(MID-4)-WDHT     )*4, MSK_D0, arow02[CHIP], WD*RMGRP, 0, 0, (Ull)NULL, WD*RMGRP);/* stage#3 */
            exe(OP_FMA, &r1, r0,          EXP_H3210,  BR[3][0][1], EXP_H3210, BR[3][2][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);         /* stage#4 */
            exe(OP_FML, &r2, BR[3][0][0], EXP_H3210,  BR[3][2][0], EXP_H3210, 0,           EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);         /* stage#4 */
            exe(OP_FML, &r3, BR[3][1][1], EXP_H3210,  BR[3][3][1], EXP_H3210, 0,           EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);         /* stage#4 */
            mop(OP_LDWR, 1, &BR[4][0][1], bofs, (0               -WDHT+WD  )*4, MSK_D0, brow00[CHIP], WD*(RMGRP+PAD*2), 0, 0, (Ull)NULL, WD*(RMGRP+PAD*2));/*st#4*/
            mop(OP_LDWR, 1, &BR[4][2][1], aofs, (0+WDHTDP*(MID-3)-WDHT+WD  )*4, MSK_D0, arow03[CHIP], WD*RMGRP, 0, 0, (Ull)NULL, WD*RMGRP);/* stage#4 */
            exe(OP_FMA, &r4, r1,          EXP_H3210,  BR[4][0][1], EXP_H3210, BR[4][2][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);         /* stage#5 */
            exe(OP_FAD, &r5, r2,          EXP_H3210,  r3,          EXP_H3210, 0,           EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);         /* stage#5 */

            mop(OP_LDWR, 1, &BR[6][0][1], bofs, (0                    -WD-1)*4, MSK_D0, brow03[CHIP], WD*(RMGRP+PAD*2), 0, 0, (Ull)NULL, WD*(RMGRP+PAD*2));/*st#6*/
            mop(OP_LDWR, 1, &BR[6][0][0], bofs, (0                    -WD+1)*4, MSK_D0, brow03[CHIP], WD*(RMGRP+PAD*2), 0, 0, (Ull)NULL, WD*(RMGRP+PAD*2));/*st#6*/
            mop(OP_LDWR, 1, &BR[6][1][1], bofs, (0                    -WD  )*4, MSK_D0, brow03[CHIP], WD*(RMGRP+PAD*2), 0, 0, (Ull)NULL, WD*(RMGRP+PAD*2));/*st#6*/
            mop(OP_LDWR, 1, &BR[6][2][1], aofs, (0+WDHTDP*(MID-2)     -WD-1)*4, MSK_D0, arow04[CHIP], WD*RMGRP, 0, 0, (Ull)NULL, WD*RMGRP);/* stage#6 */
            mop(OP_LDWR, 1, &BR[6][2][0], aofs, (0+WDHTDP*(MID-2)     -WD+1)*4, MSK_D0, arow04[CHIP], WD*RMGRP, 0, 0, (Ull)NULL, WD*RMGRP);/* stage#6 */
            mop(OP_LDWR, 1, &BR[6][3][1], aofs, (0+WDHTDP*(MID-1)     -WD  )*4, MSK_D0, arow05[CHIP], WD*RMGRP, 0, 0, (Ull)NULL, WD*RMGRP);/* stage#6 */
            exe(OP_FMA, &r0, r4,          EXP_H3210,  BR[6][0][1], EXP_H3210, BR[6][2][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#7 */
            exe(OP_FMA, &r1, r5,          EXP_H3210,  BR[6][0][0], EXP_H3210, BR[6][2][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#7 */
            exe(OP_FML, &r2, BR[6][1][1], EXP_H3210,  BR[6][3][1], EXP_H3210, 0,           EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#7 */
            mop(OP_LDWR, 1, &BR[7][0][1], bofs, (0                       -1)*4, MSK_D0, brow03[CHIP], WD*(RMGRP+PAD*2), 0, 0, (Ull)NULL, WD*(RMGRP+PAD*2));/*st#7*/
            mop(OP_LDWR, 1, &BR[7][0][0], bofs, (0                       +1)*4, MSK_D0, brow03[CHIP], WD*(RMGRP+PAD*2), 0, 0, (Ull)NULL, WD*(RMGRP+PAD*2));/*st#7*/
            mop(OP_LDWR, 1, &BR[7][1][1], bofs, (0                         )*4, MSK_D0, brow03[CHIP], WD*(RMGRP+PAD*2), 0, 0, (Ull)NULL, WD*(RMGRP+PAD*2));/*st#7*/
            mop(OP_LDWR, 1, &BR[7][2][1], aofs, (0+WDHTDP*(MID  )        -1)*4, MSK_D0, arow06[CHIP], WD*RMGRP, 0, 0, (Ull)NULL, WD*RMGRP);/* stage#7 */
            mop(OP_LDWR, 1, &BR[7][2][0], aofs, (0+WDHTDP*(MID  )        +1)*4, MSK_D0, arow06[CHIP], WD*RMGRP, 0, 0, (Ull)NULL, WD*RMGRP);/* stage#7 */
            exe(OP_FMA, &r3, r0,          EXP_H3210,  BR[7][0][1], EXP_H3210, BR[7][2][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#8 */
            exe(OP_FMA, &r4, r1,          EXP_H3210,  BR[7][0][0], EXP_H3210, BR[7][2][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#8 */
            exe(OP_FAD, &r5, r2,          EXP_H3210,  BR[7][1][1], EXP_H3210, 0,           EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#8 */
            mop(OP_LDWR, 1, &BR[8][0][1], bofs, (0                    +WD-1)*4, MSK_D0, brow03[CHIP], WD*(RMGRP+PAD*2), 0, 0, (Ull)NULL, WD*(RMGRP+PAD*2));/*st#8*/
            mop(OP_LDWR, 1, &BR[8][0][0], bofs, (0                    +WD+1)*4, MSK_D0, brow03[CHIP], WD*(RMGRP+PAD*2), 0, 0, (Ull)NULL, WD*(RMGRP+PAD*2));/*st#8*/
            mop(OP_LDWR, 1, &BR[8][1][1], bofs, (0                    +WD  )*4, MSK_D0, brow03[CHIP], WD*(RMGRP+PAD*2), 0, 0, (Ull)NULL, WD*(RMGRP+PAD*2));/*st#8*/
            mop(OP_LDWR, 1, &BR[8][2][1], aofs, (0+WDHTDP*(MID+2)     +WD-1)*4, MSK_D0, arow08[CHIP], WD*RMGRP, 0, 0, (Ull)NULL, WD*RMGRP);/* stage#8 */
            mop(OP_LDWR, 1, &BR[8][2][0], aofs, (0+WDHTDP*(MID+2)     +WD+1)*4, MSK_D0, arow08[CHIP], WD*RMGRP, 0, 0, (Ull)NULL, WD*RMGRP);/* stage#8 */
            mop(OP_LDWR, 1, &BR[8][3][1], aofs, (0+WDHTDP*(MID+1)     +WD  )*4, MSK_D0, arow07[CHIP], WD*RMGRP, 0, 0, (Ull)NULL, WD*RMGRP);/* stage#8 */
            exe(OP_FMA, &r6, r3,          EXP_H3210,  BR[8][0][1], EXP_H3210, BR[8][2][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#9 */
            exe(OP_FMA, &r7, r4,          EXP_H3210,  BR[8][0][0], EXP_H3210, BR[8][2][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#9 */
            exe(OP_FMA, &r8, r5,          EXP_H3210,  BR[8][1][1], EXP_H3210, BR[8][3][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#9 */

            mop(OP_LDWR, 1, &BR[10][0][1],bofs, (0               +WDHT-WD  )*4, MSK_D0, brow06[CHIP], WD*(RMGRP+PAD*2), 0, 0, (Ull)NULL, WD*(RMGRP+PAD*2));/*st#10*/
            mop(OP_LDWR, 1, &BR[10][2][1],aofs, (0+WDHTDP*(MID+3)+WDHT-WD  )*4, MSK_D0, arow09[CHIP], WD*RMGRP, 0, 0, (Ull)NULL, WD*RMGRP);/* stage#10*/
            exe(OP_FMA, &r0, r6,          EXP_H3210,  BR[10][0][1],EXP_H3210, BR[10][2][1],EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#11*/
            exe(OP_FAD, &r1, r7,          EXP_H3210,  r8,          EXP_H3210, 0,           EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#11*/
            mop(OP_LDWR, 1, &BR[11][0][1],bofs, (0               +WDHT   -1)*4, MSK_D0, brow06[CHIP], WD*(RMGRP+PAD*2), 0, 0, (Ull)NULL, WD*(RMGRP+PAD*2));/*st#11*/
            mop(OP_LDWR, 1, &BR[11][0][0],bofs, (0               +WDHT   +1)*4, MSK_D0, brow06[CHIP], WD*(RMGRP+PAD*2), 0, 0, (Ull)NULL, WD*(RMGRP+PAD*2));/*st#11*/
            mop(OP_LDWR, 1, &BR[11][1][1],bofs, (0               +WDHT     )*4, MSK_D0, brow06[CHIP], WD*(RMGRP+PAD*2), 0, 0, (Ull)NULL, WD*(RMGRP+PAD*2));/*st#11*/
            mop(OP_LDWR, 1, &BR[11][2][1],aofs, (0+WDHTDP*(MID+5)+WDHT   -1)*4, MSK_D0, arow0b[CHIP], WD*RMGRP, 0, 0, (Ull)NULL, WD*RMGRP);/* stage#11*/
            mop(OP_LDWR, 1, &BR[11][2][0],aofs, (0+WDHTDP*(MID+5)+WDHT   +1)*4, MSK_D0, arow0b[CHIP], WD*RMGRP, 0, 0, (Ull)NULL, WD*RMGRP);/* stage#11*/
            mop(OP_LDWR, 1, &BR[11][3][1],aofs, (0+WDHTDP*(MID+4)+WDHT     )*4, MSK_D0, arow0a[CHIP], WD*RMGRP, 0, 0, (Ull)NULL, WD*RMGRP);/* stage#11*/
            exe(OP_FMA, &r2, r0,          EXP_H3210,  BR[11][0][1],EXP_H3210, BR[11][2][1],EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#12*/
            exe(OP_FMA, &r3, r1,          EXP_H3210,  BR[11][0][0],EXP_H3210, BR[11][2][0],EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#12*/
            exe(OP_FML, &r4, BR[11][1][1],EXP_H3210,  BR[11][3][1],EXP_H3210, 0,           EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#12*/
            mop(OP_LDWR, 1, &BR[12][0][1],bofs, (0               +WDHT+WD  )*4, MSK_D0, brow06[CHIP], WD*(RMGRP+PAD*2), 0, 0, (Ull)NULL, WD*(RMGRP+PAD*2));/*st#12*/
            mop(OP_LDWR, 1, &BR[12][2][1],aofs, (0+WDHTDP*(MID+6)+WDHT+WD  )*4, MSK_D0, arow0c[CHIP], WD*RMGRP, 0, 0, (Ull)NULL, WD*RMGRP);/* stage#12*/
            exe(OP_FMA, &r5, r2,          EXP_H3210,  BR[12][0][1],EXP_H3210, BR[12][2][1],EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#13*/
            exe(OP_FAD, &r6, r3,          EXP_H3210,  r4,          EXP_H3210, 0,           EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#13*/
            exe(OP_FAD, &r7, r5,          EXP_H3210,  r6,          EXP_H3210, 0,           EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#14*/
            mop(OP_STWR, 3, &r7,          cofs, (0                         )*4, MSK_D0, crow0[CHIP],  WD*RMGRP, 0, 0, (Ull)NULL, WD*RMGRP);/* stage#14*/
          }
        }
      }
//EMAX5A end
    }
//EMAX5A drain_dirty_lmm
  }
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\epsfile{file=stencil+rmm-grapes-emax6.eps,width=1.00\textwidth}
\caption{Grapes}
\end{figure}

\clearpage

\subsection{Jacobi with stencil}

\begin{figure}[htbp]
\center
\includegraphics[angle=270,origin=b,width=0.75\textwidth]{jacobi.eps}
\caption{Jacobi}
\end{figure}

7点浮動小数点ステンシル計算である．一度のバースト演算により24行分を計算する
（RMGRP=24）．ステンシル計算であるものの，一度に24行分を計算するため，
mapdist=0である．

\begin{screen}
\tiny
\begin{verbatim}
jacobi( float *c, float *b )
     /*C3D[DP][HT][WD]*/
     /*B3D[DP][HT][WD]*/
#undef  NCHIP
#undef  RMGRP
#undef  OMAP
#undef  PAD
#undef  RRANGE
#define NCHIP     1
#define RMGRP     24
#define OMAP      1
#define PAD       1
#define RRANGE   ((HT-PAD*2)/NCHIP/OMAP)
  Ull  CHIP;
  Ull  LOOP1, LOOP0;
  Ull  INIT1, INIT0;
  Ull  AR[64][4];                     /* output of EX     in each unit */
  Ull  BR[64][4][4];                  /* output registers in each unit */
  Ull  r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15;
  Ull  r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31;
  Ull  cc0, cc1, cc2, cc3, ex0, ex1;
  int  x, y, z;
  int  row, col, n;
  Ull  roofs, coofs, aofs, bofs, cofs;
  union {float f; int i;} C1, C2;
  C1.f = 0.2;
  C2.f = 0.3;
  Ull  I1 = C1.i;
  Ull  I2 = C2.i;

#if !defined(EMAX5) && !defined(EMAX6)
  for (z=PAD; z<DP-PAD; z++) {
    for (y=PAD; y<HT-PAD; y++) {
      for (x=PAD; x<WD-PAD; x++) {
        *(c+z*WDHT+y*WD+x) = C2.f *(*(b+(z-1)*WDHT+(y  )*WD+x  )
                                  + *(b+(z  )*WDHT+(y-1)*WD+x  )
                                  + *(b+(z  )*WDHT+(y  )*WD+x-1)
                                  + *(b+(z  )*WDHT+(y  )*WD+x+1)
                                  + *(b+(z  )*WDHT+(y+1)*WD+x  )
                                  + *(b+(z+1)*WDHT+(y  )*WD+x  ))
                           + C1.f * *(b+(z  )*WDHT+(y  )*WD+x  );
      }
    }
  }
#endif
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
  for (z=PAD; z<DP-PAD; z++) {
    for (y=0; y<RRANGE; y+=RMGRP) {
      Ull  btop[NCHIP], ctop[NCHIP];
      Ull  brow00[NCHIP], brow01[NCHIP], brow02[NCHIP], brow03[NCHIP], brow04[NCHIP];
      Ull  crow0[NCHIP];
      for (CHIP=0; CHIP<NCHIP; CHIP++) { /* output channels are parallelized by multi-chip (OC/#chip) */
        btop[CHIP]   = b               +(z  )*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;
        ctop[CHIP]   = c               +(z  )*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;
        brow00[CHIP] = b               +(z-1)*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;
        brow01[CHIP] = b               +(z+1)*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;
        brow02[CHIP] = b               +(z  )*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y-1)*WD;
        brow03[CHIP] = b               +(z  )*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;/* not used for RMGRP>1 */
        brow04[CHIP] = b               +(z  )*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y+1)*WD;/* not used for RMGRP>1 */
        crow0[CHIP]  = c               +(z  )*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;
      }
//EMAX5A begin jacobi mapdist=0 /* 7 PAD>0の場合,PLOADとLOAD領域が一部重複.load中のLMMにもPLOADを取り込むために渋滞が発生する */
      for (CHIP=0; CHIP<NCHIP; CHIP++) { /* output channels are parallelized by multi-chip (OC/#chip) */
   /*2*/for (INIT1=1,LOOP1=RMGRP,roofs=0-WD*4; LOOP1--; INIT1=0) {      /* stage#0 *//* mapped to FOR() on BR[63][1][0] */
     /*1*/for (INIT0=1,LOOP0=WD-PAD*2,coofs=(PAD-1)*4; LOOP0--; INIT0=0) {          /* stage#0 *//* mapped to FOR() on BR[63][0][0] */
            exe(OP_ADD,  &coofs, INIT0?coofs:coofs, EXP_H3210, 4, EXP_H3210, 0LL, EXP_H3210, OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL); /* stage#0 */
            exe(OP_ADD,  &roofs, roofs,  EXP_H3210, INIT0?WD*4:0, EXP_H3210, 0LL, EXP_H3210, OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL); /* stage#0 */
            exe(OP_ADD3, &bofs,  btop[CHIP], EXP_H3210, roofs, EXP_H3210,  coofs, EXP_H3210, OP_AND, 0x000000ffffffffffLL, OP_NOP, 0LL); /* stage#1 */
            exe(OP_ADD3, &cofs,  ctop[CHIP], EXP_H3210, roofs, EXP_H3210,  coofs, EXP_H3210, OP_AND, 0x000000ffffffffffLL, OP_NOP, 0LL); /* stage#1 */
            /*map0*/
            mop(OP_LDWR, 1, &BR[2][0][1], bofs, (0        -WDHT     )*4, MSK_D0, brow00[CHIP], WD*RMGRP, 0, 0, NULL, WD*RMGRP);      /* stage#2 */
            mop(OP_LDWR, 1, &BR[2][2][1], bofs, (0        +WDHT     )*4, MSK_D0, brow01[CHIP], WD*RMGRP, 0, 0, CHIP]*/NULL, WD*RMGRP); /* stage#2 */
            exe(OP_FAD, &r0, BR[2][0][1],EXP_H3210,  BR[2][2][1],EXP_H3210, 0,           EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#3 */
            mop(OP_LDWR, 1, &BR[3][0][1], bofs, (0             -WD  )*4, MSK_D0, brow02[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2)); /* stage#3 */
            exe(OP_FAD, &r1, r0,         EXP_H3210,  BR[3][0][1],EXP_H3210, 0,           EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#3 */
            mop(OP_LDWR, 1, &BR[4][0][1], bofs, (0                -1)*4, MSK_D0, brow02[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2)); /* stage#4 */
            mop(OP_LDWR, 1, &BR[4][1][1], bofs, (0                  )*4, MSK_D0, brow02[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2)); /* stage#4 */
            mop(OP_LDWR, 1, &BR[4][2][1], bofs, (0                +1)*4, MSK_D0, brow02[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2)); /* stage#4 */
            exe(OP_FAD, &r2, r1,         EXP_H3210,  BR[4][0][1],EXP_H3210, 0,           EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#5 */
            exe(OP_FML, &r3, I1,         EXP_H3210,  BR[4][1][1],EXP_H3210, 0,           EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#5 */
            mop(OP_LDWR, 1, &BR[5][0][1], bofs, (0             +WD  )*4, MSK_D0, brow02[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2)); /* stage#5 */
            exe(OP_FAD, &r4, r2,         EXP_H3210,  BR[5][0][1],EXP_H3210, 0,           EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#6 */
            exe(OP_FAD, &r5, r4,         EXP_H3210,  BR[4][2][1],EXP_H3210, 0,           EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#7 */
            exe(OP_FMA, &r6, r3,         EXP_H3210,  r5,         EXP_H3210, I2,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#8 */
            mop(OP_STWR, 3, &r6,          cofs, (0                  )*4, MSK_D0, crow0[CHIP],  WD*RMGRP, 0, 0, /NULL, WD*RMGRP);     /* stage#8 */
          }
        }
      }
//EMAX5A end
    }
//EMAX5A drain_dirty_lmm
  }
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\epsfile{file=stencil+rmm-jacobi-emax6.eps,width=1.00\textwidth}
\caption{Jacobi}
\end{figure}

\clearpage

\subsection{Fd6 with stencil}

\begin{figure}[htbp]
\center
\includegraphics[angle=270,origin=b,width=0.60\textwidth]{fd6.eps}
\caption{Fd6}
\end{figure}

次数3の19点浮動小数点ステンシル計算である．一度のバースト演算により24行分を
計算する（RMGRP=24）．ステンシル計算であるものの，一度に24行分を計算するため，
mapdist=0である．

\begin{screen}
\tiny
\begin{verbatim}
fd6( float *c, float *b )
     /*C3D[DP][HT][WD]*/
     /*B3D[DP][HT][WD]*/
#define NCHIP     1
#define RMGRP     24
#define OMAP      1
#define PAD       3
#define RRANGE   ((HT-PAD*2)/NCHIP/OMAP)
  Ull  CHIP;
  Ull  LOOP1, LOOP0;
  Ull  INIT1, INIT0;
  Ull  AR[64][4];                     /* output of EX     in each unit */
  Ull  BR[64][4][4];                  /* output registers in each unit */
  Ull  r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15;
  Ull  r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31;
  Ull  cc0, cc1, cc2, cc3, ex0, ex1;
  int  x, y, z;
  int  row, col, n;
  Ull  roofs, coofs, aofs, bofs, cofs;
  union {float f; int i;} C1, C2, C3, C4;
  C1.f = 0.1;
  C2.f = 0.2;
  C3.f = 0.4;
  C4.f = 0.8;
  Ull  I1 = C1.i;
  Ull  I2 = C2.i;
  Ull  I3 = C3.i;
  Ull  I4 = C4.i;

#if !defined(EMAX5) && !defined(EMAX6)
  for (z=PAD; z<DP-PAD; z++) {
    for (y=PAD; y<HT-PAD; y++) {
      for (x=PAD; x<WD-PAD; x++) {
        *(c+z*WDHT+y*WD+x) = C4.f *(*(b+((z-3)*WDHT)+(y  )*WD+x  )
                                  + *(b+((z  )*WDHT)+(y-3)*WD+x  )
                                  + *(b+((z  )*WDHT)+(y  )*WD+x-3)
                                  + *(b+((z  )*WDHT)+(y  )*WD+x+3)
                                  + *(b+((z  )*WDHT)+(y+3)*WD+x  )
                                  + *(b+((z+3)*WDHT)+(y  )*WD+x  ))
                           + C3.f *(*(b+((z-2)*WDHT)+(y  )*WD+x  )
                                  + *(b+((z  )*WDHT)+(y-2)*WD+x  )
                                  + *(b+((z  )*WDHT)+(y  )*WD+x-2)
                                  + *(b+((z  )*WDHT)+(y  )*WD+x+2)
                                  + *(b+((z  )*WDHT)+(y+2)*WD+x  )
                                  + *(b+((z+2)*WDHT)+(y  )*WD+x  ))
                           + C2.f *(*(b+((z-1)*WDHT)+(y  )*WD+x  )
                                  + *(b+((z  )*WDHT)+(y-1)*WD+x  )
                                  + *(b+((z  )*WDHT)+(y  )*WD+x-1)
                                  + *(b+((z  )*WDHT)+(y  )*WD+x+1)
                                  + *(b+((z  )*WDHT)+(y+1)*WD+x  )
                                  + *(b+((z+1)*WDHT)+(y  )*WD+x  ))
                           + C1.f * *(b+((z  )*WDHT)+(y  )*WD+x  );
      }
    }
  }
#endif
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
  for (z=PAD; z<DP-PAD; z++) {
    for (y=0; y<RRANGE; y+=RMGRP) {
      Ull  btop[NCHIP], ctop[NCHIP];
      Ull  brow00[NCHIP], brow01[NCHIP], brow02[NCHIP], brow03[NCHIP], brow04[NCHIP], brow05[NCHIP], brow06[NCHIP];
      Ull  brow07[NCHIP], brow08[NCHIP], brow09[NCHIP], brow0a[NCHIP], brow0b[NCHIP], brow0c[NCHIP];
      Ull  crow0[NCHIP];
      for (CHIP=0; CHIP<NCHIP; CHIP++) { /* output channels are parallelized by multi-chip (OC/#chip) */
        btop[CHIP]   = b               +(z  )*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;
        ctop[CHIP]   = c               +(z  )*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;
        brow00[CHIP] = b               +(z-3)*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;
        brow01[CHIP] = b               +(z-2)*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;
        brow02[CHIP] = b               +(z-1)*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;
        brow03[CHIP] = b               +(z+1)*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;
        brow04[CHIP] = b               +(z+2)*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;
        brow05[CHIP] = b               +(z+3)*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;
        brow06[CHIP] = b               +(z  )*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y-3)*WD;
        brow07[CHIP] = b               +(z  )*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y-2)*WD;/* not used for RMGRP>1 */
        brow08[CHIP] = b               +(z  )*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y-1)*WD;/* not used for RMGRP>1 */
        brow09[CHIP] = b               +(z  )*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;/* not used for RMGRP>1 */
        brow0a[CHIP] = b               +(z  )*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y+1)*WD;/* not used for RMGRP>1 */
        brow0b[CHIP] = b               +(z  )*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y+2)*WD;/* not used for RMGRP>1 */
        brow0c[CHIP] = b               +(z  )*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y+3)*WD;/* not used for RMGRP>1 */
        crow0[CHIP]  = c               +(z  )*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;
      }
//EMAX5A begin fd6 mapdist=0 /* 11 */
      for (CHIP=0; CHIP<NCHIP; CHIP++) { /* output channels are parallelized by multi-chip (OC/#chip) */
   /*2*/for (INIT1=1,LOOP1=RMGRP,roofs=0-WD*4; LOOP1--; INIT1=0) {      /* stage#0 *//* mapped to FOR() on BR[63][1][0] */
     /*1*/for (INIT0=1,LOOP0=WD-PAD*2,coofs=(PAD-1)*4; LOOP0--; INIT0=0) {          /* stage#0 *//* mapped to FOR() on BR[63][0][0] */
            exe(OP_ADD,  &coofs, INIT0?coofs:coofs, EXP_H3210, 4, EXP_H3210, 0LL, EXP_H3210, OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL); /* stage#0 */
            exe(OP_ADD,  &roofs, roofs,  EXP_H3210, INIT0?WD*4:0, EXP_H3210, 0LL, EXP_H3210, OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL); /* stage#0 */
            exe(OP_ADD3, &bofs,  btop[CHIP], EXP_H3210, roofs, EXP_H3210,  coofs, EXP_H3210, OP_AND, 0x000000ffffffffffLL, OP_NOP, 0LL); /* stage#1 */
            exe(OP_ADD3, &cofs,  ctop[CHIP], EXP_H3210, roofs, EXP_H3210,  coofs, EXP_H3210, OP_AND, 0x000000ffffffffffLL, OP_NOP, 0LL); /* stage#1 */
            /*map0*/
            mop(OP_LDWR, 1, &BR[2][0][1], bofs, (0        -WDHT*3   )*4, MSK_D0, brow00[CHIP], WD*RMGRP, 0, 0, NULL, WD*RMGRP); /* stage#2 */
            mop(OP_LDWR, 1, &BR[2][2][1], bofs, (0        +WDHT*3   )*4, MSK_D0, brow05[CHIP], WD*RMGRP, 0, 0, NULL, WD*RMGRP); /* stage#2 */
            exe(OP_FAD, &r3, BR[2][0][1],EXP_H3210,  BR[2][2][1], EXP_H3210, 0,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#3 */
            mop(OP_LDWR, 1, &BR[3][0][1], bofs, (0        -WDHT*2   )*4, MSK_D0, brow01[CHIP], WD*RMGRP, 0, 0, NULL, WD*RMGRP); /* stage#3 */
            mop(OP_LDWR, 1, &BR[3][2][1], bofs, (0        +WDHT*2   )*4, MSK_D0, brow04[CHIP], WD*RMGRP, 0, 0, NULL, WD*RMGRP); /* stage#3 */
            exe(OP_FAD, &r2, BR[3][0][1],EXP_H3210,  BR[3][2][1], EXP_H3210, 0,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#4 */
            mop(OP_LDWR, 1, &BR[4][0][1], bofs, (0        -WDHT*1   )*4, MSK_D0, brow02[CHIP], WD*RMGRP, 0, 0, NULL, WD*RMGRP); /* stage#4 */
            mop(OP_LDWR, 1, &BR[4][2][1], bofs, (0        +WDHT*1   )*4, MSK_D0, brow03[CHIP], WD*RMGRP, 0, 0, NULL, WD*RMGRP); /* stage#4 */
            exe(OP_FAD, &r1, BR[4][0][1],EXP_H3210,  BR[4][2][1], EXP_H3210, 0,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#5 */
            mop(OP_LDWR, 1, &BR[5][0][1], bofs, (0             -WD*3)*4, MSK_D0, brow06[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2)); /* stage#5 */
            mop(OP_LDWR, 1, &BR[5][0][0], bofs, (0             +WD*3)*4, MSK_D0, brow06[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2)); /* stage#5 */
            mop(OP_LDWR, 1, &BR[5][1][1], bofs, (0                -3)*4, MSK_D0, brow06[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2)); /* stage#5 */
            mop(OP_LDWR, 1, &BR[5][1][0], bofs, (0                +3)*4, MSK_D0, brow06[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2)); /* stage#5 */
            exe(OP_FAD, &r13,BR[5][0][1],EXP_H3210,  BR[5][0][0], EXP_H3210, 0,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#6 */
            exe(OP_FAD, &r23,BR[5][1][1],EXP_H3210,  BR[5][1][0], EXP_H3210, 0,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#6 */
            mop(OP_LDWR, 1, &BR[6][0][1], bofs, (0             +WD*2)*4, MSK_D0, brow06[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2)); /* stage#6 */
            mop(OP_LDWR, 1, &BR[6][0][0], bofs, (0             -WD*2)*4, MSK_D0, brow06[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2)); /* stage#6 */
            mop(OP_LDWR, 1, &BR[6][1][1], bofs, (0                -2)*4, MSK_D0, brow06[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2)); /* stage#6 */
            mop(OP_LDWR, 1, &BR[6][1][0], bofs, (0                +2)*4, MSK_D0, brow06[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2)); /* stage#6 */
            exe(OP_FAD, &r12,BR[6][0][1],EXP_H3210,  BR[6][0][0], EXP_H3210, 0,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#7 */
            exe(OP_FAD, &r22,BR[6][1][1],EXP_H3210,  BR[6][1][0], EXP_H3210, 0,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#7 */
            exe(OP_FAD, &r23,r13,        EXP_H3210,  r23,         EXP_H3210, 0,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#7 */
            mop(OP_LDWR, 1, &BR[7][0][1], bofs, (0             +WD*1)*4, MSK_D0, brow06[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2)); /* stage#7 */
            mop(OP_LDWR, 1, &BR[7][0][0], bofs, (0             -WD*1)*4, MSK_D0, brow06[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2)); /* stage#7 */
            mop(OP_LDWR, 1, &BR[7][1][1], bofs, (0                -1)*4, MSK_D0, brow06[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2)); /* stage#7 */
            mop(OP_LDWR, 1, &BR[7][1][0], bofs, (0                +1)*4, MSK_D0, brow06[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2)); /* stage#7 */
            exe(OP_FAD, &r11,BR[7][0][1],EXP_H3210,  BR[7][0][0], EXP_H3210, 0,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#8 */
            exe(OP_FAD, &r21,BR[7][1][1],EXP_H3210,  BR[7][1][0], EXP_H3210, 0,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#8 */
            exe(OP_FAD, &r22,r12,        EXP_H3210,  r22,         EXP_H3210, 0,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#8 */
            exe(OP_FAD, &r3, r23,        EXP_H3210,  r3,          EXP_H3210, 0,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#8 */
            mop(OP_LDWR, 1, &BR[8][0][1], bofs, (0                  )*4, MSK_D0, brow06[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2)); /* stage#8 */
            exe(OP_FML, &r10,BR[8][0][1],EXP_H3210,  I1,          EXP_H3210, 0,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#9  */
            exe(OP_FAD, &r21,r11,        EXP_H3210,  r21,         EXP_H3210, 0,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#9 */
            exe(OP_FAD, &r2, r22,        EXP_H3210,  r2,          EXP_H3210, 0,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#9 */
            exe(OP_FMA, &r13,r10,        EXP_H3210,  r3,          EXP_H3210, I4,         EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#10 */
            exe(OP_FAD, &r1, r21,        EXP_H3210,  r1,          EXP_H3210, 0,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#10 */
            exe(OP_FMA, &r12,r13,        EXP_H3210,  r2,          EXP_H3210, I3,         EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#11 */
            exe(OP_FMA, &r11,r12,        EXP_H3210,  r1,          EXP_H3210, I2,         EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#12 */
            mop(OP_STWR, 3, &r11,        cofs, (0                   )*4, MSK_D0, crow0[CHIP],  WD*RMGRP, 0, 0, NULL, WD*RMGRP); /* stage#12 */
          }
        }
      }
//EMAX5A end
    }
//EMAX5A drain_dirty_lmm
  }
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\epsfile{file=stencil+rmm-fd6-emax6.eps,width=1.00\textwidth}
\caption{Fd6}
\end{figure}

\clearpage

\subsection{Resid with stencil}

\begin{figure}[htbp]
\center
\includegraphics[angle=270,origin=b,width=0.65\textwidth]{resid.eps}
\caption{Resid}
\end{figure}

27点浮動小数点ステンシル計算である．一度のバースト演算により24行分を計算する
（RMGRP=24）．ステンシル計算であるものの，一度に24行分を計算するため，
mapdist=0である．

\begin{screen}
\tiny
\begin{verbatim}
resid( float *d, float *b, float *c )
     /*D3D[DP][HT][WD]*/
     /*B3D[DP][HT][WD]*/
     /*C3D[DP][HT][WD]*/
#define NCHIP     1
#define RMGRP     24
#define OMAP      1
#define PAD       1
#define RRANGE   ((HT-PAD*2)/NCHIP/OMAP)
  Ull  CHIP;
  Ull  LOOP1, LOOP0;
  Ull  INIT1, INIT0;
  Ull  AR[64][4];                     /* output of EX     in each unit */
  Ull  BR[64][4][4];                  /* output registers in each unit */
  Ull  r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15;
  Ull  r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31;
  Ull  cc0, cc1, cc2, cc3, ex0, ex1;
  int  x, y, z;
  int  row, col, n;
  Ull  roofs, coofs, bofs, cofs, dofs;
  union {float f; int i;} A0, A1, A2, A3;
  A0.f = -0.1;  A1.f = -0.2;  A2.f = -0.3;  A3.f = -0.4;
  Ull  I0 = A0.i;  Ull  I1 = A1.i;  Ull  I2 = A2.i;  Ull  I3 = A3.i;

#if !defined(EMAX5) && !defined(EMAX6)
  for (z=PAD; z<DP-PAD; z++) {
    for (y=PAD; y<HT-PAD; y++) {
      for (x=PAD; x<WD-PAD; x++) {
        *(d+z*WDHT+y*WD+x) = *(c+z*WDHT+y*WD+x)
                    + A0.f * *(b+(z  )*WDHT+(y  )*WD+x  )
                    + A1.f *(*(b+(z-1)*WDHT+(y  )*WD+x  )
                           + *(b+(z  )*WDHT+(y-1)*WD+x  )
                           + *(b+(z  )*WDHT+(y  )*WD+x-1)
                           + *(b+(z  )*WDHT+(y  )*WD+x+1)
                           + *(b+(z  )*WDHT+(y+1)*WD+x  )
                           + *(b+(z+1)*WDHT+(y  )*WD+x  ))
                    + A2.f *(*(b+(z-1)*WDHT+(y-1)*WD+x  )
                           + *(b+(z-1)*WDHT+(y  )*WD+x-1)
                           + *(b+(z-1)*WDHT+(y  )*WD+x+1)
                           + *(b+(z-1)*WDHT+(y+1)*WD+x  )
                           + *(b+(z  )*WDHT+(y-1)*WD+x-1)
                           + *(b+(z  )*WDHT+(y-1)*WD+x+1)
                           + *(b+(z  )*WDHT+(y+1)*WD+x-1)
                           + *(b+(z  )*WDHT+(y+1)*WD+x+1)
                           + *(b+(z+1)*WDHT+(y-1)*WD+x  )
                           + *(b+(z+1)*WDHT+(y  )*WD+x-1)
                           + *(b+(z+1)*WDHT+(y  )*WD+x+1)
                           + *(b+(z+1)*WDHT+(y+1)*WD+x  ))
                    + A3.f *(*(b+(z-1)*WDHT+(y-1)*WD+x-1)
                           + *(b+(z-1)*WDHT+(y-1)*WD+x+1)
                           + *(b+(z-1)*WDHT+(y+1)*WD+x-1)
                           + *(b+(z-1)*WDHT+(y+1)*WD+x+1)
                           + *(b+(z+1)*WDHT+(y-1)*WD+x-1)
                           + *(b+(z+1)*WDHT+(y-1)*WD+x+1)
                           + *(b+(z+1)*WDHT+(y+1)*WD+x-1)
                           + *(b+(z+1)*WDHT+(y+1)*WD+x+1));
  } } }
#endif
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
  for (z=PAD; z<DP-PAD; z++) {
    for (y=0; y<RRANGE; y+=RMGRP) {
      Ull  btop[NCHIP], ctop[NCHIP], dtop[NCHIP];
      Ull  brow00[NCHIP], brow01[NCHIP], brow02[NCHIP], brow03[NCHIP], brow04[NCHIP], brow05[NCHIP], brow06[NCHIP], brow07[NCHIP], brow08[NCHIP];
      Ull  crow0[NCHIP];
      Ull  drow0[NCHIP];
      for (CHIP=0; CHIP<NCHIP; CHIP++) { /* output channels are parallelized by multi-chip (OC/#chip) */
        btop[CHIP]   = b               +(z  )*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;
        ctop[CHIP]   = c               +(z  )*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;
        dtop[CHIP]   = d               +(z  )*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;
        brow00[CHIP] = b               +(z-1)*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y-1)*WD;
        brow01[CHIP] = b               +(z-1)*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;/* not used for RMGRP>1 */
        brow02[CHIP] = b               +(z-1)*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y+1)*WD;/* not used for RMGRP>1 */
        brow03[CHIP] = b               +(z  )*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y-1)*WD;
        brow04[CHIP] = b               +(z  )*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;/* not used for RMGRP>1 */
        brow05[CHIP] = b               +(z  )*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y+1)*WD;/* not used for RMGRP>1 */
        brow06[CHIP] = b               +(z+1)*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y-1)*WD;
        brow07[CHIP] = b               +(z+1)*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;/* not used for RMGRP>1 */
        brow08[CHIP] = b               +(z+1)*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y+1)*WD;/* not used for RMGRP>1 */
        crow0[CHIP]  = c               +(z  )*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;
        drow0[CHIP]  = d               +(z  )*WDHT+(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;
      }
//EMAX5A begin resid mapdist=0 /* 12 */
      for (CHIP=0; CHIP<NCHIP; CHIP++) { /* output channels are parallelized by multi-chip (OC/#chip) */
   /*2*/for (INIT1=1,LOOP1=RMGRP,roofs=0-WD*4; LOOP1--; INIT1=0) {      /* stage#0 *//* mapped to FOR() on BR[63][1][0] */
     /*1*/for (INIT0=1,LOOP0=WD-PAD*2,coofs=(PAD-1)*4; LOOP0--; INIT0=0) {          /* stage#0 *//* mapped to FOR() on BR[63][0][0] */
            exe(OP_ADD,  &coofs, INIT0?coofs:coofs, EXP_H3210, 4, EXP_H3210, 0LL, EXP_H3210, OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL); /* stage#0 */
            exe(OP_ADD,  &roofs, roofs,  EXP_H3210, INIT0?WD*4:0, EXP_H3210, 0LL, EXP_H3210, OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL); /* stage#0 */
            exe(OP_ADD3, &bofs,  btop[CHIP], EXP_H3210, roofs, EXP_H3210,  coofs, EXP_H3210, OP_AND, 0x000000ffffffffffLL, OP_NOP, 0LL); /* stage#1 */
            exe(OP_ADD3, &cofs,  ctop[CHIP], EXP_H3210, roofs, EXP_H3210,  coofs, EXP_H3210, OP_AND, 0x000000ffffffffffLL, OP_NOP, 0LL); /* stage#1 */
            exe(OP_ADD3, &dofs,  dtop[CHIP], EXP_H3210, roofs, EXP_H3210,  coofs, EXP_H3210, OP_AND, 0x000000ffffffffffLL, OP_NOP, 0LL); /* stage#1 */
            /*map0*/
            mop(OP_LDWR, 1, &BR[2][0][1], bofs, (0       -WDHT-WD-1)*4, MSK_D0, brow00[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2));/* stage#2 */
            mop(OP_LDWR, 1, &BR[2][0][0], bofs, (0       -WDHT-WD  )*4, MSK_D0, brow00[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2));/* stage#2 */
            mop(OP_LDWR, 1, &BR[2][1][1], bofs, (0       -WDHT-WD+1)*4, MSK_D0, brow00[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2));/* stage#2 */
            exe(OP_FML, &r0, BR[2][0][1], EXP_H3210,  I3,          EXP_H3210,  0,           EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#3 */
            exe(OP_FML, &r1, BR[2][0][0], EXP_H3210,  I2,          EXP_H3210,  0,           EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#3 */
            exe(OP_FML, &r2, BR[2][1][1], EXP_H3210,  I3,          EXP_H3210,  0,           EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#3 */
            mop(OP_LDWR, 1, &BR[3][0][1], bofs, (0       -WDHT   -1)*4, MSK_D0, brow00[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2));/* stage#3 */
            mop(OP_LDWR, 1, &BR[3][0][0], bofs, (0       -WDHT     )*4, MSK_D0, brow00[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2));/* stage#3 */
            mop(OP_LDWR, 1, &BR[3][1][1], bofs, (0       -WDHT   +1)*4, MSK_D0, brow00[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2));/* stage#3 */
            exe(OP_FMA, &r3, r0,          EXP_H3210,  BR[3][0][1], EXP_H3210,  I2,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#4 */
            exe(OP_FMA, &r4, r1,          EXP_H3210,  BR[3][0][0], EXP_H3210,  I1,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#4 */
            exe(OP_FMA, &r5, r2,          EXP_H3210,  BR[3][1][1], EXP_H3210,  I2,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#4 */
            mop(OP_LDWR, 1, &BR[4][0][1], bofs, (0       -WDHT+WD-1)*4, MSK_D0, brow00[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2));/* stage#4 */
            mop(OP_LDWR, 1, &BR[4][0][0], bofs, (0       -WDHT+WD  )*4, MSK_D0, brow00[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2));/* stage#4 */
            mop(OP_LDWR, 1, &BR[4][1][1], bofs, (0       -WDHT+WD+1)*4, MSK_D0, brow00[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2));/* stage#4 */
            exe(OP_FMA, &r6, r3,          EXP_H3210,  BR[4][0][1], EXP_H3210,  I3,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#5 */
            exe(OP_FMA, &r7, r4,          EXP_H3210,  BR[4][0][0], EXP_H3210,  I2,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#5 */
            exe(OP_FMA, &r8, r5,          EXP_H3210,  BR[4][1][1], EXP_H3210,  I3,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#5 */

            mop(OP_LDWR, 1, &BR[5][0][1], bofs, (0            -WD-1)*4, MSK_D0, brow03[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2));/* stage#5 */
            mop(OP_LDWR, 1, &BR[5][0][0], bofs, (0            -WD  )*4, MSK_D0, brow03[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2));/* stage#5 */
            mop(OP_LDWR, 1, &BR[5][1][1], bofs, (0            -WD+1)*4, MSK_D0, brow03[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2));/* stage#5 */
            exe(OP_FMA, &r0, r6,          EXP_H3210,  BR[5][0][1], EXP_H3210,  I2,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#6 */
            exe(OP_FMA, &r1, r7,          EXP_H3210,  BR[5][0][0], EXP_H3210,  I1,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#6 */
            exe(OP_FMA, &r2, r8,          EXP_H3210,  BR[5][1][1], EXP_H3210,  I2,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#6 */
            mop(OP_LDWR, 1, &BR[6][0][1], bofs, (0               -1)*4, MSK_D0, brow03[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2));/* stage#6 */
            mop(OP_LDWR, 1, &BR[6][0][0], bofs, (0                 )*4, MSK_D0, brow03[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2));/* stage#6 */
            mop(OP_LDWR, 1, &BR[6][1][1], bofs, (0               +1)*4, MSK_D0, brow03[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2));/* stage#6 */
            exe(OP_FMA, &r3, r0,          EXP_H3210,  BR[6][0][1], EXP_H3210,  I1,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#7 */
            exe(OP_FMA, &r4, r1,          EXP_H3210,  BR[6][0][0], EXP_H3210,  I0,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#7 */
            exe(OP_FMA, &r5, r2,          EXP_H3210,  BR[6][1][1], EXP_H3210,  I1,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#7 */
            mop(OP_LDWR, 1, &BR[7][0][1], bofs, (0            +WD-1)*4, MSK_D0, brow03[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2));/* stage#7 */
            mop(OP_LDWR, 1, &BR[7][0][0], bofs, (0            +WD  )*4, MSK_D0, brow03[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2));/* stage#7 */
            mop(OP_LDWR, 1, &BR[7][1][1], bofs, (0            +WD+1)*4, MSK_D0, brow03[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2));/* stage#7 */
            exe(OP_FMA, &r6, r3,          EXP_H3210,  BR[7][0][1], EXP_H3210,  I2,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#8 */
            exe(OP_FMA, &r7, r4,          EXP_H3210,  BR[7][0][0], EXP_H3210,  I1,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#8 */
            exe(OP_FMA, &r8, r5,          EXP_H3210,  BR[7][1][1], EXP_H3210,  I2,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#8 */

            mop(OP_LDWR, 1, &BR[8][0][1], bofs, (0       +WDHT-WD-1)*4, MSK_D0, brow06[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2));/* stage#8 */
            mop(OP_LDWR, 1, &BR[8][0][0], bofs, (0       +WDHT-WD  )*4, MSK_D0, brow06[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2));/* stage#8 */
            mop(OP_LDWR, 1, &BR[8][1][1], bofs, (0       +WDHT-WD+1)*4, MSK_D0, brow06[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2));/* stage#8 */
            exe(OP_FMA, &r0, r6,          EXP_H3210,  BR[8][0][1], EXP_H3210,  I3,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#9 */
            exe(OP_FMA, &r1, r7,          EXP_H3210,  BR[8][0][0], EXP_H3210,  I2,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#9 */
            exe(OP_FMA, &r2, r8,          EXP_H3210,  BR[8][1][1], EXP_H3210,  I3,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#9 */
            mop(OP_LDWR, 1, &BR[9][0][1], bofs, (0       +WDHT   -1)*4, MSK_D0, brow06[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2));/* stage#9 */
            mop(OP_LDWR, 1, &BR[9][0][0], bofs, (0       +WDHT     )*4, MSK_D0, brow06[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2));/* stage#9 */
            mop(OP_LDWR, 1, &BR[9][1][1], bofs, (0       +WDHT   +1)*4, MSK_D0, brow06[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2));/* stage#9 */
            exe(OP_FMA, &r3, r0,          EXP_H3210,  BR[9][0][1], EXP_H3210,  I2,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#10*/
            exe(OP_FMA, &r4, r1,          EXP_H3210,  BR[9][0][0], EXP_H3210,  I1,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#10*/
            exe(OP_FMA, &r5, r2,          EXP_H3210,  BR[9][1][1], EXP_H3210,  I2,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#10*/
            mop(OP_LDWR, 1, &BR[10][0][1],bofs, (0       +WDHT+WD-1)*4, MSK_D0, brow06[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2));/* stage#10*/
            mop(OP_LDWR, 1, &BR[10][0][0],bofs, (0       +WDHT+WD  )*4, MSK_D0, brow06[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2));/* stage#10*/
            mop(OP_LDWR, 1, &BR[10][1][1],bofs, (0       +WDHT+WD+1)*4, MSK_D0, brow06[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2));/* stage#10*/
            exe(OP_FMA, &r6, r3,          EXP_H3210,  BR[10][0][1],EXP_H3210,  I3,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#11*/
            exe(OP_FMA, &r7, r4,          EXP_H3210,  BR[10][0][0],EXP_H3210,  I2,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#11*/
            exe(OP_FMA, &r8, r5,          EXP_H3210,  BR[10][1][1],EXP_H3210,  I3,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#11*/
            mop(OP_LDWR, 1, &BR[11][0][1],cofs, (0                 )*4, MSK_D0, crow0[CHIP],  WD*RMGRP, 0, 0, NULL, WD*RMGRP);     /* stage#11*/
            exe(OP_FAD, &r1, r6,          EXP_H3210,  BR[11][0][1],EXP_H3210,  0,           EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#12*/
            exe(OP_FAD, &r2, r7,          EXP_H3210,  r8,          EXP_H3210,  0,           EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#12*/
            exe(OP_FAD, &r0, r1,          EXP_H3210,  r2,          EXP_H3210,  0,           EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#13*/
            mop(OP_STWR, 3, &r0,          dofs, (0                 )*4, MSK_D0, drow0[CHIP],  WD*RMGRP, 0, 0, NULL, WD*RMGRP);     /* stage#13*/
          }
        }
      }
//EMAX5A end
    }
//EMAX5A drain_dirty_lmm
  }
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\epsfile{file=stencil+rmm-resid-emax6.eps,width=1.00\textwidth}
\caption{Resid}
\end{figure}

\clearpage

\subsection{Wave2d with stencil}

\begin{figure}[htbp]
\center
\includegraphics[angle=270,origin=b,width=0.60\textwidth]{wave2d.eps}
\caption{Wave2d}
\end{figure}

5点浮動小数点ステンシル計算である．一度のバースト演算により24行分を計算する
（RMGRP=24）．ステンシル計算であるものの，一度に24行分を計算するため，
mapdist=0である．なお，未使用stageを使用したPLOADにより性能向上が可能である．
ただし，PAD>1の場合，LOAD対象LMMとPLOAD対象LMMの領域が一部重複するため，
PLOAD向けAXIトランザクションがLOAD対象LMMにもヒットする．loadサイクルにおい
てAXIが待たされ，AXIが渋滞することがある．

\begin{screen}
\tiny
\begin{verbatim}
wave2d( float *z2, float *z0, float *z1 )
     /*WZ2[HT][WD]*/
     /*WZ0[HT][WD]*/
     /*WZ1[HT][WD]*/
#define NCHIP     1
#define RMGRP     24
#define OMAP      1
#define PAD       1
#define RRANGE   ((HT-PAD*2)/NCHIP/OMAP)
  Ull  CHIP;
  Ull  LOOP1, LOOP0;
  Ull  INIT1, INIT0;
  Ull  AR[64][4];                     /* output of EX     in each unit */
  Ull  BR[64][4][4];                  /* output registers in each unit */
  Ull  r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15;
  Ull  r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31;
  Ull  cc0, cc1, cc2, cc3, ex0, ex1;
  int  x, y, z;
  int  row, col, n;
  Ull  roofs, coofs, z0ofs, z1ofs, z2ofs;
  union {float f; int i;} C1, C2, C3, C4;
  C1.f =  2.00;
  C2.f = -1.00;
  C3.f =  0.25;
  C4.f = -4.00;
  Ull  I1 = C1.i;
  Ull  I2 = C2.i;
  Ull  I3 = C3.i;
  Ull  I4 = C4.i;

#if !defined(EMAX5) && !defined(EMAX6)
  for (y=PAD; y<HT-PAD; y++) {
    for (x=PAD; x<WD-PAD; x++) {
      *(z2+y*WD+x) =  C1.f * *(z1+y*WD+x)
                   +  C2.f * *(z0+y*WD+x)
                   +  C3.f *(*(z1+(y+1)*WD+x  )
                           + *(z1+(y-1)*WD+x  )
                           + *(z1+(y  )*WD+x-1)
                           + *(z1+(y  )*WD+x+1) + C4.f * *(z1+y*WD+x));
    }
  }
#endif
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
  for (y=0; y<RRANGE; y+=RMGRP) {
    Ull  z0top[NCHIP], z1top[NCHIP], z2top[NCHIP];
    Ull  z0row0[NCHIP];
    Ull  z1row00[NCHIP], z1row01[NCHIP], z1row02[NCHIP];
    Ull  z2row0[NCHIP];
    for (CHIP=0; CHIP<NCHIP; CHIP++) { /* output channels are parallelized by multi-chip (OC/#chip) */
      z0top[CHIP]   = z0              +(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;
      z1top[CHIP]   = z1              +(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;
      z2top[CHIP]   = z2              +(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;
      z0row0[CHIP]  = z0              +(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;
      z1row00[CHIP] = z1              +(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y-1)*WD;
      z1row01[CHIP] = z1              +(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;/* not used for RMGRP>1 */
      z1row02[CHIP] = z1              +(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y+1)*WD;/* not used for RMGRP>1 */
      z2row0[CHIP]  = z2              +(CHIP*RRANGE*OMAP+RRANGE*0+PAD+y  )*WD;
    }
//EMAX5A begin wave2d mapdist=0 /* 8 */
    for (CHIP=0; CHIP<NCHIP; CHIP++) { /* output channels are parallelized by multi-chip (OC/#chip) */
 /*2*/for (INIT1=1,LOOP1=RMGRP,roofs=0-WD*4; LOOP1--; INIT1=0) {      /* stage#0 *//* mapped to FOR() on BR[63][1][0] */
   /*1*/for (INIT0=1,LOOP0=WD-PAD*2,coofs=(PAD-1)*4; LOOP0--; INIT0=0) {          /* stage#0 *//* mapped to FOR() on BR[63][0][0] */
          exe(OP_ADD,  &coofs, INIT0?coofs:coofs, EXP_H3210, 4, EXP_H3210,  0LL, EXP_H3210, OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL); /* stage#0 */
          exe(OP_ADD,  &roofs, roofs,  EXP_H3210, INIT0?WD*4:0, EXP_H3210,  0LL, EXP_H3210, OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL); /* stage#0 */
          exe(OP_ADD3, &z0ofs, z0top[CHIP], EXP_H3210, roofs, EXP_H3210,  coofs, EXP_H3210, OP_AND, 0x000000ffffffffffLL, OP_NOP, 0LL); /* stage#1 */
          exe(OP_ADD3, &z1ofs, z1top[CHIP], EXP_H3210, roofs, EXP_H3210,  coofs, EXP_H3210, OP_AND, 0x000000ffffffffffLL, OP_NOP, 0LL); /* stage#1 */
          exe(OP_ADD3, &z2ofs, z2top[CHIP], EXP_H3210, roofs, EXP_H3210,  coofs, EXP_H3210, OP_AND, 0x000000ffffffffffLL, OP_NOP, 0LL); /* stage#1 */
          /*map0*/
          mop(OP_LDWR, 1, &BR[2][0][1], z0ofs, (0                  )*4, MSK_D0, z0row0[CHIP],  WD*RMGRP, 0, 0, NULL, WD*RMGRP);  /* stage#2 */
          exe(OP_FML, &r0, BR[2][0][1], EXP_H3210,  I2,          EXP_H3210,  0,           EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#3 */
          mop(OP_LDWR, 1, &BR[3][0][1], z1ofs, (0             -WD  )*4, MSK_D0, z1row00[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2)); /* stage#3 */
          mop(OP_LDWR, 1, &BR[4][0][1], z1ofs, (0                -1)*4, MSK_D0, z1row00[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2)); /* stage#4 */
          mop(OP_LDWR, 1, &BR[4][0][0], z1ofs, (0                  )*4, MSK_D0, z1row00[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2)); /* stage#4 */
          mop(OP_LDWR, 1, &BR[4][1][1], z1ofs, (0                +1)*4, MSK_D0, z1row00[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2)); /* stage#4 */
          exe(OP_FAD, &r1, BR[3][0][1], EXP_H3210,  BR[4][0][1], EXP_H3210,  0,           EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#5 */
          mop(OP_LDWR, 1, &BR[5][0][1], z1ofs, (0             +WD  )*4, MSK_D0, z1row00[CHIP], WD*(RMGRP+PAD*2), 0, 0, NULL, WD*(RMGRP+PAD*2)); /* stage#5 */
          exe(OP_FMA, &r2, r1,          EXP_H3210,  BR[4][0][0], EXP_H3210,  I4,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#6 */
          exe(OP_FAD, &r3, BR[4][1][1], EXP_H3210,  BR[5][0][1], EXP_H3210,  0,           EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#6 */
          exe(OP_FAD, &r4, r2,          EXP_H3210,  r3,          EXP_H3210,  0,           EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#7 */
          exe(OP_FMA, &r5, r0,          EXP_H3210,  r4,          EXP_H3210,  I3,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#8 */
          exe(OP_FMA, &r6, r5,          EXP_H3210,  BR[4][0][0], EXP_H3210,  I1,          EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);      /* stage#9 */
          mop(OP_STWR, 3, &r6,          z2ofs, (0                  )*4, MSK_D0, z2row0[CHIP],  WD*RMGRP, 0, 0, NULL, WD*RMGRP);  /* stage#9 */
        }
      }
    }
//EMAX5A end
  }
//EMAX5A drain_dirty_lmm
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\epsfile{file=stencil+rmm-wave2d-emax6.eps,width=1.00\textwidth}
\caption{Wave2d}
\end{figure}

\clearpage

\section{実用カーネル}

\subsection{3x3畳み込み}

\shabox{
\leftline{cent\% make -f Makefile-csim.emax6+dma cnn-csim.emax6+dma clean}
\leftline{cent\% ../../src/csim/csim -x cnn-csim.emax6+dma}
}

\shabox{
\leftline{zynq\% make -f Makefile-zynq.emax6+dma cnn-zynq.emax6+dma clean}
\leftline{zynq\% ./cnn-zynq.emax6+dma}
}

\begin{figure}[htbp]
\center
\includegraphics[angle=270,origin=b,width=0.65\textwidth]{EMAX6CNN.eps}
\caption{\label{cnn}CNNの写像}
\end{figure}

図\ref{cnn}は，応用プログラムの1つであるAlexnetの畳み込み演算（CNN）における
データの流れである．入力画像の一部とカーネル（重み）の積和演算結果を求め，複
数入力画像方向に加算したものを出力画像の一部とする（１つの出力画像を得るため
に全入力画像が必要）．各入力画像の画素数は徐々に減少し枚数は増加する．出力画
像は次の処理の入力画像となるため，常に入力画像枚数≦出力画像枚数である．全画
像をハードウェア内に保持できない前提では，入力画像は順次ブロードキャストし，
出力画像単位に演算を分割し，出力画像に次の出力値を累算できるハードウェア構成
が適している．

\begin{figure}[htbp]
\center
\includegraphics[width=0.90\textwidth]{cnn0.eps}
\caption{\label{fig:cnn0}Cnn}
\end{figure}

242x242の畳み込み演算である．一度のバースト演算により8行分を計算する
（RMGRP=8）．ステンシル計算であるものの，一度に8行分を計算するため，
mapdist=0である．図\ref{fig:cnn0}(a)に，CNNのデータ構造，(b)に各unitに積和演
算器を1つ備える(K$^2$+1)xW構成のCGRAを示す（M$\ge$K, OC$\ge$Wを仮定）．(b)は
簡単のために，同一時刻のスナップショットではなく，データフローグラフを示して
いる．実際のハードウェアでは図\ref{fig:mm0}(c)のように各段のデータがパイプラ
イン処理される．CNNは，入力inの一部（KxK）とkernel（KxK）の積和結果を全入力
チャネル分累算し，出力outに格納する．入力の総ワード数はM$^2$xIC，kernelの総
ワード数は，K$^2$に入力チャネル数（IC）と出力チャネル数（OC）を乗じた
K$^2$xICxOC，出力の総ワード数はM$^2$xOCとなる．CNNに用いられるKは奇数であり，
偶数が適するハードウェアパラメタWに対応させると演算器稼働率が低下する．KxKの
積和演算を1列のunit[*][oc mod W]に対応させてパイプライン実行し，W個の出力チャ
ネルを同時に計算するとK$^2$xWの全演算器を利用でき効率がよい（ただしK段のLMM
に対するブロードキャスト機能が必要）．(c)はさらに，OCをNチップに分割して並列
処理し，各チップがK$^2$段の積和演算をREP組xW列写像できる段数を備え，さらに各
LMMが，inの1行（M要素）x GRP行分と，全kernel（IC*OC*K*K要素）を収容できる場
合の実装である．矩形内の7重ループが全チップのCGRAを1回起動する処理に対応し，
chipループの各イタレーションが，各チップにおけるREP組の入力チャネルとkernel
との畳み込み演算によりW組の出力チャネルをGRP行分計算する処理に対応する．外側
ループのocが0からOC/N-1まで増加する間，各チップの最終段を除くLMMはinをGRP行
分保持する．一方，最終段のLMMはocを更新する度に入れ替える必要がある．以上の
演算に要する理論的サイクル数は，CGRA起動時の遅延（K$^2$xREPサイクル）および
LMMの入れ換え時間を除くとK$^2$x(M-2)$^2$xICxOC/(K$^2$xREPxWxN) =
(M-2)$^2$xICxOC/(REPxWxN)となる．また，LMMがin，kernel，out全体を収容できる
場合の理論的DDR-LMM間転送量がM$^2$xIC + K$^2$xICxOC + M$^2$xOCであるのに対し，
各LMMがinをMxGRP，outをMxGRPxW，kernelのみ全部収容できる場合の転送量は，inと
kernelが各々M$^2$xICとK$^2$xICxOC，outは1回分の入れ換え量が(MxGRPxW)x2，矩形
外の回転数(OC/N/W)x(IC/REP)x(M/GRP)にNを乗じた回数の入れ替えが発生するため
M$^2$x2xOCxIC/REP（IC=REPの場合outは一度で計算でき入れ換え不要のためDDR出力
のみのM$^2$xOC．Nに非依存）となる．

\begin{screen}
\tiny
\begin{verbatim}
orig() {
  for (ic=0; ic<IC; ic++) { /* set input channel */
    ip0 = &in[ic*M*M]; /* top of input */
    for (row=1; row<M-1; row++) { /* image loop */
      for (col=1; col<M-1; col++) {
        for (oc=0; oc<OC; oc++) { /* set output channel */
          op = &out0[oc*M*M+row*M+col]; /* top of output */
          kp = &ker[(oc*IC+ic)*K*K];
          kidx = 0;
          for (y=-((K-1)/2); y<=(K-1)/2; y++) { /* kernel loop */
            for (x=-((K-1)/2); x<=(K-1)/2; x++) {
              if (ic == 0 && kidx == 0) {
                *(float*)&*op  = *(float*)&ip0[(row+y)*M+col+x] * *(float*)&kp[kidx];
              }
              else {
                *(float*)&*op += *(float*)&ip0[(row+y)*M+col+x] * *(float*)&kp[kidx];
              }
              kidx++;
              count0++;
} } } } } } }
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
imax() {
  Ull CHIP;
  Ull rofs;
  for (top=1; top<M-1; top+=RMGRP) {
    for (iset=0; iset<IC; iset+=IMAP) { /* accumulate multiple sets of IC */
      for (oc=0; oc<OC/NCHIP; oc+=W) { /* set output channel */
  /*3*/ for (CHIP=0; CHIP<NCHIP; CHIP++) { /* output channels are parallelized by multi-chip (OC/#chip) */
    /*2*/ for (rofs=0; rofs<RMGRP; rofs++) { /* image loop (row) */
      /*1*/ for (col=1; col<M-1; col++) { /* image loop (col) */
              for (w=0; w<W; w++) { /* set output channel */
                op = &out1[(CHIP*OC/NCHIP+oc+w)*M*M+(top+rofs)*M+col]; /* top of output */
                for (ic=0; ic<IMAP; ic++) { /* set offset of input channel */
                  ip0 = &in[(iset+ic)*M*M]; /* top of input */
                  kp = &ker[((CHIP*OC/NCHIP+oc+w)*IC+iset+ic)*K*K];
                  kidx = 0;
                  for (y=-((K-1)/2); y<=(K-1)/2; y++) { /* kernel loop */
                    for (x=-((K-1)/2); x<=(K-1)/2; x++) {
                      if (iset == 0 && ic == 0 && kidx == 0) {
                        *(float*)&*op  = *(float*)&ip0[(top+rofs+y)*M+col+x] * *(float*)&kp[kidx];
                      }
                      else {
                        *(float*)&*op += *(float*)&ip0[(top+rofs+y)*M+col+x] * *(float*)&kp[kidx];
                      }
                      kidx++;
                      count1++;
} } } } } } } } } } }
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
imax() {
  Ull  CHIP;  Ull  LOOP1, LOOP0;  Ull  INIT1, INIT0;
  Ull  AR[64][4];                     /* output of EX     in each unit */
  Ull  BR[64][4][4];                  /* output registers in each unit */
  Ull  r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15;
  Ull  r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31;
  Ull  cc0, cc1, cc2, cc3, ex0, ex1;  Ull  cofs, rofs, oofs;
  for (top=1; top<M-1; top+=RMGRP) {
    for (iset=0; iset<IC; iset+=IMAP) { /* accumulate multiple sets of IC */
      Uint *ip0  = &in[(iset+0)*M*M]; /* top of input#0 */
      Uint *it00 = ip0+(top-1)*M+1-1, *ip00 = ip0+(top-1)*M+1-1, *ip01 = ip0+(top-1)*M+1+0, *ip02 = ip0+(top-1)*M+1+1;
      Uint                            *ip03 = ip0+(top+0)*M+1-1, *ip04 = ip0+(top+0)*M+1+0, *ip05 = ip0+(top+0)*M+1+1;
      Uint                            *ip06 = ip0+(top+1)*M+1-1, *ip07 = ip0+(top+1)*M+1+0, *ip08 = ip0+(top+1)*M+1+1;
          :
      for (oc=0; oc<OC/NCHIP; oc+=W) { /* set output channel */
        Uint *kp00[NCHIP], *kp01[NCHIP], *kp02[NCHIP], *kp03[NCHIP];
            ]
        Uint *kp50[NCHIP], *kp51[NCHIP], *kp52[NCHIP], *kp53[NCHIP];
        Uint *op0[NCHIP], *op1[NCHIP], *op2[NCHIP], *op3[NCHIP];
        Uint *ot0[NCHIP], *ot1[NCHIP], *ot2[NCHIP], *ot3[NCHIP];

        for (CHIP=0; CHIP<NCHIP; CHIP++) { /* output channels are parallelized by multi-chip (OC/#chip) */
          Uint choc  = CHIP*OC/NCHIP+oc;
          kp00[CHIP] = ker+((choc+0)*IC+iset+0)*K*K; kp01[CHIP] = ker+((choc+1)*IC+iset+0)*K*K; kp02[CHIP]
                     = ker+((choc+2)*IC+iset+0)*K*K; kp03[CHIP] = ker+((choc+3)*IC+iset+0)*K*K;
             :
          op0[CHIP] = out1+(choc+0)*M*M+top*M+1; op1[CHIP] = out1+(choc+1)*M*M+top*M+1; op2[CHIP] = out1+(choc+2)*M*M+top*M+1; op3[CHIP] = out1+(choc+3)*M*M+top*M+1;
          ot0[CHIP] = out1+(choc+0)*M*M+top*M+0; ot1[CHIP] = out1+(choc+1)*M*M+top*M+0; ot2[CHIP] = out1+(choc+2)*M*M+top*M+0; ot3[CHIP] = out1+(choc+3)*M*M+top*M+0;
        }
//EMAX5A begin cnn mapdist=0
  /*3*/ for (CHIP=0; CHIP<NCHIP; CHIP++) { /* output channels are parallelized by multi-chip (OC/#chip) */
    /*2*/ for (INIT1=1,LOOP1=RMGRP,rofs=0-M*4; LOOP1--; INIT1=0) {                             /* stage#0 *//* mapped to FOR() on BR[63][1][0] */
      /*1*/ for (INIT0=1,LOOP0=M-2,cofs=0-4; LOOP0--; INIT0=0) {          /* stage#0 *//* mapped to FOR() on BR[63][0][0] */
              exe(OP_ADD,    &cofs, INIT0?cofs:cofs, EXP_H3210, 4, EXP_H3210, 0LL, EXP_H3210, OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL);/* stage#0 */
              exe(OP_ADD,    &rofs, rofs, EXP_H3210, INIT0?M*4:0, EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);                  /* stage#0 */
              exe(OP_ADD,    &oofs, rofs, EXP_H3210, cofs, EXP_H3210, 0LL, EXP_H3210, OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL);        /* stage#1 */
              mop(OP_LDWR,   1, &BR[2][0][1],  (Ull)kp00[CHIP], 0LL, MSK_D0, (Ull)ker, IC*OC*K*K, 0, 0, (Ull)NULL, IC*OC*K*K);       /* stage#2 */
              mop(OP_LDWR,   1, &BR[2][0][0],  (Ull)kp01[CHIP], 0LL, MSK_D0, (Ull)ker, IC*OC*K*K, 0, 0, (Ull)NULL, IC*OC*K*K);       /* stage#2 */
              mop(OP_LDWR,   1, &BR[2][1][1],  (Ull)kp02[CHIP], 0LL, MSK_D0, (Ull)ker, IC*OC*K*K, 0, 0, (Ull)NULL, IC*OC*K*K);       /* stage#2 */
              mop(OP_LDWR,   1, &BR[2][1][0],  (Ull)kp03[CHIP], 0LL, MSK_D0, (Ull)ker, IC*OC*K*K, 0, 0, (Ull)NULL, IC*OC*K*K);       /* stage#2 10KB */
              mop(OP_LDWR,   1, &BR[2][2][1],  (Ull)ip00, oofs, MSK_W0, (Ull)it00, M*(RMGRP+2), 0, 0, (Ull)NULL, M*(RMGRP+2));       /* stage#2 8KB */

              /****in0*****/
              exe(OP_FML, &AR[3][0], BR[2][2][1], EXP_H3210, BR[2][0][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);          /* stage#3 */
              exe(OP_FML, &AR[3][1], BR[2][2][1], EXP_H3210, BR[2][0][0], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);          /* stage#3 */
              exe(OP_FML, &AR[3][2], BR[2][2][1], EXP_H3210, BR[2][1][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);          /* stage#3 */
              exe(OP_FML, &AR[3][3], BR[2][2][1], EXP_H3210, BR[2][1][0], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);          /* stage#3 */
              mop(OP_LDWR,   1, &BR[3][0][1],  (Ull)kp00[CHIP], 4LL, MSK_D0, (Ull)ker, IC*OC*K*K, 0, 0, (Ull)NULL, IC*OC*K*K);       /* stage#3 */
              mop(OP_LDWR,   1, &BR[3][0][0],  (Ull)kp01[CHIP], 4LL, MSK_D0, (Ull)ker, IC*OC*K*K, 0, 0, (Ull)NULL, IC*OC*K*K);       /* stage#3 */
              mop(OP_LDWR,   1, &BR[3][1][1],  (Ull)kp02[CHIP], 4LL, MSK_D0, (Ull)ker, IC*OC*K*K, 0, 0, (Ull)NULL, IC*OC*K*K);       /* stage#3 */
              mop(OP_LDWR,   1, &BR[3][1][0],  (Ull)kp03[CHIP], 4LL, MSK_D0, (Ull)ker, IC*OC*K*K, 0, 0, (Ull)NULL, IC*OC*K*K);       /* stage#3 */
              mop(OP_LDWR,   1, &BR[3][2][1],  (Ull)ip01, oofs, MSK_W0, (Ull)it00, M*(RMGRP+2), 0, 0, (Ull)NULL, M*(RMGRP+2));       /* stage#3 */
                :
              /****in5*****/
              exe(OP_FMA, &AR[48][0], AR[47][0], EXP_H3210, BR[47][2][1], EXP_H3210, BR[47][0][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#48 */
              exe(OP_FMA, &AR[48][1], AR[47][1], EXP_H3210, BR[47][2][1], EXP_H3210, BR[47][0][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#48 */
              exe(OP_FMA, &AR[48][2], AR[47][2], EXP_H3210, BR[47][2][1], EXP_H3210, BR[47][1][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#48 */
              exe(OP_FMA, &AR[48][3], AR[47][3], EXP_H3210, BR[47][2][1], EXP_H3210, BR[47][1][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#48 */
              mop(OP_LDWR,   1, &BR[48][0][1],  (Ull)kp50[CHIP], 4LL, MSK_D0, (Ull)ker, IC*OC*K*K, 0, 0, (Ull)NULL, IC*OC*K*K);      /* stage#48 */
              mop(OP_LDWR,   1, &BR[48][0][0],  (Ull)kp51[CHIP], 4LL, MSK_D0, (Ull)ker, IC*OC*K*K, 0, 0, (Ull)NULL, IC*OC*K*K);      /* stage#48 */
              mop(OP_LDWR,   1, &BR[48][1][1],  (Ull)kp52[CHIP], 4LL, MSK_D0, (Ull)ker, IC*OC*K*K, 0, 0, (Ull)NULL, IC*OC*K*K);      /* stage#48 */
              mop(OP_LDWR,   1, &BR[48][1][0],  (Ull)kp53[CHIP], 4LL, MSK_D0, (Ull)ker, IC*OC*K*K, 0, 0, (Ull)NULL, IC*OC*K*K);      /* stage#48 */
              mop(OP_LDWR,   1, &BR[48][2][1],  (Ull)ip51, oofs, MSK_W0, (Ull)it50, M*(RMGRP+2), 0, 0, (Ull)NULL, M*(RMGRP+2));      /* stage#48 */
                :
              exe(OP_FMA, &AR[53][0], AR[52][0], EXP_H3210, BR[52][2][1], EXP_H3210, BR[52][0][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#53 */
              exe(OP_FMA, &AR[53][1], AR[52][1], EXP_H3210, BR[52][2][1], EXP_H3210, BR[52][0][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#53 */
              exe(OP_FMA, &AR[53][2], AR[52][2], EXP_H3210, BR[52][2][1], EXP_H3210, BR[52][1][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#53 */
              exe(OP_FMA, &AR[53][3], AR[52][3], EXP_H3210, BR[52][2][1], EXP_H3210, BR[52][1][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#53 */
              mop(OP_LDWR,   1, &BR[53][0][1],  (Ull)kp50[CHIP], 24LL, MSK_D0, (Ull)ker, IC*OC*K*K, 0, 0, (Ull)NULL, IC*OC*K*K);     /* stage#53 */
              mop(OP_LDWR,   1, &BR[53][0][0],  (Ull)kp51[CHIP], 24LL, MSK_D0, (Ull)ker, IC*OC*K*K, 0, 0, (Ull)NULL, IC*OC*K*K);     /* stage#53 */
              mop(OP_LDWR,   1, &BR[53][1][1],  (Ull)kp52[CHIP], 24LL, MSK_D0, (Ull)ker, IC*OC*K*K, 0, 0, (Ull)NULL, IC*OC*K*K);     /* stage#53 */
              mop(OP_LDWR,   1, &BR[53][1][0],  (Ull)kp53[CHIP], 24LL, MSK_D0, (Ull)ker, IC*OC*K*K, 0, 0, (Ull)NULL, IC*OC*K*K);     /* stage#53 */
              mop(OP_LDWR,   1, &BR[53][2][1],  (Ull)ip56, oofs, MSK_W0, (Ull)it50, M*(RMGRP+2), 0, 0, (Ull)NULL, M*(RMGRP+2));      /* stage#53 */

              exe(OP_FMA, &AR[54][0], AR[53][0], EXP_H3210, BR[53][2][1], EXP_H3210, BR[53][0][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#54 */
              exe(OP_FMA, &AR[54][1], AR[53][1], EXP_H3210, BR[53][2][1], EXP_H3210, BR[53][0][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#54 */
              exe(OP_FMA, &AR[54][2], AR[53][2], EXP_H3210, BR[53][2][1], EXP_H3210, BR[53][1][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#54 */
              exe(OP_FMA, &AR[54][3], AR[53][3], EXP_H3210, BR[53][2][1], EXP_H3210, BR[53][1][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#54 */
              mop(OP_LDWR,   1, &BR[54][0][1],  (Ull)kp50[CHIP], 28LL, MSK_D0, (Ull)ker, IC*OC*K*K, 0, 0, (Ull)NULL, IC*OC*K*K);     /* stage#54 */
              mop(OP_LDWR,   1, &BR[54][0][0],  (Ull)kp51[CHIP], 28LL, MSK_D0, (Ull)ker, IC*OC*K*K, 0, 0, (Ull)NULL, IC*OC*K*K);     /* stage#54 */
              mop(OP_LDWR,   1, &BR[54][1][1],  (Ull)kp52[CHIP], 28LL, MSK_D0, (Ull)ker, IC*OC*K*K, 0, 0, (Ull)NULL, IC*OC*K*K);     /* stage#54 */
              mop(OP_LDWR,   1, &BR[54][1][0],  (Ull)kp53[CHIP], 28LL, MSK_D0, (Ull)ker, IC*OC*K*K, 0, 0, (Ull)NULL, IC*OC*K*K);     /* stage#54 */
              mop(OP_LDWR,   1, &BR[54][2][1],  (Ull)ip57, oofs, MSK_W0, (Ull)it50, M*(RMGRP+2), 0, 0, (Ull)NULL, M*(RMGRP+2));      /* stage#54 */

              exe(OP_FMA, &AR[55][0], AR[54][0], EXP_H3210, BR[54][2][1], EXP_H3210, BR[54][0][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#55 */
              exe(OP_FMA, &AR[55][1], AR[54][1], EXP_H3210, BR[54][2][1], EXP_H3210, BR[54][0][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#55 */
              exe(OP_FMA, &AR[55][2], AR[54][2], EXP_H3210, BR[54][2][1], EXP_H3210, BR[54][1][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#55 */
              exe(OP_FMA, &AR[55][3], AR[54][3], EXP_H3210, BR[54][2][1], EXP_H3210, BR[54][1][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#55 */
              mop(OP_LDWR,   1, &BR[55][0][1],  (Ull)kp50[CHIP], 32LL, MSK_D0, (Ull)ker, IC*OC*K*K, 0, 0, (Ull)NULL, IC*OC*K*K);     /* stage#55 */
              mop(OP_LDWR,   1, &BR[55][0][0],  (Ull)kp51[CHIP], 32LL, MSK_D0, (Ull)ker, IC*OC*K*K, 0, 0, (Ull)NULL, IC*OC*K*K);     /* stage#55 */
              mop(OP_LDWR,   1, &BR[55][1][1],  (Ull)kp52[CHIP], 32LL, MSK_D0, (Ull)ker, IC*OC*K*K, 0, 0, (Ull)NULL, IC*OC*K*K);     /* stage#55 */
              mop(OP_LDWR,   1, &BR[55][1][0],  (Ull)kp53[CHIP], 32LL, MSK_D0, (Ull)ker, IC*OC*K*K, 0, 0, (Ull)NULL, IC*OC*K*K);     /* stage#55 */
              mop(OP_LDWR,   1, &BR[55][2][1],  (Ull)ip58, oofs, MSK_W0, (Ull)it50, M*(RMGRP+2), 0, 0, (Ull)NULL, M*(RMGRP+2));      /* stage#55 */

              exe(OP_FMA, &AR[56][0], AR[55][0], EXP_H3210, BR[55][2][1], EXP_H3210, BR[55][0][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#56 */
              exe(OP_FMA, &AR[56][1], AR[55][1], EXP_H3210, BR[55][2][1], EXP_H3210, BR[55][0][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#56 */
              exe(OP_FMA, &AR[56][2], AR[55][2], EXP_H3210, BR[55][2][1], EXP_H3210, BR[55][1][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#56 */
              exe(OP_FMA, &AR[56][3], AR[55][3], EXP_H3210, BR[55][2][1], EXP_H3210, BR[55][1][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#56 */

              mop(OP_LDWR,   1, &BR[57][0][1],  (Ull)op0[CHIP], oofs, MSK_W0, (Ull)ot0[CHIP], M*RMGRP, 0, 1, (Ull)NULL, M*RMGRP);    /* stage#57 */
              mop(OP_LDWR,   1, &BR[57][1][1],  (Ull)op1[CHIP], oofs, MSK_W0, (Ull)ot1[CHIP], M*RMGRP, 0, 1, (Ull)NULL, M*RMGRP);    /* stage#57 */
              mop(OP_LDWR,   1, &BR[57][2][1],  (Ull)op2[CHIP], oofs, MSK_W0, (Ull)ot2[CHIP], M*RMGRP, 0, 1, (Ull)NULL, M*RMGRP);    /* stage#57 */
              mop(OP_LDWR,   1, &BR[57][3][1],  (Ull)op3[CHIP], oofs, MSK_W0, (Ull)ot3[CHIP], M*RMGRP, 0, 1, (Ull)NULL, M*RMGRP);    /* stage#57 */
              exe(OP_FAD, &AR[57][0], AR[56][0], EXP_H3210, BR[57][0][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);          /* stage#57 */
              exe(OP_FAD, &AR[57][1], AR[56][1], EXP_H3210, BR[57][1][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);          /* stage#57 */
              exe(OP_FAD, &AR[57][2], AR[56][2], EXP_H3210, BR[57][2][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);          /* stage#57 */
              exe(OP_FAD, &AR[57][3], AR[56][3], EXP_H3210, BR[57][3][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);          /* stage#57 */
              mop(OP_STWR,   1, &AR[57][0], oofs, (Ull)op0[CHIP], MSK_D0, (Ull)ot0[CHIP], M*RMGRP, 0, 1, (Ull)NULL, M*RMGRP);        /* stage#57 8KB */
              mop(OP_STWR,   1, &AR[57][1], oofs, (Ull)op1[CHIP], MSK_D0, (Ull)ot1[CHIP], M*RMGRP, 0, 1, (Ull)NULL, M*RMGRP);        /* stage#57 8KB */
              mop(OP_STWR,   1, &AR[57][2], oofs, (Ull)op2[CHIP], MSK_D0, (Ull)ot2[CHIP], M*RMGRP, 0, 1, (Ull)NULL, M*RMGRP);        /* stage#57 8KB */
              mop(OP_STWR,   1, &AR[57][3], oofs, (Ull)op3[CHIP], MSK_D0, (Ull)ot3[CHIP], M*RMGRP, 0, 1, (Ull)NULL, M*RMGRP);        /* stage#57 8KB */
        } } }
//EMAX5A end
  } } }
//EMAX5A drain_dirty_lmm
}
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\epsfile{file=cnn+rmm-cnn-emax6.eps,width=1.00\textwidth}
\caption{3x3畳み込み}
\end{figure}

\clearpage

Unaligned loadとSIMD演算の組み合わせ

\begin{screen}
\tiny
\begin{verbatim}
imax() {
  Ull  CHIP;  Ull  LOOP1, LOOP0;  Ull  INIT1, INIT0;
  Ull  AR[64][4];                     /* output of EX     in each unit */
  Ull  BR[64][4][4];                  /* output registers in each unit */
  Ull  r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15;
  Ull  r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31;
  Ull  cc0, cc1, cc2, cc3, ex0, ex1;  Ull  cofs, rofs, oofs, k;
  for (top=1; top<M-1; top+=RMGRP) {
    for (iset=0; iset<IC; iset+=IMAP) { /* accumulate multiple sets of IC */
      Uint *ip[IMAP], *it[IMAP], *ip0[IMAP][K*K], *ip1[IMAP][K*K];
      for (k=0; k<IMAP; k++) {
        ip[k] = &in[(iset+k)*M*M]; /* top of input#0-5 */
        it[k] = ip[k]+(top-1)*M+1-1;
        ip0[k][0] = ip[k]+(top-1)*M+1-1; ip0[k][1] = ip[k]+(top-1)*M+1+0; ip0[k][2] = ip[k]+(top-1)*M+1+1;
        ip0[k][3] = ip[k]+(top+0)*M+1-1; ip0[k][4] = ip[k]+(top+0)*M+1+0; ip0[k][5] = ip[k]+(top+0)*M+1+1;
        ip0[k][6] = ip[k]+(top+1)*M+1-1; ip0[k][7] = ip[k]+(top+1)*M+1+0; ip0[k][8] = ip[k]+(top+1)*M+1+1;
        ip1[k][0] = ip[k]+(top-1)*M+1+1; ip1[k][1] = ip[k]+(top-1)*M+1+2; ip1[k][2] = ip[k]+(top-1)*M+1+3;
        ip1[k][3] = ip[k]+(top+0)*M+1+1; ip1[k][4] = ip[k]+(top+0)*M+1+2; ip1[k][5] = ip[k]+(top+0)*M+1+3;
        ip1[k][6] = ip[k]+(top+1)*M+1+1; ip1[k][7] = ip[k]+(top+1)*M+1+2; ip1[k][8] = ip[k]+(top+1)*M+1+3;
      }

      for (oc=0; oc<OC/NCHIP; oc+=W) { /* set output channel */
        Uint *kp0[IMAP][NCHIP], *kp1[IMAP][NCHIP], *kp2[IMAP][NCHIP], *kp3[IMAP][NCHIP];
        Uint *op0[NCHIP], *op1[NCHIP], *op2[NCHIP], *op3[NCHIP];
        Uint *ot0[NCHIP], *ot1[NCHIP], *ot2[NCHIP], *ot3[NCHIP];

        for (CHIP=0; CHIP<NCHIP; CHIP++) { /* output channels are parallelized by multi-chip (OC/#chip) */
          Uint choc  = CHIP*OC/NCHIP+oc;
          for (k=0; k<IMAP; k++) {
            kp0[k][CHIP] = ker+((choc+0)*IC+iset+k)*K*K;
            kp1[k][CHIP] = ker+((choc+1)*IC+iset+k)*K*K;
            kp2[k][CHIP] = ker+((choc+2)*IC+iset+k)*K*K;
            kp3[k][CHIP] = ker+((choc+3)*IC+iset+k)*K*K;
          }
          op0[CHIP] = out1+(choc+0)*M*M+top*M+0; op1[CHIP] = out1+(choc+1)*M*M+top*M+0; op2[CHIP] = out1+(choc+2)*M*M+top*M+0; op3[CHIP] = out1+(choc+3)*M*M+top*M+0;
          ot0[CHIP] = out1+(choc+0)*M*M+top*M+0; ot1[CHIP] = out1+(choc+1)*M*M+top*M+0; ot2[CHIP] = out1+(choc+2)*M*M+top*M+0; ot3[CHIP] = out1+(choc+3)*M*M+top*M+0;
        }

#define cnn_core1(r, i, ofs, k, rp1) \
/*dup load*/  mop(OP_LDWR,   1, &BR[r][0][1],  (Ull)kp0[i][CHIP], ofs, MSK_D0, (Ull)ker, IC*OC*K*K, 0, 0, (Ull)NULL, IC*OC*K*K);\
/*dup load*/  mop(OP_LDWR,   1, &BR[r][0][0],  (Ull)kp1[i][CHIP], ofs, MSK_D0, (Ull)ker, IC*OC*K*K, 0, 0, (Ull)NULL, IC*OC*K*K);\
/*dup load*/  mop(OP_LDWR,   1, &BR[r][1][1],  (Ull)kp2[i][CHIP], ofs, MSK_D0, (Ull)ker, IC*OC*K*K, 0, 0, (Ull)NULL, IC*OC*K*K);\
/*dup load*/  mop(OP_LDWR,   1, &BR[r][1][0],  (Ull)kp3[i][CHIP], ofs, MSK_D0, (Ull)ker, IC*OC*K*K, 0, 0, (Ull)NULL, IC*OC*K*K);\
/*unaligned*/ mop(OP_LDR,    1, &BR[r][2][1],  (Ull)ip1[i][k], oofs, MSK_W0, (Ull)it[i], M*(RMGRP+2), 0, 0, (Ull)NULL, M*(RMGRP+2));\
/*unaligned*/ mop(OP_LDR,    1, &BR[r][2][0],  (Ull)ip0[i][k], oofs, MSK_W0, (Ull)it[i], M*(RMGRP+2), 0, 0, (Ull)NULL, M*(RMGRP+2));\
              exe(OP_FMA, &AR[rp1][0], AR[r][0], EXP_H3210, BR[r][2][0], EXP_H3210, BR[r][0][1], EXP_H1010, OP_NOP, 0LL, OP_NOP, 0LL);\
              exe(OP_FMA, &AR[rp1][1], AR[r][1], EXP_H3210, BR[r][2][0], EXP_H3210, BR[r][0][0], EXP_H1010, OP_NOP, 0LL, OP_NOP, 0LL);\
              exe(OP_FMA, &AR[rp1][2], AR[r][2], EXP_H3210, BR[r][2][0], EXP_H3210, BR[r][1][1], EXP_H1010, OP_NOP, 0LL, OP_NOP, 0LL);\
              exe(OP_FMA, &AR[rp1][3], AR[r][3], EXP_H3210, BR[r][2][0], EXP_H3210, BR[r][1][0], EXP_H1010, OP_NOP, 0LL, OP_NOP, 0LL)

#define cnn_final(r, rp1) \
              mop(OP_LDR,  1, &BR[rp1][0][1],  (Ull)op0[CHIP], oofs, MSK_W0, (Ull)ot0[CHIP], M*RMGRP, 0, 1, (Ull)NULL, M*RMGRP);\
              mop(OP_LDR,  1, &BR[rp1][1][1],  (Ull)op1[CHIP], oofs, MSK_W0, (Ull)ot1[CHIP], M*RMGRP, 0, 1, (Ull)NULL, M*RMGRP);\
              mop(OP_LDR,  1, &BR[rp1][2][1],  (Ull)op2[CHIP], oofs, MSK_W0, (Ull)ot2[CHIP], M*RMGRP, 0, 1, (Ull)NULL, M*RMGRP);\
              mop(OP_LDR,  1, &BR[rp1][3][1],  (Ull)op3[CHIP], oofs, MSK_W0, (Ull)ot3[CHIP], M*RMGRP, 0, 1, (Ull)NULL, M*RMGRP);\
              exe(OP_FAD, &AR[rp1][0], AR[r][0], EXP_H3210, BR[rp1][0][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
              exe(OP_FAD, &AR[rp1][1], AR[r][1], EXP_H3210, BR[rp1][1][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
              exe(OP_FAD, &AR[rp1][2], AR[r][2], EXP_H3210, BR[rp1][2][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
              exe(OP_FAD, &AR[rp1][3], AR[r][3], EXP_H3210, BR[rp1][3][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
              mop(OP_STR,  3, &AR[rp1][0], oofs, (Ull)op0[CHIP], MSK_D0, (Ull)ot0[CHIP], M*RMGRP, 0, 1, (Ull)NULL, M*RMGRP);\
              mop(OP_STR,  3, &AR[rp1][1], oofs, (Ull)op1[CHIP], MSK_D0, (Ull)ot1[CHIP], M*RMGRP, 0, 1, (Ull)NULL, M*RMGRP);\
              mop(OP_STR,  3, &AR[rp1][2], oofs, (Ull)op2[CHIP], MSK_D0, (Ull)ot2[CHIP], M*RMGRP, 0, 1, (Ull)NULL, M*RMGRP);\
              mop(OP_STR,  3, &AR[rp1][3], oofs, (Ull)op3[CHIP], MSK_D0, (Ull)ot3[CHIP], M*RMGRP, 0, 1, (Ull)NULL, M*RMGRP)

//EMAX5A begin cnn mapdist=0
  /*3*/ for (CHIP=0; CHIP<NCHIP; CHIP++) { /* output channels are parallelized by multi-chip (OC/#chip) */
    /*2*/ for (INIT1=1,LOOP1=RMGRP,rofs=0-M*4; LOOP1--; INIT1=0) {            /* stage#0 *//* mapped to FOR() on BR[63][1][0] */
      /*1*/ for (INIT0=1,LOOP0=(M-2)/2,cofs=0-8; LOOP0--; INIT0=0) {          /* stage#0 *//* mapped to FOR() on BR[63][0][0] */
              exe(OP_ADD,    &cofs, INIT0?cofs:cofs, EXP_H3210, 8, EXP_H3210, 0LL, EXP_H3210, OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL);/* stage#0 */
              exe(OP_ADD,    &rofs, rofs, EXP_H3210, INIT0?M*4:0,  EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);           /* stage#0 */
              exe(OP_ADD,    &oofs, rofs, EXP_H3210, cofs, EXP_H3210, 0LL, EXP_H3210, OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL);  /* stage#1 */

/*dup load*/  mop(OP_LDWR,   1, &BR[2][0][1],  (Ull)kp0[0][CHIP], 0LL, MSK_D0, (Ull)ker, IC*OC*K*K, 0, 0, (Ull)NULL, IC*OC*K*K); /* stage#2 */
/*dup load*/  mop(OP_LDWR,   1, &BR[2][0][0],  (Ull)kp1[0][CHIP], 0LL, MSK_D0, (Ull)ker, IC*OC*K*K, 0, 0, (Ull)NULL, IC*OC*K*K); /* stage#2 */
/*dup load*/  mop(OP_LDWR,   1, &BR[2][1][1],  (Ull)kp2[0][CHIP], 0LL, MSK_D0, (Ull)ker, IC*OC*K*K, 0, 0, (Ull)NULL, IC*OC*K*K); /* stage#2 */
/*dup load*/  mop(OP_LDWR,   1, &BR[2][1][0],  (Ull)kp3[0][CHIP], 0LL, MSK_D0, (Ull)ker, IC*OC*K*K, 0, 0, (Ull)NULL, IC*OC*K*K); /* stage#2 10KB */
/*unaligned*/ mop(OP_LDR,    1, &BR[2][2][1],  (Ull)ip1[0][0], oofs, MSK_W0, (Ull)it[0], M*(RMGRP+2), 0, 0, (Ull)NULL, M*(RMGRP+2)); /* stage#2 8KB */
/*unaligned*/ mop(OP_LDR,    1, &BR[2][2][0],  (Ull)ip0[0][0], oofs, MSK_W0, (Ull)it[0], M*(RMGRP+2), 0, 0, (Ull)NULL, M*(RMGRP+2)); /* stage#2 8KB */
              exe(OP_FML, &AR[3][0], BR[2][2][0], EXP_H3210, BR[2][0][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#3 */
              exe(OP_FML, &AR[3][1], BR[2][2][0], EXP_H3210, BR[2][0][0], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#3 */
              exe(OP_FML, &AR[3][2], BR[2][2][0], EXP_H3210, BR[2][1][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#3 */
              exe(OP_FML, &AR[3][3], BR[2][2][0], EXP_H3210, BR[2][1][0], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#3 */

              cnn_core1( 3, 0,  4LL, 1,  4);
              cnn_core1( 4, 0,  8LL, 2,  5);
              cnn_core1( 5, 0, 12LL, 3,  6);
              cnn_core1( 6, 0, 16LL, 4,  7);
              cnn_core1( 7, 0, 20LL, 5,  8);
              cnn_core1( 8, 0, 24LL, 6,  9);
              cnn_core1( 9, 0, 28LL, 7, 10);
              cnn_core1(10, 0, 32LL, 8, 11);

              cnn_core1(11, 1,  0LL, 0, 12);
              cnn_core1(12, 1,  4LL, 1, 13);
              cnn_core1(13, 1,  8LL, 2, 14);
              cnn_core1(14, 1, 12LL, 3, 15);
              cnn_core1(15, 1, 16LL, 4, 16);
              cnn_core1(16, 1, 20LL, 5, 17);
              cnn_core1(17, 1, 24LL, 6, 18);
              cnn_core1(18, 1, 28LL, 7, 19);
              cnn_core1(19, 1, 32LL, 8, 20);
                :
              cnn_core1(55, 5, 32LL, 8, 56);
              /****final*****/
              cnn_final(56,     57);
        } } }
//EMAX5A end
  } } }
//EMAX5A drain_dirty_lmm
}
\end{verbatim}
\end{screen}

\clearpage

\subsection{行列積}

\shabox{
\leftline{cent\% make -f Makefile-csim.emax6+dma mm-csim.emax6+dma clean}
\leftline{cent\% ../../src/csim/csim -x mm-csim.emax6+dma}
}

\shabox{
\leftline{zynq\% make -f Makefile-zynq.emax6+dma mm-zynq.emax6+dma clean}
\leftline{zynq\% ./mm-zynq.emax6+dma}
}

\begin{figure}[htbp]
\center
\includegraphics[width=0.98\textwidth]{mm0.eps}
\caption{\label{fig:mm0}Mm}
\end{figure}

480x480の行列積計算である．一度のバースト演算により8行分を計算する（RMGRP=8）．
ステンシル計算であるものの，一度に8行分を計算するため，mapdist=0である．図
\ref{fig:mm0}(a)にMMのデータ構造，(b)にC言語による一般的な実装，(c)に各unit
に積和演算器を1つ備えるH+1（height）x W（width）構成のCGRAと同一時刻における
スナップショットを示す（M$\ge$H, M$\ge$Wを仮定）．出力C[row][col]に対応する
A[row][*] x B[*][col]の積和演算をH組ごとに分割し，1列のunit[*mod H][col mod
W]に対応させてパイプライン実行するとHxWの全演算器を利用でき効率がよい．例え
ば左端列では，結果C0c, C08, C04, C00に必要な乗算A00 x B0c，A01 x B18, A02 x
B24, A03 x B30を同時刻に行い，最終段からC00, C04, C08, C0c,.., C0(M-4)の部分
和を毎サイクル出力しLMMに累算する．すなわち，HxWの演算スループットにより，毎
サイクルW個の部分和を出力する．これをM/H回繰り返すことにより，完全なC00,
C01,.., C0(M-1)が得られる．(d)はさらに，配列AをNチップに行分割して並列処理し，
各LMMが，配列Aの1行（M要素）x GRP行分と，配列Bの1行（M要素）を収容できる場合
の実装である．矩形内の5重ループが全チップのCGRAを1回起動する処理に対応し，
chipループの各イタレーションが，各チップにおける配列AのGRP行分と配列B全体の
行列積に対応する．外側ループのblkが0からM-1に増加する間，各チップの最終段を
除くLMMは配列AをGRP行分保持し，最終段のLMMはCx0, Cx1,.., Cx(M-1)をGRP行分保
持しつつ更新する．一方，配列Bは，blkを更新する度に対応するH行分を全チップに
ブロードキャストする必要がある．以上の演算に要する理論的サイクル数は，CGRA起
動時の遅延（H+1サイクル）およびLMMの入れ換え時間を除くとM$^3$/(HxWxN)となる．
また，LMMがA，B，C全体を収容できる場合の理論的DDR-LMM間転送量がM$^2$x3である
のに対し，各LMMがAとCをMxGRP，BをMxHのみ収容できる場合の転送量は，AとCが各々
M$^2$，BがM$^2$xM/GRP（M=GRPの場合M$^2$に一致．Nに非依存．ブロードキャスト前
提）と最適になる．

\begin{screen}
\tiny
\begin{verbatim}
orig() {
  for (row=0; row<M1; row++) {
    for (col=0; col<M2; col++) {
      for (n=0; n<L; n++) {
        if (n==0) *(float*)&C0[row*M2+col]  = *(float*)&A[row*L+n] * *(float*)&B[n*M2+col];
        else      *(float*)&C0[row*M2+col] += *(float*)&A[row*L+n] * *(float*)&B[n*M2+col];
        count0++;
} } } }
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
imax() {
  Ull CHIP;  Ull rofs;
  for (top=0; top<M1/NCHIP; top+=RMGRP) { /* will be parallelized by multi-chip (M/#chip) */
    for (blk=0; blk<L; blk+=H) { /* 3重ループ目 (Cが確定するまでのDMA入れ換えはR/Wを伴うためオーバヘッドになる. Bのbroadcast回数を増やす方が結果的に高速) */
/*3*/ for (CHIP=0; CHIP<NCHIP; CHIP++) { /* will be parallelized by multi-chip (M/#chip) */
  /*2*/ for (rofs=0; rofs<RMGRP; rofs++) { /* will be parallelized by multi-chip (M/#chip) */
    /*1*/ for (col=0; col<M2; col+=W) { /* one-horizontal-line is calculated by EMAX-while(loop--) */
            for (w=0; w<W; w++) {   /* horizontal (parallel) execution */
              for (h=0; h<H; h++) { /* vertical (pipelined) execution */
                if (blk == 0 && h == 0)
                  *(float*)&C1[(CHIP*M1/NCHIP+top+rofs)*M2+col+w]  = *(float*)&A[(CHIP*M1/NCHIP+top+rofs)*L+blk+h]**(float*)&B[(blk+h)*M2+col+w];
                else
                  *(float*)&C1[(CHIP*M1/NCHIP+top+rofs)*M2+col+w] += *(float*)&A[(CHIP*M1/NCHIP+top+rofs)*L+blk+h]**(float*)&B[(blk+h)*M2+col+w];
                count1++;
} } } } } } } }
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
imax() {
  Ull  CHIP;  Ull  LOOP1, LOOP0;  Ull  INIT1, INIT0;
  Ull  AR[64][4];                     /* output of EX     in each unit */
  Ull  BR[64][4][4];                  /* output registers in each unit */
  Ull  r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15;
  Ull  r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31;
  Ull  cc0, cc1, cc2, cc3, ex0, ex1;  Ull  cofs, rofs, oofs;
  for (top=0; top<M1/NCHIP; top+=RMGRP) { /* will be parallelized by multi-chip (M/#chip) */
    for (blk=0; blk<L; blk+=H) { /* 3重ループ展開の外側対象 */
      typedef struct {Uint i[4]} Ui4;
      Ui4  *b00 = B+(blk+ 0)*M2, *b000 = b00, *b001 = (Uint*)b00+1, *b002 = (Uint*)b00+2, *b003 = (Uint*)b00+3;
          :
      Uint *a0[NCHIP]; Uint *a00[NCHIP], *a01[NCHIP], *a02[NCHIP], *a03[NCHIP], *a04[NCHIP], *a05[NCHIP], *a06[NCHIP], *a07[NCHIP];
          :
      Ui4  *c0[NCHIP]; Ui4  *c00[NCHIP], *c01[NCHIP], *c02[NCHIP], *c03[NCHIP];
      for (CHIP=0; CHIP<NCHIP; CHIP++) { /* will be parallelized by multi-chip (M/#chip) */
        a0[CHIP] = A+(CHIP*M1/NCHIP+top)*L;
        a00[CHIP]= a0[CHIP]+blk+ 0; a01[CHIP]= a0[CHIP]+blk+ 1; a02[CHIP]= a0[CHIP]+blk+ 2; a03[CHIP]= a0[CHIP]+blk+ 3;
              :
        c0[CHIP] = C1+(CHIP*M1/NCHIP+top)*M2;  c00[CHIP]= (Uint*)c0[CHIP]+0; c01[CHIP]= (Uint*)c0[CHIP]+1; c02[CHIP]= (Uint*)c0[CHIP]+2; c03[CHIP]= (Uint*)c0[CHIP]+3;
      }
//EMAX5A begin mm mapdist=0
/*3*/ for (CHIP=0; CHIP<NCHIP; CHIP++) { /* will be parallelized by multi-chip (M/#chip) */
  /*2*/ for (INIT1=1,LOOP1=RMGRP,rofs=(0-L*4)<<32|((0-M2*4)&0xffffffff); LOOP1--; INIT1=0) { /* stage#0 *//* mapped to FOR() on BR[63][1][0] */
    /*1*/ for (INIT0=1,LOOP0=M2/W,cofs=(0-W*4)<<32|((0-W*4)&0xffffffff); LOOP0--; INIT0=0) {      /* stage#0 *//* mapped to FOR() on BR[63][0][0] */
            exe(OP_ADD,    &cofs, INIT0?cofs:cofs, EXP_H3210, (W*4)<<32|(W*4), EXP_H3210, 0LL, EXP_H3210, OP_AND, 0xffffffffffffffffLL, OP_NOP, 0LL);
            exe(OP_ADD,    &rofs, rofs, EXP_H3210, INIT0?(L*4)<<32|(M2*4):0, EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#0 */
            exe(OP_ADD,    &oofs, rofs, EXP_H3210, cofs, EXP_H3210, 0, EXP_H3210, OP_AND, 0xffffffff, OP_NOP, 0LL);            /* stage#1 */
            mop(OP_LDWR,   1, &BR[1][0][1],  (Ull)b000, (Ull)cofs, MSK_W1, (Ull)b00, M2, 0, 0, (Ull)NULL, M2);             /* stage#1 */
            mop(OP_LDWR,   1, &BR[1][0][0],  (Ull)b001, (Ull)cofs, MSK_W1, (Ull)b00, M2, 0, 0, (Ull)NULL, M2);             /* stage#1 */
            mop(OP_LDWR,   1, &BR[1][1][1],  (Ull)b002, (Ull)cofs, MSK_W1, (Ull)b00, M2, 0, 0, (Ull)NULL, M2);             /* stage#1 */
            mop(OP_LDWR,   1, &BR[1][1][0],  (Ull)b003, (Ull)cofs, MSK_W1, (Ull)b00, M2, 0, 0, (Ull)NULL, M2);             /* stage#1 2KB */
            mop(OP_LDWR,   1, &BR[1][2][1],  (Ull)a00[CHIP],  (Ull)rofs, MSK_W1, (Ull)a0[CHIP], L*RMGRP, 0, 0, (Ull)NULL, L*RMGRP); /* stage#1 16KB */

            exe(OP_FML, &AR[2][0], BR[1][0][1], EXP_H3210,  BR[1][2][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#2 */
            exe(OP_FML, &AR[2][1], BR[1][0][0], EXP_H3210,  BR[1][2][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#2 */
            exe(OP_FML, &AR[2][2], BR[1][1][1], EXP_H3210,  BR[1][2][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#2 */
            exe(OP_FML, &AR[2][3], BR[1][1][0], EXP_H3210,  BR[1][2][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#2 */
            mop(OP_LDWR,   1, &BR[2][0][1],  (Ull)b010, (Ull)cofs, MSK_W1, (Ull)b01, M2, 0, 0, (Ull)NULL, M2);             /* stage#2 */
            mop(OP_LDWR,   1, &BR[2][0][0],  (Ull)b011, (Ull)cofs, MSK_W1, (Ull)b01, M2, 0, 0, (Ull)NULL, M2);             /* stage#2 */
            mop(OP_LDWR,   1, &BR[2][1][1],  (Ull)b012, (Ull)cofs, MSK_W1, (Ull)b01, M2, 0, 0, (Ull)NULL, M2);             /* stage#2 */
            mop(OP_LDWR,   1, &BR[2][1][0],  (Ull)b013, (Ull)cofs, MSK_W1, (Ull)b01, M2, 0, 0, (Ull)NULL, M2);             /* stage#2 2KB */
            mop(OP_LDWR,   1, &BR[2][2][1],  (Ull)a01[CHIP],  (Ull)rofs, MSK_W1, (Ull)a0[CHIP], L*RMGRP, 0, 0, (Ull)NULL, L*RMGRP);  /* stage#2 16KB */
              :
            exe(OP_FMA, &AR[60][0], AR[59][0], EXP_H3210,  BR[59][2][1], EXP_H3210, BR[59][0][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#60 */
            exe(OP_FMA, &AR[60][1], AR[59][1], EXP_H3210,  BR[59][2][1], EXP_H3210, BR[59][0][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#60 */
            exe(OP_FMA, &AR[60][2], AR[59][2], EXP_H3210,  BR[59][2][1], EXP_H3210, BR[59][1][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#60 */
            exe(OP_FMA, &AR[60][3], AR[59][3], EXP_H3210,  BR[59][2][1], EXP_H3210, BR[59][1][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#60 */
            mop(OP_LDWR,   1, &BR[60][0][1],  (Ull)b590, (Ull)cofs, MSK_W1, (Ull)b59, M2, 0, 0, (Ull)NULL, M2);            /* stage#60 */
            mop(OP_LDWR,   1, &BR[60][0][0],  (Ull)b591, (Ull)cofs, MSK_W1, (Ull)b59, M2, 0, 0, (Ull)NULL, M2);            /* stage#60 */
            mop(OP_LDWR,   1, &BR[60][1][1],  (Ull)b592, (Ull)cofs, MSK_W1, (Ull)b59, M2, 0, 0, (Ull)NULL, M2);            /* stage#60 */
            mop(OP_LDWR,   1, &BR[60][1][0],  (Ull)b593, (Ull)cofs, MSK_W1, (Ull)b59, M2, 0, 0, (Ull)NULL, M2);            /* stage#60 */
            mop(OP_LDWR,   1, &BR[60][2][1],  (Ull)a59[CHIP],  (Ull)rofs, MSK_W1, (Ull)a0[CHIP], L*RMGRP, 0, 0, (Ull)NULL, L*RMGRP); /* stage#60 */

            exe(OP_FMA, &AR[61][0], AR[60][0], EXP_H3210,  BR[60][2][1], EXP_H3210, BR[60][0][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#61 */
            exe(OP_FMA, &AR[61][1], AR[60][1], EXP_H3210,  BR[60][2][1], EXP_H3210, BR[60][0][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#61 */
            exe(OP_FMA, &AR[61][2], AR[60][2], EXP_H3210,  BR[60][2][1], EXP_H3210, BR[60][1][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#61 */
            exe(OP_FMA, &AR[61][3], AR[60][3], EXP_H3210,  BR[60][2][1], EXP_H3210, BR[60][1][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#61 */

            mop(OP_LDWR,   1, &BR[62][0][1],  (Ull)c00[CHIP], (Ull)oofs, MSK_W0, (Ull)c0[CHIP], M2*RMGRP, 0, 1, (Ull)NULL, M2*RMGRP);  /* stage#62 */
            mop(OP_LDWR,   1, &BR[62][1][1],  (Ull)c01[CHIP], (Ull)oofs, MSK_W0, (Ull)c0[CHIP], M2*RMGRP, 0, 1, (Ull)NULL, M2*RMGRP);  /* stage#62 */
            mop(OP_LDWR,   1, &BR[62][2][1],  (Ull)c02[CHIP], (Ull)oofs, MSK_W0, (Ull)c0[CHIP], M2*RMGRP, 0, 1, (Ull)NULL, M2*RMGRP);  /* stage#62 */
            mop(OP_LDWR,   1, &BR[62][3][1],  (Ull)c03[CHIP], (Ull)oofs, MSK_W0, (Ull)c0[CHIP], M2*RMGRP, 0, 1, (Ull)NULL, M2*RMGRP);  /* stage#62 */
            exe(OP_FAD, &AR[62][0], AR[61][0], EXP_H3210,  BR[62][0][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#62 */
            exe(OP_FAD, &AR[62][1], AR[61][1], EXP_H3210,  BR[62][1][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#62 */
            exe(OP_FAD, &AR[62][2], AR[61][2], EXP_H3210,  BR[62][2][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#62 */
            exe(OP_FAD, &AR[62][3], AR[61][3], EXP_H3210,  BR[62][3][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#62 */
            mop(OP_STWR,   1, &AR[62][0],     (Ull)oofs, (Ull)c00[CHIP], MSK_D0, (Ull)c0[CHIP], M2*RMGRP, 0, 1, (Ull)NULL, M2*RMGRP);  /* stage#62 */
            mop(OP_STWR,   1, &AR[62][1],     (Ull)oofs, (Ull)c01[CHIP], MSK_D0, (Ull)c0[CHIP], M2*RMGRP, 0, 1, (Ull)NULL, M2*RMGRP);  /* stage#62 */
            mop(OP_STWR,   1, &AR[62][2],     (Ull)oofs, (Ull)c02[CHIP], MSK_D0, (Ull)c0[CHIP], M2*RMGRP, 0, 1, (Ull)NULL, M2*RMGRP);  /* stage#62 */
            mop(OP_STWR,   1, &AR[62][3],     (Ull)oofs, (Ull)c03[CHIP], MSK_D0, (Ull)c0[CHIP], M2*RMGRP, 0, 1, (Ull)NULL, M2*RMGRP);  /* stage#62 */
      } } }
//EMAX5A end
  } }
//EMAX5A drain_dirty_lmm
}
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\epsfile{file=mm+rmm-mm-emax6.eps,width=1.00\textwidth}
\caption{行列積}
\end{figure}

\clearpage

Duplicated loadとSIMD演算の組み合わせ

\begin{figure}[htbp]
\center
\includegraphics[width=0.80\textwidth]{mm1.eps}
\caption{\label{fig:mm1}32bit $\rightarrow$ 32bit$|$32bit loadとSIMD演算の組み合わせ}
\end{figure}

\begin{screen}
\tiny
\begin{verbatim}
imax() {
  Ull  CHIP;  Ull  LOOP1, LOOP0;  Ull  INIT1, INIT0;
  Ull  AR[64][4];                     /* output of EX     in each unit */
  Ull  BR[64][4][4];                  /* output registers in each unit */
  Ull  r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15;
  Ull  r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31;
  Ull  cc0, cc1, cc2, cc3, ex0, ex1;  Ull  cofs, rofs, oofs, k;
  for (top=0; top<M1/NCHIP; top+=RMGRP) { /* will be parallelized by multi-chip (M/#chip) */
    for (blk=0; blk<L; blk+=H) { /* 3重ループ展開の外側対象 */
      typedef struct {Uint i[8]} Ui8;
      Uint *a0[NCHIP];
      Uint *a[H][NCHIP];
      Ui8  *b[H], *b0[H], *b1[H], *b2[H], *b3[H];
      Ui8  *c0[NCHIP];
      Ui8  *c00[NCHIP], *c01[NCHIP], *c02[NCHIP], *c03[NCHIP];
      for (k=0; k<H; k++) {
        b[k] = B+(blk+k)*M2; b0[k] = b[k]; b1[k] = (Uint*)b[k]+2; b2[k] = (Uint*)b[k]+4;  b3[k] = (Uint*)b[k]+6;
      }
      for (CHIP=0; CHIP<NCHIP; CHIP++) { /* will be parallelized by multi-chip (M/#chip) */
        a0[CHIP] = A+(CHIP*M1/NCHIP+top)*L;
        for (k=0; k<H; k++)
          a[k][CHIP] = a0[CHIP]+blk+k;
        c0[CHIP] = C1+(CHIP*M1/NCHIP+top)*M2;
        c00[CHIP]= (Uint*)c0[CHIP]+0; c01[CHIP]= (Uint*)c0[CHIP]+2; c02[CHIP]= (Uint*)c0[CHIP]+4; c03[CHIP]= (Uint*)c0[CHIP]+6;
      }

#define sgemm00_core1(r, rm1, rp1) \
            mop(OP_LDR,  3, &BR[r][0][1],  (Ull)b0[rm1], (Ull)cofs, MSK_W1, (Ull)b[rm1], M2, 0, 0, (Ull)NULL, M2);\
            mop(OP_LDR,  3, &BR[r][0][0],  (Ull)b1[rm1], (Ull)cofs, MSK_W1, (Ull)b[rm1], M2, 0, 0, (Ull)NULL, M2);\
            mop(OP_LDR,  3, &BR[r][1][1],  (Ull)b2[rm1], (Ull)cofs, MSK_W1, (Ull)b[rm1], M2, 0, 0, (Ull)NULL, M2);\
            mop(OP_LDR,  3, &BR[r][1][0],  (Ull)b3[rm1], (Ull)cofs, MSK_W1, (Ull)b[rm1], M2, 0, 0, (Ull)NULL, M2);\
/*dup load*/mop(OP_LDWR, 1, &BR[r][2][1],  (Ull)a[rm1][CHIP],  (Ull)rofs, MSK_W1, (Ull)a0[CHIP], L*RMGRP, 0, 0, (Ull)NULL, L*RMGRP);\
            exe(OP_FMA, &AR[rp1][0], AR[r][0], EXP_H3210,  BR[r][2][1], EXP_H1010, BR[r][0][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
            exe(OP_FMA, &AR[rp1][1], AR[r][1], EXP_H3210,  BR[r][2][1], EXP_H1010, BR[r][0][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
            exe(OP_FMA, &AR[rp1][2], AR[r][2], EXP_H3210,  BR[r][2][1], EXP_H1010, BR[r][1][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
            exe(OP_FMA, &AR[rp1][3], AR[r][3], EXP_H3210,  BR[r][2][1], EXP_H1010, BR[r][1][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL)

#define sgemm00_final(r, rp1) \
            mop(OP_LDR,  3, &BR[rp1][0][1],  (Ull)c00[CHIP], (Ull)oofs, MSK_W0, (Ull)c0[CHIP], M2*RMGRP, 0, 1, (Ull)NULL, M2*RMGRP);\
            mop(OP_LDR,  3, &BR[rp1][1][1],  (Ull)c01[CHIP], (Ull)oofs, MSK_W0, (Ull)c0[CHIP], M2*RMGRP, 0, 1, (Ull)NULL, M2*RMGRP);\
            mop(OP_LDR,  3, &BR[rp1][2][1],  (Ull)c02[CHIP], (Ull)oofs, MSK_W0, (Ull)c0[CHIP], M2*RMGRP, 0, 1, (Ull)NULL, M2*RMGRP);\
            mop(OP_LDR,  3, &BR[rp1][3][1],  (Ull)c03[CHIP], (Ull)oofs, MSK_W0, (Ull)c0[CHIP], M2*RMGRP, 0, 1, (Ull)NULL, M2*RMGRP);\
            exe(OP_FAD, &AR[rp1][0], AR[r][0], EXP_H3210,  BR[rp1][0][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
            exe(OP_FAD, &AR[rp1][1], AR[r][1], EXP_H3210,  BR[rp1][1][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
            exe(OP_FAD, &AR[rp1][2], AR[r][2], EXP_H3210,  BR[rp1][2][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
            exe(OP_FAD, &AR[rp1][3], AR[r][3], EXP_H3210,  BR[rp1][3][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
            mop(OP_STR,  3, &AR[rp1][0],     (Ull)oofs, (Ull)c00[CHIP], MSK_D0, (Ull)c0[CHIP], M2*RMGRP, 0, 1, (Ull)NULL, M2*RMGRP);\
            mop(OP_STR,  3, &AR[rp1][1],     (Ull)oofs, (Ull)c01[CHIP], MSK_D0, (Ull)c0[CHIP], M2*RMGRP, 0, 1, (Ull)NULL, M2*RMGRP);\
            mop(OP_STR,  3, &AR[rp1][2],     (Ull)oofs, (Ull)c02[CHIP], MSK_D0, (Ull)c0[CHIP], M2*RMGRP, 0, 1, (Ull)NULL, M2*RMGRP);\
            mop(OP_STR,  3, &AR[rp1][3],     (Ull)oofs, (Ull)c03[CHIP], MSK_D0, (Ull)c0[CHIP], M2*RMGRP, 0, 1, (Ull)NULL, M2*RMGRP)

//EMAX5A begin mm mapdist=0
/*3*/ for (CHIP=0; CHIP<NCHIP; CHIP++) { /* will be parallelized by multi-chip (M/#chip) */
  /*2*/ for (INIT1=1,LOOP1=RMGRP,rofs=(0-L*4)<<32|((0-M2*4)&0xffffffff); LOOP1--; INIT1=0) { /* stage#0 *//* mapped to FOR() on BR[63][1][0] */
    /*1*/ for (INIT0=1,LOOP0=M2/W/2,cofs=(0-W*8)<<32|((0-W*8)&0xffffffff); LOOP0--; INIT0=0) {      /* stage#0 *//* mapped to FOR() on BR[63][0][0] */
            exe(OP_ADD,    &cofs, INIT0?cofs:cofs, EXP_H3210, (W*8)<<32|(W*8), EXP_H3210, 0LL, EXP_H3210, OP_AND, 0xffffffffffffffffLL, OP_NOP, 0LL);/* stage#0 */
            exe(OP_ADD,    &rofs, rofs, EXP_H3210, INIT0?(L*4)<<32|(M2*4):0, EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#0 */
            exe(OP_ADD,    &oofs, rofs, EXP_H3210, cofs, EXP_H3210, 0, EXP_H3210, OP_AND, 0xffffffff, OP_NOP, 0LL);        /* stage#1 */

            mop(OP_LDR,  3, &BR[1][0][1],  (Ull)b0[0], (Ull)cofs, MSK_W1, (Ull)b[0], M2, 0, 0, (Ull)NULL, M2);             /* stage#1 */
            mop(OP_LDR,  3, &BR[1][0][0],  (Ull)b1[0], (Ull)cofs, MSK_W1, (Ull)b[0], M2, 0, 0, (Ull)NULL, M2);             /* stage#1 */
            mop(OP_LDR,  3, &BR[1][1][1],  (Ull)b2[0], (Ull)cofs, MSK_W1, (Ull)b[0], M2, 0, 0, (Ull)NULL, M2);             /* stage#1 */
            mop(OP_LDR,  3, &BR[1][1][0],  (Ull)b3[0], (Ull)cofs, MSK_W1, (Ull)b[0], M2, 0, 0, (Ull)NULL, M2);             /* stage#1 2KB */
/*dup load*/mop(OP_LDWR, 1, &BR[1][2][1],  (Ull)a[0][CHIP],  (Ull)rofs, MSK_W1, (Ull)a0[CHIP], L*RMGRP, 0, 0, (Ull)NULL, L*RMGRP); /* stage#1 16KB */
            exe(OP_FML, &AR[2][0], BR[1][0][1], EXP_H3210,  BR[1][2][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#2 */
            exe(OP_FML, &AR[2][1], BR[1][0][0], EXP_H3210,  BR[1][2][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#2 */
            exe(OP_FML, &AR[2][2], BR[1][1][1], EXP_H3210,  BR[1][2][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#2 */
            exe(OP_FML, &AR[2][3], BR[1][1][0], EXP_H3210,  BR[1][2][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#2 */

            sgemm00_core1( 2,  1,  3);
            sgemm00_core1( 3,  2,  4);
            sgemm00_core1( 4,  3,  5);
            sgemm00_core1( 5,  4,  6);
            sgemm00_core1( 6,  5,  7);
            sgemm00_core1( 7,  6,  8);
            sgemm00_core1( 8,  7,  9);
            sgemm00_core1( 9,  8, 10);
            sgemm00_core1(10,  9, 11);
            sgemm00_core1(11, 10, 12);
            sgemm00_core1(12, 11, 13);
            sgemm00_core1(13, 12, 14);
            sgemm00_core1(14, 13, 15);
            sgemm00_core1(15, 14, 16);
            sgemm00_core1(16, 15, 17);
            sgemm00_core1(17, 16, 18);
            sgemm00_core1(18, 17, 19);
            sgemm00_core1(19, 18, 20);
            sgemm00_core1(20, 19, 21);
            sgemm00_core1(21, 20, 22);
            sgemm00_core1(22, 21, 23);
            sgemm00_core1(23, 22, 24);
                :
            sgemm00_core1(59, 58, 60);
            sgemm00_core1(60, 59, 61); /* H=60 */
            /****final*****/
            sgemm00_final(61,     62);
      } } }
//EMAX5A end
  } }
//EMAX5A drain_dirty_lmm
}
\end{verbatim}
\end{screen}

\clearpage

\subsection{逆行列(1/3)}

\shabox{
\leftline{cent\% make -f Makefile-csim.emax6+dma inv-csim.emax6+dma clean}
\leftline{cent\% ../../src/csim/csim -x inv-csim.emax6+dma}
}

\shabox{
\leftline{zynq\% make -f Makefile-zynq.emax6+dma inv-zynq.emax6+dma clean}
\leftline{zynq\% ./inv-zynq.emax6+dma}
}

\begin{figure}[htbp]
\center
\includegraphics[angle=270,origin=b,width=0.80\textwidth]{inv.eps}
\caption{Inverse matrix}
\end{figure}

512x512の逆行列計算（LU分解）である．一度のバースト演算により8行分を計算す
る．ステンシル計算ではなくmapdist=0である．

\begin{screen}
\tiny
\begin{verbatim}
  /* LU分解 */
  for (i=0; i<M+1; i++)
    p[i] = i;
  for (i=0; i<M; i++) {
    pmax = 0.0;
    k = -1;
    for (j=i; j<M; j++) {
      if (pmax < fabsf(A[p[j]*M+i])) {
        pmax = fabsf(A[p[j]*M+i]);
        k = j;
      }
    }
    if (k == -1) {
      fprintf(stderr, "can't solve\n");
      exit(1);
    }
    j = p[k]; p[k] = p[i]; p[i] = j;
    A[p[i]*M+i] = 1.0/A[p[i]*M+i];
    for (j=i+1; j<M; j++) {
      A[p[j]*M+i] *= A[p[i]*M+i];
      for (k=i+1; k<M; k++)
        A[p[j]*M+k] -= A[p[j]*M+i]*A[p[i]*M+k];
    }
  }
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
  /* LU分解 */
  for (i=0; i<M+1; i++)
    p[i] = i;
  for (i=0; i<M; i++) { /* 列方向 */
    pmax = 0.0;
    k = -1;
    for (j=i; j<M; j++) { /* 行方向に探索 */
      if (pmax < fabsf(A[p[j]*M+i])) {
        pmax = fabsf(A[p[j]*M+i]);
        k = j;
      }
    }
    if (k == -1) {
      fprintf(stderr, "can't solve\n");
      exit(1);
    }
    j = p[k]; p[k] = p[i]; p[i] = j;
    A[p[i]*M+i] = 1.0/A[p[i]*M+i];
    for (j=i+1; j<M; j++) /* 行方向 */
      A[p[j]*M+i] *= A[p[i]*M+i];
    for (j=i+1; j<M; j+=NCHIP*H) { /* 行方向 */
      /********************************************/
      for (CHIP=0; CHIP<NCHIP; CHIP++) {
        for (k=0; k<M-(i+1); k++) { /* 最内列方向 */
          for (h=0; h<H; h++) { /* vertical (parallel) execution */
            if (j+h*NCHIP+CHIP<M) A[p[j+h*NCHIP+CHIP]*M+i+1+k] -= A[p[j+h*NCHIP+CHIP]*M+i]*A[p[i]*M+i+1+k];
                                                     /* 後続の逆行列と異なり,accumurateではなく要素毎の単独減算の繰返し */
                                                     /* const:A[p[j]][0] * LMM A[p[  0]][*] */
                                                     /*        ↓                           */
            /*   v A[p[j]*M+i]         */            /*   LMM A[p[j>0]][*] accumulate (column方向にj,j+1,..,479のため依存無) */
            /***************************/
            /* + - - - - - - - - - - - */ /* A[p[i]] 先頭行       */ /* 先頭行はi更新まで再利用可能 */
            /* | * > > > > > > > > > > */ /* A[p[j]] 次行から引く */ /* 1行をLMMに写像 */
            /* | v + - - - - - - - - - */
            /* | v | * > > > > > > > > */ /* M/60を収容してi更新までj+=60を繰り返す */
            /* | v | v + - - - - - - - */ /* 行番号比較とcstによる端数制御 */
            /* | v | v - + - - - - - - */ /* + CHIP#1 h=0 */
            /* | v | v - - + - - - - - */ /* + CHIP#0 h=1 */
            /* | v | v - - - + - - - - */ /* + CHIP#1 h=1 */
            /* | v | v - - - - + - - - */ /* + CHIP#0 h=2 */
            /* | v | v - - - - - + - - */ /* + CHIP#1 h=2 */
            /* | v | v - - - - - - + - */ /* + CHIP#0 h=3 */
            /* | v | v - - - - - - - + */ /* + CHIP#1 h=3 */
            /***************************/ /* 最大60行まで写像可能 */
          }
        }
      }
      /********************************************/
    }
  }
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
  /* LU分解 */
  for (i=0; i<M+1; i++)
    p[i] = i;
  for (i=0; i<M; i++) { /* 列方向 */
    pmax = 0.0;
    k = -1;
    for (j=i; j<M; j++) { /* 行方向に探索 */
      if (pmax < fabsf(A[j*M+i])) {
        pmax = fabsf(A[j*M+i]);
        k = j;
      }
    }
    if (k == -1) {
      fprintf(stderr, "can't solve\n");
      exit(1);
    }
    j = p[k]; p[k] = p[i]; p[i] = j;
    for (j=0; j<M; j++) { /* real pivotting */            /*★*/
      tmp = A[k*M+j]; A[k*M+j] = A[i*M+j]; A[i*M+j] = tmp;/*★*/
    }                                                     /*★*/
    A[i*M+i] = 1.0/A[i*M+i];                              /*★*/
    for (j=i+1; j<M; j++) /* 行方向 */
      A[j*M+i] *= A[i*M+i];

    Uint *top  = &A[i*M+i];
    Uint *topw = (Ull)top;
    Uint  len  = M-i;
    Uint  len2 = len+(RMGRP-1)*M;
    Uint  grp;
    /* FPGA実機でj-loopの最終(len=1)が動かないので,ついでにARMのほうが速そうなlenをARMで実行 2019/3/1 Nakashima */
    if (len < 16) { /* len<1でも正常なので性能最大化で決めてよい */
      for (j=i+1; j<M; j+=NCHIP*H*RMGRP) { /* 行方向 */
        for (CHIP=0; CHIP<NCHIP; CHIP++) {
          for (h=0; h<H; h++) { /* vertical (parallel) execution */
            for (grp=0; grp<RMGRP; grp++) {
              for (k=0; k<M-(i+1); k++) { /* 最内列方向 */
                if (j+h*NCHIP*RMGRP+CHIP*RMGRP+grp<M) A[(j+h*NCHIP*RMGRP+CHIP*RMGRP+grp)*M+i+1+k] -= A[(j+h*NCHIP*RMGRP+CHIP*RMGRP+grp)*M+i]*A[i*M+i+1+k];
    } } } } } }
    else {
    for (j=i+1; j<M; j+=NCHIP*H*RMGRP) { /* 行方向 */
      /********************************************/
      Uint  l00[NCHIP],  l01[NCHIP],  l02[NCHIP],  l03[NCHIP],  l04[NCHIP],  l05[NCHIP],  l06[NCHIP],  l07[NCHIP]; /* j<M-(h*NCHIP+CHIP) */
      Uint  l08[NCHIP],  l09[NCHIP],  l10[NCHIP],  l11[NCHIP],  l12[NCHIP],  l13[NCHIP],  l14[NCHIP],  l15[NCHIP]; /* j<M-(h*NCHIP+CHIP) */
      Uint *d00[NCHIP], *d01[NCHIP], *d02[NCHIP], *d03[NCHIP], *d04[NCHIP], *d05[NCHIP], *d06[NCHIP], *d07[NCHIP]; /* A[p[j+h*NCHIP+CHIP]*M+k] */
      Uint *d08[NCHIP], *d09[NCHIP], *d10[NCHIP], *d11[NCHIP], *d12[NCHIP], *d13[NCHIP], *d14[NCHIP], *d15[NCHIP]; /* A[p[j+h*NCHIP+CHIP]*M+k] */
      Uint *d00w[NCHIP],*d01w[NCHIP],*d02w[NCHIP],*d03w[NCHIP],*d04w[NCHIP],*d05w[NCHIP],*d06w[NCHIP],*d07w[NCHIP];/* A[p[j+h*NCHIP+CHIP]*M+k] */
      Uint *d08w[NCHIP],*d09w[NCHIP],*d10w[NCHIP],*d11w[NCHIP],*d12w[NCHIP],*d13w[NCHIP],*d14w[NCHIP],*d15w[NCHIP];/* A[p[j+h*NCHIP+CHIP]*M+k] */
      for (CHIP=0; CHIP<NCHIP; CHIP++) { /* output channels are parallelized by multi-chip (OC/#chip) */
        l00[CHIP]=(j+ 0*NCHIP*RMGRP+CHIP*RMGRP<M)?(j+ 0*NCHIP*RMGRP+CHIP*RMGRP):M;l01[CHIP]=(j+ 1*NCHIP*RMGRP+CHIP*RMGRP<M)?(j+ 1*NCHIP*RMGRP+CHIP*RMGRP):M;
                :
        l14[CHIP]=(j+14*NCHIP*RMGRP+CHIP*RMGRP<M)?(j+14*NCHIP*RMGRP+CHIP*RMGRP):M;l15[CHIP]=(j+15*NCHIP*RMGRP+CHIP*RMGRP<M)?(j+15*NCHIP*RMGRP+CHIP*RMGRP):M;
        d00[CHIP] = &A[l00[CHIP]*M+i];   d01[CHIP] = &A[l01[CHIP]*M+i];
                :
        d14[CHIP] = &A[l14[CHIP]*M+i];   d15[CHIP] = &A[l15[CHIP]*M+i];
        d00w[CHIP]= (Ull)d00[CHIP];      d01w[CHIP]= (Ull)d01[CHIP];
                :
        d14w[CHIP]= (Ull)d14[CHIP];      d15w[CHIP]= (Ull)d15[CHIP];
      }
//EMAX5A begin inv_x1 mapdist=0
/*3*/ for (CHIP=0; CHIP<NCHIP; CHIP++) {
  /*2*/ for (INIT1=1,LOOP1=RMGRP,rofs=0-M*4; LOOP1--; INIT1=0) {                             /* stage#0 *//* mapped to FOR() on BR[63][1][0] */
    /*1*/ for (INIT0=1,LOOP0=M-(i+1),cofs=0; LOOP0--; INIT0=0) { /* stage#0 *//* mapped to FOR() on BR[63][0][0] */
            exe(OP_ADD, &cofs, INIT0?cofs:cofs, EXP_H3210, 4LL, EXP_H3210, 0LL, EXP_H3210, OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL); /* stage#0 */
            exe(OP_ADD, &rofs, rofs, EXP_H3210, INIT0?M*4:0, EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);                     /* stage#0 */
            exe(OP_ADD, &oofs, rofs, EXP_H3210, cofs, EXP_H3210, 0LL, EXP_H3210, OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL);           /* stage#1 */
            exe(OP_CMP_LT,   &cc0,         l00[CHIP],   EXP_H3210, M,         EXP_H3210, 0LL,         EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#1              LD
            mop(OP_LDWR,  1, &BR[2][2][1], top,         cofs, MSK_W0, topw,       len, 0, 0, NULL, len);  /* A[p[i]*M+k]                       stage#2              |
            mop(OP_LDWR,  1, &BR[2][0][1], d00[CHIP],   oofs, MSK_W0, d00w[CHIP], len2,0, 1, NULL, len2); /* A[p[j+h*NCHIP+CHIP]*M+k]          stage#2  +->         |
            mop(OP_LDWR,  1, &BR[2][1][1], d00[CHIP],   rofs, MSK_W0, d00w[CHIP], len2,0, 1, NULL, len2); /* A[p[j+h*NCHIP+CHIP]*M+k]          stage#2  +->         |
            exe(OP_FMS,      &AR[2][0],    BR[2][0][1], EXP_H3210, BR[2][1][1], EXP_H3210, BR[2][2][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0); /* stage#2  |   ■■■  |
            cex(OP_CEXE,     &ex0,   0, 0, 0, cc0, 0xaaaa);                                                                                 /* stage#2  |  AR[1]    |
            mop(OP_STWR,ex0, &AR[2][0],    oofs,   d00[CHIP], MSK_D0, d00w[CHIP], len2, 0, 1, NULL, len2);                                  /* stage#2  |    + ST   v
#if (H>1)                                                                                                                                   /*          *--------- BR[2]
            exe(OP_CMP_LT,   &cc0,         l01[CHIP],   EXP_H3210, M,         EXP_H3210, 0LL,         EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#2              LD
            mop(OP_LDWR,  1, &BR[3][2][1], top,         cofs, MSK_W0, topw,       len, 0, 0, NULL, len);  /* A[p[i]*M+k]                       stage#3              |
            mop(OP_LDWR,  1, &BR[3][0][1], d01[CHIP],   oofs, MSK_W0, d01w[CHIP], len2,0, 1, NULL, len2); /* A[p[j+h*NCHIP+CHIP]*M+k]          stage#3  +->         |
            mop(OP_LDWR,  1, &BR[3][1][1], d01[CHIP],   rofs, MSK_W0, d01w[CHIP], len2,0, 1, NULL, len2); /* A[p[j+h*NCHIP+CHIP]*M+k]          stage#3  +->         |
            exe(OP_FMS,      &AR[3][0],    BR[3][0][1], EXP_H3210, BR[3][1][1], EXP_H3210, BR[3][2][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0); /* stage#3  |   ■■■  |
            cex(OP_CEXE,     &ex0,   0, 0, 0, cc0, 0xaaaa);                                                                                 /* stage#3  |  AR[2]    |
            mop(OP_STWR,ex0, &AR[3][0],    oofs,   d01[CHIP], MSK_D0, d01w[CHIP], len2, 0, 1, NULL, len2);                                  /* stage#3  |    + ST   v
                :
#if (H>12)                                                                                                                                  /*          *--------- BR[13]
            exe(OP_CMP_LT,   &cc0,         l12[CHIP],   EXP_H3210, M,         EXP_H3210, 0LL,         EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#13             LD
            mop(OP_LDWR,  1, &BR[14][2][1],top,         cofs, MSK_W0, topw,       len, 0, 0, NULL, len);  /* A[p[i]*M+k] stage#1               stage#14             |
            mop(OP_LDWR,  1, &BR[14][0][1],d12[CHIP],   oofs, MSK_W0, d12w[CHIP], len2,0, 1, NULL, len2); /* A[p[j+h*NCHIP+CHIP]*M+k]          stage#14 +->         |
            mop(OP_LDWR,  1, &BR[14][1][1],d12[CHIP],   rofs, MSK_W0, d12w[CHIP], len2,0, 1, NULL, len2); /* A[p[j+h*NCHIP+CHIP]*M+k]          stage#14 +->         |
            exe(OP_FMS,      &AR[14][0],   BR[14][0][1],EXP_H3210, BR[14][1][1], EXP_H3210, BR[14][2][1],EXP_H3210, OP_NOP, 0LL, OP_NOP, 0);/* stage#14 |   ■■■  |
            cex(OP_CEXE,     &ex0,   0, 0, 0, cc0, 0xaaaa);                                                                                 /* stage#14 |  AR[13]   |
            mop(OP_STWR,ex0, &AR[14][0],   oofs,   d12[CHIP], MSK_D0, d12w[CHIP], len2, 0, 1, NULL, len2);                                  /* stage#14 |    + ST   v
#if (H>13)                                                                                                                                  /*          *--------- BR[14]
            exe(OP_CMP_LT,   &cc0,         l13[CHIP],   EXP_H3210, M,         EXP_H3210, 0LL,         EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#14             LD
            mop(OP_LDWR,  1, &BR[15][2][1],top,         cofs, MSK_W0, topw,       len, 0, 0, NULL, len);  /* A[p[i]*M+k] stage#1               stage#15             |
            mop(OP_LDWR,  1, &BR[15][0][1],d13[CHIP],   oofs, MSK_W0, d13w[CHIP], len2,0, 1, NULL, len2); /* A[p[j+h*NCHIP+CHIP]*M+k]          stage#15 +->         |
            mop(OP_LDWR,  1, &BR[15][1][1],d13[CHIP],   rofs, MSK_W0, d13w[CHIP], len2,0, 1, NULL, len2); /* A[p[j+h*NCHIP+CHIP]*M+k]          stage#15 +->         |
            exe(OP_FMS,      &AR[15][0],   BR[15][0][1],EXP_H3210, BR[15][1][1], EXP_H3210, BR[15][2][1],EXP_H3210, OP_NOP, 0LL, OP_NOP, 0);/* stage#15 |   ■■■  |
            cex(OP_CEXE,     &ex0,   0, 0, 0, cc0, 0xaaaa);                                                                                 /* stage#15 |  AR[14]   |
            mop(OP_STWR,ex0, &AR[15][0],   oofs,   d13[CHIP], MSK_D0, d13w[CHIP], len2, 0, 1, NULL, len2);                                  /* stage#15 |    + ST   v
#if (H>14)                                                                                                                                  /*          *--------- BR[15]
            exe(OP_CMP_LT,   &cc0,         l14[CHIP],   EXP_H3210, M,         EXP_H3210, 0LL,         EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#15             LD
            mop(OP_LDWR,  1, &BR[16][2][1],top,         cofs, MSK_W0, topw,       len, 0, 0, NULL, len);  /* A[p[i]*M+k] stage#1               stage#16             |
            mop(OP_LDWR,  1, &BR[16][0][1],d14[CHIP],   oofs, MSK_W0, d14w[CHIP], len2,0, 1, NULL, len2); /* A[p[j+h*NCHIP+CHIP]*M+k]          stage#16 +->         |
            mop(OP_LDWR,  1, &BR[16][1][1],d14[CHIP],   rofs, MSK_W0, d14w[CHIP], len2,0, 1, NULL, len2); /* A[p[j+h*NCHIP+CHIP]*M+k]          stage#16 +->         |
            exe(OP_FMS,      &AR[16][0],   BR[16][0][1],EXP_H3210, BR[16][1][1], EXP_H3210, BR[16][2][1],EXP_H3210, OP_NOP, 0LL, OP_NOP, 0);/* stage#16 |   ■■■  |
            cex(OP_CEXE,     &ex0,   0, 0, 0, cc0, 0xaaaa);                                                                                 /* stage#16 |  AR[15]   |
            mop(OP_STWR,ex0, &AR[16][0],   oofs,   d14[CHIP], MSK_D0, d14w[CHIP], len2, 0, 1, NULL, len2);                                  /* stage#16 |    + ST   v
#if (H>15)                                                                                                                                  /*          *--------- BR[16]
            exe(OP_CMP_LT,   &cc0,         l15[CHIP],   EXP_H3210, M,         EXP_H3210, 0LL,         EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#16             LD
            mop(OP_LDWR,  1, &BR[17][2][1],top,         cofs, MSK_W0, topw,       len, 0, 0, NULL, len);  /* A[p[i]*M+k] stage#1               stage#17             |
            mop(OP_LDWR,  1, &BR[17][0][1],d15[CHIP],   oofs, MSK_W0, d15w[CHIP], len2,0, 1, NULL, len2); /* A[p[j+h*NCHIP+CHIP]*M+k]          stage#17 +->         |
            mop(OP_LDWR,  1, &BR[17][1][1],d15[CHIP],   rofs, MSK_W0, d15w[CHIP], len2,0, 1, NULL, len2); /* A[p[j+h*NCHIP+CHIP]*M+k]          stage#17 +->         |
            exe(OP_FMS,      &AR[17][0],   BR[17][0][1],EXP_H3210, BR[17][1][1], EXP_H3210, BR[17][2][1],EXP_H3210, OP_NOP, 0LL, OP_NOP, 0);/* stage#17 |   ■■■  |
            cex(OP_CEXE,     &ex0,   0, 0, 0, cc0, 0xaaaa);                                                                                 /* stage#17 |  AR[16]   |
            mop(OP_STWR,ex0, &AR[17][0],   oofs,   d15[CHIP], MSK_D0, d15w[CHIP], len2, 0, 1, NULL, len2);                                  /* stage#17 |    + ST   v
                                                                                                                                            /*          *--------- BR[17]
#endif
      } } }
//EMAX5A end
      /********************************************/
    } /* j-loop */
//EMAX5A drain_dirty_lmm
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\epsfile{file=inv+rmm-inv_x1-emax6.eps,width=1.00\textwidth}
\caption{逆行列(1/3)}
\end{figure}

\clearpage

\subsection{逆行列(2/3)}

512x512の逆行列計算（前進消去）である．一度のバースト演算により8行分を計算す
る．ステンシル計算ではなくmapdist=0である．

\begin{screen}
\tiny
\begin{verbatim}
  /* 逆行列前半 */
  for (i=0; i<M; i++) {
    for (j=0; j<M; j++)
      b[p[j]] = (i==j)?1.0:0.0;
    /*for (j=1; j<M; j++) { *//*通常の連立一時方程式の場合*/
    for (j=i+1; j<M; j++) { /* 逆行列(b[]=E)の場合,k<iではb[]==0なのでj=i+1から開始 */
      /*for (k=0; k<j; k++) *//*通常の連立一時方程式の場合*/
      for (k=i; k<j; k++) /* 逆行列(b[]=E)の場合,k<iではb[]==0なのでk=iから開始 */
        b[p[j]] -= A[p[j]*M+k]*b[p[k]];
    }
  }
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
  /* 逆行列求める */
  for (i=0; i<M; i++) { /* 列方向 */
    for (j=0; j<M; j++) /* 行方向 */
      b[i*M+j] = (i==j)?1.0:0.0;
  }
  for (i=0; i<M; i+=NCHIP*H) { /* 列方向 */
    for (j=1; j<M; j++) { /* 行方向 */
      /********************************************/
      for (CHIP=0; CHIP<NCHIP; CHIP++) {
        for (k=0; k<j; k++) { /* 最内列方向 */
          for (h=0; h<H; h++) { /* vertical (parallel) execution */
            b[(i+CHIP*H+h)*M+j] -= A[p[j]*M+k]*b[(i+CHIP*H+h)*M+k];
                                        /* b[*]を縦に配置する場合,Aも縦配置. jが列方向に対応するが列方向の移動でkも長くなる */
                                        /* 可変長kをH方向に展開写像するのは難しい.kはread-modify-writeの回転数に写像するしかない */
                                        /* b[*]とA[j][*]が同一LMMに入る前提 最大64KB/4/2=各8K要素,b[*]をいかに動かさないか */
                                        /* 回転数jを一斉適用するには,iをWxH方向に展開するのが自然 */
              /*           ↓★A[p[j]][*]をbroadcast可能 各A[p[j]][*]はp[j]が不連続なので1K要素まで収容.つまり二重ループ展開は無理 */
              /* +-----------------------------------+     +------+ +------+ +------+ */
              /* b[ 3][j]-=A[p[j]][0:j-1] b[ 3][0:j-1]     b[ 2][*] b[ 1][*] b[ 0][*] */
              /*                                                                      */
              /* b[ 7][j]-=A[p[j]][0:j-1] b[ 7][0:j-1]     b[ 6][*] b[ 5][*] b[ 4][*] */
              /* b[59][j]-=A[p[j]][0:j-1] b[59][0:j-1]     b[58][*] b[57][*] b[56][*] */
          }
        }
      }
      /********************************************/
    }
  }
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
  /* 逆行列前半 */
  for (i=0; i<M; i++) { /* 列方向 */
    for (j=0; j<M; j++) /* 行方向 */
      b[i*M+j] = (i==j)?1.0:0.0;
  }
  for (i=0; i<M; i+=NCHIP*H) { /* 列方向 */
    /*for (j=1; j<M; j++) { *//*通常の連立一時方程式の場合*/
    for (j=i+1; j<M; j++) { /* 逆行列(b[]=E)の場合,k<iではb[]==0なのでj=i+1から開始 */
      Uint *top  = &A[p[j]*M+i];                                     /* A[p[j]*M+k] */
      Uint *topw = (Ull)top;
      /*Uint  len = (j+1)/2;*/
      Uint  len = j-i;/* bが単位行列の場合,k<iではb[]==0なのでk=iから開始 */
      /********************************************/
      if (len < 2) { /* len<1でも正常なので性能最大化で決めてよい */
        for (CHIP=0; CHIP<NCHIP; CHIP++) {
        /*for (k=0; k<j; k++) { *//*通常の連立一時方程式の場合*/
          for (k=i; k<j; k++) { /* 逆行列(b[]=E)の場合,k<iではb[]==0なのでk=iから開始 */
            for (h=0; h<H; h++) { /* vertical (parallel) execution */
              b[(i+CHIP*H+h)*M+j] -= A[p[j]*M+k]*b[(i+CHIP*H+h)*M+k];
            }
          }
        }
      }
      else {
      Uint  jc = j-i;
      Ull   Ajk; /* k=0...j-1 */
      Ull   b000, b001;
      Uint  l000[NCHIP],  l010[NCHIP],  l020[NCHIP],  l030[NCHIP],  l040[NCHIP],  l050[NCHIP],  l060[NCHIP],  l070[NCHIP];  /* (i+CHIP*W*H+h*W+w)        */
      Uint  l080[NCHIP],  l090[NCHIP],  l100[NCHIP],  l110[NCHIP],  l120[NCHIP],  l130[NCHIP],  l140[NCHIP],  l150[NCHIP];  /* (i+CHIP*W*H+h*W+w)        */
      Uint *t000[NCHIP], *t010[NCHIP], *t020[NCHIP], *t030[NCHIP], *t040[NCHIP], *t050[NCHIP], *t060[NCHIP], *t070[NCHIP];  /* b[(i+CHIP*W*H+h*W+w)*M+k] */
      Uint *t080[NCHIP], *t090[NCHIP], *t100[NCHIP], *t110[NCHIP], *t120[NCHIP], *t130[NCHIP], *t140[NCHIP], *t150[NCHIP];  /* b[(i+CHIP*W*H+h*W+w)*M+k] */
      Uint *t000w[NCHIP],*t010w[NCHIP],*t020w[NCHIP],*t030w[NCHIP],*t040w[NCHIP],*t050w[NCHIP],*t060w[NCHIP],*t070w[NCHIP]; /* b[(i+CHIP*W*H+h*W+w)*M+k] */
      Uint *t080w[NCHIP],*t090w[NCHIP],*t100w[NCHIP],*t110w[NCHIP],*t120w[NCHIP],*t130w[NCHIP],*t140w[NCHIP],*t150w[NCHIP]; /* b[(i+CHIP*W*H+h*W+w)*M+k] */
      Uint *d000[NCHIP], *d010[NCHIP], *d020[NCHIP], *d030[NCHIP], *d040[NCHIP], *d050[NCHIP], *d060[NCHIP], *d070[NCHIP];  /* b[(i+CHIP*W*H+h*W+w)*M+j] */
      Uint *d080[NCHIP], *d090[NCHIP], *d100[NCHIP], *d110[NCHIP], *d120[NCHIP], *d130[NCHIP], *d140[NCHIP], *d150[NCHIP];  /* b[(i+CHIP*W*H+h*W+w)*M+j] */
      Uint *d000w[NCHIP],*d010w[NCHIP],*d020w[NCHIP],*d030w[NCHIP],*d040w[NCHIP],*d050w[NCHIP],*d060w[NCHIP],*d070w[NCHIP]; /* b[(i+CHIP*W*H+h*W+w)*M+j] */
      Uint *d080w[NCHIP],*d090w[NCHIP],*d100w[NCHIP],*d110w[NCHIP],*d120w[NCHIP],*d130w[NCHIP],*d140w[NCHIP],*d150w[NCHIP]; /* b[(i+CHIP*W*H+h*W+w)*M+j] */
      for (CHIP=0; CHIP<NCHIP; CHIP++) { /* output channels are parallelized by multi-chip (OC/#chip) */
        l000[CHIP] = (i+CHIP*H+ 0+0)*M;         l010[CHIP] = (i+CHIP*H+ 1+0)*M;         l020[CHIP] = (i+CHIP*H+ 2+0)*M;         l030[CHIP] = (i+CHIP*H+ 3+0)*M;
              :
        l120[CHIP] = (i+CHIP*H+12+0)*M;         l130[CHIP] = (i+CHIP*H+13+0)*M;         l140[CHIP] = (i+CHIP*H+14+0)*M;         l150[CHIP] = (i+CHIP*H+15+0)*M;
        t000[CHIP] = &b[l000[CHIP]+i]; t010[CHIP] = &b[l010[CHIP]+i];
              :
        t140[CHIP] = &b[l140[CHIP]+i]; t150[CHIP] = &b[l150[CHIP]+i];
        t000w[CHIP]= (Ull)t000[CHIP];  t010w[CHIP]= (Ull)t010[CHIP];
              :
        t140w[CHIP]= (Ull)t140[CHIP];  t150w[CHIP]= (Ull)t150[CHIP];
        d000[CHIP] = &b[l000[CHIP]+j]; d010[CHIP] = &b[l010[CHIP]+j];
              :
        d140[CHIP] = &b[l140[CHIP]+j]; d150[CHIP] = &b[l150[CHIP]+j];
        d000w[CHIP]= (Ull)d000[CHIP];  d010w[CHIP]= (Ull)d010[CHIP];
              :
        d140w[CHIP]= (Ull)d140[CHIP];  d150w[CHIP]= (Ull)d150[CHIP];
      }
//EMAX5A begin inv_x2 mapdist=0
/*2*/ for (CHIP=0; CHIP<NCHIP; CHIP++) {
  /*1*/ for (INIT0=1,LOOP0=jc,cofs=0-4; LOOP0--; INIT0=0) { /* stage#0 *//* mapped to FOR() on BR[63][0][0] */
          exe(OP_ADD, &cofs, cofs, EXP_H3210, 4LL, EXP_H3210, 0LL, EXP_H3210, OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL); /* stage#0 */
          mop(OP_LDWR,  1, &Ajk,         top,          cofs, MSK_W0, topw,        len, 0, 0, NULL, len);  /* A[p[j]*M+k]              */
          mop(OP_LDWR,  1, &BR[1][3][1], t000[CHIP],   cofs, MSK_W0, t000w[CHIP], len, 0, 1, NULL, len);  /* b[(i+CHIP*W*H+h*W+0)*M+k]*//* stage#1.3 +->xxx     LD */
          mop(OP_LDWR,  1, &b000,        d000[CHIP],   0,    MSK_W0, d000w[CHIP], 1,   0, 1, NULL, 1);    /* b[(i+CHIP*W*H+h*W+0)*M+j]*//* stage#2.0 |   ■■■ |  */
          exe(OP_FMS,      &b000,        b000,         EXP_H3210, Ajk, EXP_H3210, BR[1][3][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);    /* stage#2.0 +- xxx+ST  v  */
          mop(OP_STWR,  1, &b000,        0,      d000[CHIP], MSK_D0, d000w[CHIP], 1,   0, 1, NULL, 1);                                  /* stage#2.0 +-------- xxx */
#if (H>1)
          mop(OP_LDWR,  1, &BR[2][3][1], t010[CHIP],   cofs, MSK_W0, t010w[CHIP], len, 0, 1, NULL, len);  /* b[(i+CHIP*W*H+h*W+1)*M+k]*//* stage#2.3 +->xxx     LD */
          mop(OP_LDWR,  1, &b000,        d010[CHIP],   0,    MSK_W0, d010w[CHIP], 1,   0, 1, NULL, 1);    /* b[(i+CHIP*W*H+h*W+0)*M+j]*//* stage#3.0 |   ■■■ |  */
          exe(OP_FMS,      &b000,        b000,         EXP_H3210, Ajk, EXP_H3210, BR[2][3][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);    /* stage#3.0 +- xxx+ST  v  */
          mop(OP_STWR,  1, &b000,        0,      d010[CHIP], MSK_D0, d010w[CHIP], 1,   0, 1, NULL, 1);                                  /* stage#3.0 +-------- xxx */
                :
#if (H>8)
          mop(OP_LDWR,  1, &BR[9][3][1], t080[CHIP],   cofs, MSK_W0, t080w[CHIP], len, 0, 1, NULL, len);  /* b[(i+CHIP*W*H+h*W+0)*M+k]*//* stage#9.3 +->xxx     LD */
          mop(OP_LDWR,  1, &b000,        d080[CHIP],   0,    MSK_W0, d080w[CHIP], 1,   0, 1, NULL, 1);    /* b[(i+CHIP*W*H+h*W+0)*M+j]*//* stage#10.0|   ■■■ |  */
          exe(OP_FMS,      &b000,        b000,         EXP_H3210, Ajk, EXP_H3210, BR[9][3][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);    /* stage#10.0+- xxx+ST  v  */
          mop(OP_STWR,  1, &b000,        0,      d080[CHIP], MSK_D0, d080w[CHIP], 1,   0, 1, NULL, 1);                                  /* stage#10.0+-------- xxx */
#if (H>9)
          mop(OP_LDWR,  1, &BR[10][3][1],t090[CHIP],   cofs, MSK_W0, t090w[CHIP], len, 0, 1, NULL, len);  /* b[(i+CHIP*W*H+h*W+0)*M+k]*//* stage#10.3+->xxx     LD */
          mop(OP_LDWR,  1, &b000,        d090[CHIP],   0,    MSK_W0, d090w[CHIP], 1,   0, 1, NULL, 1);    /* b[(i+CHIP*W*H+h*W+0)*M+j]*//* stage#11.0|   ■■■ |  */
          exe(OP_FMS,      &b000,        b000,         EXP_H3210, Ajk, EXP_H3210, BR[10][3][1],EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);    /* stage#11.0+- xxx+ST  v  */
          mop(OP_STWR,  1, &b000,        0,      d090[CHIP], MSK_D0, d090w[CHIP], 1,   0, 1, NULL, 1);                                  /* stage#11.0+-------- xxx */
#if (H>10)
          mop(OP_LDWR,  1, &BR[11][3][1],t100[CHIP],   cofs, MSK_W0, t100w[CHIP], len, 0, 1, NULL, len);  /* b[(i+CHIP*W*H+h*W+0)*M+k]*//* stage#11.3+->xxx     LD */
          mop(OP_LDWR,  1, &b000,        d100[CHIP],   0,    MSK_W0, d100w[CHIP], 1,   0, 1, NULL, 1);    /* b[(i+CHIP*W*H+h*W+0)*M+j]*//* stage#12.0|   ■■■ |  */
          exe(OP_FMS,      &b000,        b000,         EXP_H3210, Ajk, EXP_H3210, BR[11][3][1],EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);    /* stage#12.0+- xxx+ST  v  */
          mop(OP_STWR,  1, &b000,        0,      d100[CHIP], MSK_D0, d100w[CHIP], 1,   0, 1, NULL, 1);                                  /* stage#12.0+-------- xxx */
#if (H>11)
          mop(OP_LDWR,  1, &BR[12][3][1],t110[CHIP],   cofs, MSK_W0, t110w[CHIP], len, 0, 1, NULL, len);  /* b[(i+CHIP*W*H+h*W+0)*M+k]*//* stage#12.3+->xxx     LD */
          mop(OP_LDWR,  1, &b000,        d110[CHIP],   0,    MSK_W0, d110w[CHIP], 1,   0, 1, NULL, 1);    /* b[(i+CHIP*W*H+h*W+0)*M+j]*//* stage#13.0|   ■■■ |  */
          exe(OP_FMS,      &b000,        b000,         EXP_H3210, Ajk, EXP_H3210, BR[12][3][1],EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);    /* stage#13.0+- xxx+ST  v  */
          mop(OP_STWR,  1, &b000,        0,      d110[CHIP], MSK_D0, d110w[CHIP], 1,   0, 1, NULL, 1);                                  /* stage#13.0+-------- xxx */
#if (H>12)
          mop(OP_LDWR,  1, &BR[13][3][1],t120[CHIP],   cofs, MSK_W0, t120w[CHIP], len, 0, 1, NULL, len);  /* b[(i+CHIP*W*H+h*W+0)*M+k]*//* stage#13.3+->xxx     LD */
          mop(OP_LDWR,  1, &b000,        d120[CHIP],   0,    MSK_W0, d120w[CHIP], 1,   0, 1, NULL, 1);    /* b[(i+CHIP*W*H+h*W+0)*M+j]*//* stage#14.0|   ■■■ |  */
          exe(OP_FMS,      &b000,        b000,         EXP_H3210, Ajk, EXP_H3210, BR[13][3][1],EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);    /* stage#14.0+- xxx+ST  v  */
          mop(OP_STWR,  1, &b000,        0,      d120[CHIP], MSK_D0, d120w[CHIP], 1,   0, 1, NULL, 1);                                  /* stage#14.0+-------- xxx */
#if (H>13)
          mop(OP_LDWR,  1, &BR[14][3][1],t130[CHIP],   cofs, MSK_W0, t130w[CHIP], len, 0, 1, NULL, len);  /* b[(i+CHIP*W*H+h*W+0)*M+k]*//* stage#14.3+->xxx     LD */
          mop(OP_LDWR,  1, &b000,        d130[CHIP],   0,    MSK_W0, d130w[CHIP], 1,   0, 1, NULL, 1);    /* b[(i+CHIP*W*H+h*W+0)*M+j]*//* stage#15.0|   ■■■ |  */
          exe(OP_FMS,      &b000,        b000,         EXP_H3210, Ajk, EXP_H3210, BR[14][3][1],EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);    /* stage#15.0+- xxx+ST  v  */
          mop(OP_STWR,  1, &b000,        0,      d130[CHIP], MSK_D0, d130w[CHIP], 1,   0, 1, NULL, 1);                                  /* stage#15.0+-------- xxx */
#if (H>14)
          mop(OP_LDWR,  1, &BR[15][3][1],t140[CHIP],   cofs, MSK_W0, t140w[CHIP], len, 0, 1, NULL, len);  /* b[(i+CHIP*W*H+h*W+0)*M+k]*//* stage#15.3+->xxx     LD */
          mop(OP_LDWR,  1, &b000,        d140[CHIP],   0,    MSK_W0, d140w[CHIP], 1,   0, 1, NULL, 1);    /* b[(i+CHIP*W*H+h*W+0)*M+j]*//* stage#16.0|   ■■■ |  */
          exe(OP_FMS,      &b000,        b000,         EXP_H3210, Ajk, EXP_H3210, BR[15][3][1],EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);    /* stage#16.0+- xxx+ST  v  */
          mop(OP_STWR,  1, &b000,        0,      d140[CHIP], MSK_D0, d140w[CHIP], 1,   0, 1, NULL, 1);                                  /* stage#16.0+-------- xxx */
#if (H>15)
          mop(OP_LDWR,  1, &BR[16][3][1],t150[CHIP],   cofs, MSK_W0, t150w[CHIP], len, 0, 1, NULL, len);  /* b[(i+CHIP*W*H+h*W+0)*M+k]*//* stage#16.3+->xxx     LD */
          mop(OP_LDWR,  1, &b000,        d150[CHIP],   0,    MSK_W0, d150w[CHIP], 1,   0, 1, NULL, 1);    /* b[(i+CHIP*W*H+h*W+0)*M+j]*//* stage#17.0|   ■■■ |  */
          exe(OP_FMS,      &b000,        b000,         EXP_H3210, Ajk, EXP_H3210, BR[16][3][1],EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);    /* stage#17.0+- xxx+ST  v  */
          mop(OP_STWR,  1, &b000,        0,      d150[CHIP], MSK_D0, d150w[CHIP], 1,   0, 1, NULL, 1);                                  /* stage#17.0+-------- xxx */
#endif
        }
      }
//EMAX5A end
//EMAX5A drain_dirty_lmm
      } /* else */
      /********************************************/
    } /* j-loop */
  }
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\epsfile{file=inv+rmm-inv_x2-emax6.eps,width=1.00\textwidth}
\caption{逆行列(2/3)}
\end{figure}

\clearpage

\subsection{逆行列(3/3)}

512x512の逆行列計算（後退代入）である．一度のバースト演算により8行分を計算す
る．ステンシル計算ではなくmapdist=0である．

\begin{screen}
\tiny
\begin{verbatim}
  /* 逆行列後半 */
  for (i=0; i<M; i++) {
    for (j=M-1; j>=0; j--) {
      for (k=M-1; k>j; k--)
        b[p[j]] -= A[p[j]*M+k]*x[k];
      inv0[j*M+p[i]] = x[j] = b[p[j]]*A[p[j]*M+j];
    }
  }
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
  for (i=0; i<M; i+=NCHIP*H) { /* 列方向 */
    for (j=M-1; j>=0; j--) { /* 行方向 */
      /********************************************/
      for (CHIP=0; CHIP<NCHIP; CHIP++) {
        for (k=M-1; k>j; k--) { /* 最内列方向 */
          for (h=0; h<H; h++) { /* vertical (parallel) execution */
            b[(i+CHIP*H+h)*M+j] -= A[p[j]*M+k]*x[(i+CHIP*H+h)*M+k];
                                            /* x[*]とA[j][*]が同一LMMに入る前提 最大64KB/4/2=各8K要素,x[*]をいかに動かさないか */
                                            /* 回転数jを一斉適用するには,iをWxH方向に展開するのが自然 */
            /*           ↓★A[p[j]][*]をbroadcast可能 各A[p[j]][*]はp[j]が不連続なので1K要素まで収容.つまり二重ループ展開は無理 */
            /* +-----------------------------------+     +------+ +------+ +------+ */
            /* b[ 3][j]-=A[p[j]][M-1:j+1] x[ 3][M-1:j+1] b[ 2][*] b[ 1][*] b[ 0][*] */
            /*                                                                      */
            /* b[ 7][j]-=A[p[j]][M-1:j+1] x[ 7][M-1:j+1] b[ 6][*] b[ 5][*] b[ 4][*] */
            /* b[59][j]-=A[p[j]][M-1:j+1] x[59][M-1:j+1] b[58][*] b[57][*] b[56][*] */
          }
        }
      }
      /********************************************/
      for (CHIP=0; CHIP<NCHIP; CHIP++) {
        for (h=0; h<H; h++) { /* vertical (parallel) execution */
          inv1[j*M+p[i+CHIP*H+h+w]] = x[(i+CHIP*H+h)*M+j] = A[p[j]*M+j]*b[(i+CHIP*H+h)*M+j]; /* PIOにてLMMのx[i*M+j]を直接更新 */
                                                                                             /* iはそのままで,jを切替え */
        }
      }
    }
  }
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
  /* 逆行列後半 */
  for (i=0; i<M; i+=NCHIP*H) { /* 列方向 */
    for (j=M-1; j>=0; j--) { /* 行方向 */
      if (j<M-1) {
        Uint *top  = &A[p[j]*M+j+1];                                  /* A[p[j]*M+k] */
        Uint *topw = (Ull)top;
        Uint  len = M-j-1;
        /********************************************/
        if (len < 2) { /* len<1でも正常なので性能最大化で決めてよい */
          for (CHIP=0; CHIP<NCHIP; CHIP++) {
            for (k=M-1; k>j; k--) { /* 最内列方向 */
              for (h=0; h<H; h++) { /* vertical (parallel) execution */
                b[(i+CHIP*H+h)*M+j] -= A[p[j]*M+k]*x[(i+CHIP*H+h)*M+k];
              }
            }
          }
        }
        else {
        Uint  jc = M-j-1;
        Ull   Ajk; /* k=j+1...M-1 */
        Ull   b000, b001;
        Uint  l000[NCHIP],  l010[NCHIP],  l020[NCHIP],  l030[NCHIP],  l040[NCHIP],  l050[NCHIP],  l060[NCHIP],  l070[NCHIP];  /* (i+CHIP*W*H+h*W+w)        */
        Uint  l080[NCHIP],  l090[NCHIP],  l100[NCHIP],  l110[NCHIP],  l120[NCHIP],  l130[NCHIP],  l140[NCHIP],  l150[NCHIP];  /* (i+CHIP*W*H+h*W+w)        */
        Uint *t000[NCHIP], *t010[NCHIP], *t020[NCHIP], *t030[NCHIP], *t040[NCHIP], *t050[NCHIP], *t060[NCHIP], *t070[NCHIP];  /* b[(i+CHIP*W*H+h*W+w)*M+k] */
        Uint *t080[NCHIP], *t090[NCHIP], *t100[NCHIP], *t110[NCHIP], *t120[NCHIP], *t130[NCHIP], *t140[NCHIP], *t150[NCHIP];  /* b[(i+CHIP*W*H+h*W+w)*M+k] */
        Uint *t000w[NCHIP],*t010w[NCHIP],*t020w[NCHIP],*t030w[NCHIP],*t040w[NCHIP],*t050w[NCHIP],*t060w[NCHIP],*t070w[NCHIP]; /* b[(i+CHIP*W*H+h*W+w)*M+k] */
        Uint *t080w[NCHIP],*t090w[NCHIP],*t100w[NCHIP],*t110w[NCHIP],*t120w[NCHIP],*t130w[NCHIP],*t140w[NCHIP],*t150w[NCHIP]; /* b[(i+CHIP*W*H+h*W+w)*M+k] */
        Uint *d000[NCHIP], *d010[NCHIP], *d020[NCHIP], *d030[NCHIP], *d040[NCHIP], *d050[NCHIP], *d060[NCHIP], *d070[NCHIP];  /* b[(i+CHIP*W*H+h*W+w)*M+j] */
        Uint *d080[NCHIP], *d090[NCHIP], *d100[NCHIP], *d110[NCHIP], *d120[NCHIP], *d130[NCHIP], *d140[NCHIP], *d150[NCHIP];  /* b[(i+CHIP*W*H+h*W+w)*M+j] */
        Uint *d000w[NCHIP],*d010w[NCHIP],*d020w[NCHIP],*d030w[NCHIP],*d040w[NCHIP],*d050w[NCHIP],*d060w[NCHIP],*d070w[NCHIP]; /* b[(i+CHIP*W*H+h*W+w)*M+j] */
        Uint *d080w[NCHIP],*d090w[NCHIP],*d100w[NCHIP],*d110w[NCHIP],*d120w[NCHIP],*d130w[NCHIP],*d140w[NCHIP],*d150w[NCHIP]; /* b[(i+CHIP*W*H+h*W+w)*M+j] */
        for (CHIP=0; CHIP<NCHIP; CHIP++) { /* output channels are parallelized by multi-chip (OC/#chip) */
          l000[CHIP] = (i+CHIP*H+ 0+0)*M+j+1;   l010[CHIP] = (i+CHIP*H+ 1+0)*M+j+1;
                 :
          l140[CHIP] = (i+CHIP*H+14+0)*M+j+1;       l150[CHIP] = (i+CHIP*H+15+0)*M+j+1;
          t000[CHIP] = &x[l000[CHIP]];   t010[CHIP] = &x[l010[CHIP]];
                 :
          t140[CHIP] = &x[l140[CHIP]];   t150[CHIP] = &x[l150[CHIP]];
          t000w[CHIP]= (Ull)t000[CHIP];t010w[CHIP]= (Ull)t010[CHIP];
                 :
          t140w[CHIP]= (Ull)t140[CHIP];t150w[CHIP]= (Ull)t150[CHIP];
          d000[CHIP] = &b[l000[CHIP]-1]; d010[CHIP] = &b[l010[CHIP]-1];
                 :
          d140[CHIP] = &b[l140[CHIP]-1]; d150[CHIP] = &b[l150[CHIP]-1];
          d000w[CHIP]= (Ull)d000[CHIP];  d010w[CHIP]= (Ull)d010[CHIP];
                 :
          d140w[CHIP]= (Ull)d140[CHIP];  d150w[CHIP]= (Ull)d150[CHIP];
        }
//EMAX5A begin inv_x3 mapdist=0
  /*2*/ for (CHIP=0; CHIP<NCHIP; CHIP++) {
    /*1*/ for (INIT0=1,LOOP0=jc,cofs=jc*4; LOOP0--; INIT0=0) { /* stage#0 *//* mapped to FOR() on BR[63][0][0] */
            exe(OP_ADD, &cofs, cofs, EXP_H3210, -4, EXP_H3210, 0LL, EXP_H3210, OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL); /* stage#0 */
            mop(OP_LDWR,  1, &Ajk,         top,          cofs, MSK_W0, topw,        len, 0, 0, NULL, len);  /* A[p[j]*M+k]              */
            mop(OP_LDWR,  1, &BR[1][3][1], t000[CHIP],   cofs, MSK_W0, t000w[CHIP], len, 0, 1, NULL, len);  /* b[(i+CHIP*W*H+h*W+0)*M+k]*//* stage#1.3 +->x     LD*/
            mop(OP_LDWR,  1, &b000,        d000[CHIP],   0,    MSK_W0, d000w[CHIP], 1,   0, 1, NULL, 1);    /* b[(i+CHIP*W*H+h*W+0)*M+j]*//* stage#2.0 |   ■■ | */
            exe(OP_FMS,      &b000,        b000,         EXP_H3210, Ajk, EXP_H3210, BR[1][3][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);    /* stage#2.0 +- x+ST  v */
            mop(OP_STWR,  1, &b000,        0,      d000[CHIP], MSK_D0, d000w[CHIP], 1,   0, 1, NULL, 1);                                  /* stage#2.0 +------ xxx*/
#if (H>1)
            mop(OP_LDWR,  1, &BR[2][3][1], t010[CHIP],   cofs, MSK_W0, t010w[CHIP], len, 0, 1, NULL, len);  /* b[(i+CHIP*W*H+h*W+0)*M+k]*//* stage#2.3 +->x     LD*/
            mop(OP_LDWR,  1, &b000,        d010[CHIP],   0,    MSK_W0, d010w[CHIP], 1,   0, 1, NULL, 1);    /* b[(i+CHIP*W*H+h*W+0)*M+j]*//* stage#3.0 |   ■■ | */
            exe(OP_FMS,      &b000,        b000,         EXP_H3210, Ajk, EXP_H3210, BR[2][3][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);    /* stage#3.0 +- x+ST  v */
            mop(OP_STWR,  1, &b000,        0,      d010[CHIP], MSK_D0, d010w[CHIP], 1,   0, 1, NULL, 1);                                  /* stage#3.0 +------ xxx*/
                 :
#if (H>8)
            mop(OP_LDWR,  1, &BR[9][3][1], t080[CHIP],   cofs, MSK_W0, t080w[CHIP], len, 0, 1, NULL, len);  /* b[(i+CHIP*W*H+h*W+0)*M+k]*//* stage#9.3 +->x     LD*/
            mop(OP_LDWR,  1, &b000,        d080[CHIP],   0,    MSK_W0, d080w[CHIP], 1,   0, 1, NULL, 1);    /* b[(i+CHIP*W*H+h*W+0)*M+j]*//* stage#10.0|   ■■ | */
            exe(OP_FMS,      &b000,        b000,         EXP_H3210, Ajk, EXP_H3210, BR[9][3][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);    /* stage#10.0+- x+ST  v */
            mop(OP_STWR,  1, &b000,        0,      d080[CHIP], MSK_D0, d080w[CHIP], 1,   0, 1, NULL, 1);                                  /* stage#10.0+------ xxx*/
#if (H>9)
            mop(OP_LDWR,  1, &BR[10][3][1],t090[CHIP],   cofs, MSK_W0, t090w[CHIP], len, 0, 1, NULL, len);  /* b[(i+CHIP*W*H+h*W+0)*M+k]*//* stage#10.3+->x     LD*/
            mop(OP_LDWR,  1, &b000,        d090[CHIP],   0,    MSK_W0, d090w[CHIP], 1,   0, 1, NULL, 1);    /* b[(i+CHIP*W*H+h*W+0)*M+j]*//* stage#11.0|   ■■ | */
            exe(OP_FMS,      &b000,        b000,         EXP_H3210, Ajk, EXP_H3210, BR[10][3][1],EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);    /* stage#11.0+- x+ST  v */
            mop(OP_STWR,  1, &b000,        0,      d090[CHIP], MSK_D0, d090w[CHIP], 1,   0, 1, NULL, 1);                                  /* stage#11.0+------ xxx*/
#if (H>10)
            mop(OP_LDWR,  1, &BR[11][3][1],t100[CHIP],   cofs, MSK_W0, t100w[CHIP], len, 0, 1, NULL, len);  /* b[(i+CHIP*W*H+h*W+0)*M+k]*//* stage#11.3+->x     LD*/
            mop(OP_LDWR,  1, &b000,        d100[CHIP],   0,    MSK_W0, d100w[CHIP], 1,   0, 1, NULL, 1);    /* b[(i+CHIP*W*H+h*W+0)*M+j]*//* stage#12.0|   ■■ | */
            exe(OP_FMS,      &b000,        b000,         EXP_H3210, Ajk, EXP_H3210, BR[11][3][1],EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);    /* stage#12.0+- x+ST  v */
            mop(OP_STWR,  1, &b000,        0,      d100[CHIP], MSK_D0, d100w[CHIP], 1,   0, 1, NULL, 1);                                  /* stage#12.0+------ xxx*/
#if (H>11)
            mop(OP_LDWR,  1, &BR[12][3][1],t110[CHIP],   cofs, MSK_W0, t110w[CHIP], len, 0, 1, NULL, len);  /* b[(i+CHIP*W*H+h*W+0)*M+k]*//* stage#12.3+->x     LD*/
            mop(OP_LDWR,  1, &b000,        d110[CHIP],   0,    MSK_W0, d110w[CHIP], 1,   0, 1, NULL, 1);    /* b[(i+CHIP*W*H+h*W+0)*M+j]*//* stage#13.0|   ■■ | */
            exe(OP_FMS,      &b000,        b000,         EXP_H3210, Ajk, EXP_H3210, BR[12][3][1],EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);    /* stage#13.0+- x+ST  v */
            mop(OP_STWR,  1, &b000,        0,      d110[CHIP], MSK_D0, d110w[CHIP], 1,   0, 1, NULL, 1);                                  /* stage#13.0+------ xxx*/
#if (H>12)
            mop(OP_LDWR,  1, &BR[13][3][1],t120[CHIP],   cofs, MSK_W0, t120w[CHIP], len, 0, 1, NULL, len);  /* b[(i+CHIP*W*H+h*W+0)*M+k]*//* stage#13.3+->x     LD*/
            mop(OP_LDWR,  1, &b000,        d120[CHIP],   0,    MSK_W0, d120w[CHIP], 1,   0, 1, NULL, 1);    /* b[(i+CHIP*W*H+h*W+0)*M+j]*//* stage#14.0|   ■■ | */
            exe(OP_FMS,      &b000,        b000,         EXP_H3210, Ajk, EXP_H3210, BR[13][3][1],EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);    /* stage#14.0+- x+ST  v */
            mop(OP_STWR,  1, &b000,        0,      d120[CHIP], MSK_D0, d120w[CHIP], 1,   0, 1, NULL, 1);                                  /* stage#14.0+------ xxx*/
#if (H>13)
            mop(OP_LDWR,  1, &BR[14][3][1],t130[CHIP],   cofs, MSK_W0, t130w[CHIP], len, 0, 1, NULL, len);  /* b[(i+CHIP*W*H+h*W+0)*M+k]*//* stage#14.3+->x     LD*/
            mop(OP_LDWR,  1, &b000,        d130[CHIP],   0,    MSK_W0, d130w[CHIP], 1,   0, 1, NULL, 1);    /* b[(i+CHIP*W*H+h*W+0)*M+j]*//* stage#15.0|   ■■ | */
            exe(OP_FMS,      &b000,        b000,         EXP_H3210, Ajk, EXP_H3210, BR[14][3][1],EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);    /* stage#15.0+- x+ST  v */
            mop(OP_STWR,  1, &b000,        0,      d130[CHIP], MSK_D0, d130w[CHIP], 1,   0, 1, NULL, 1);                                  /* stage#15.0+------ xxx*/
#if (H>14)
            mop(OP_LDWR,  1, &BR[15][3][1],t140[CHIP],   cofs, MSK_W0, t140w[CHIP], len, 0, 1, NULL, len);  /* b[(i+CHIP*W*H+h*W+0)*M+k]*//* stage#15.3+->x     LD*/
            mop(OP_LDWR,  1, &b000,        d140[CHIP],   0,    MSK_W0, d140w[CHIP], 1,   0, 1, NULL, 1);    /* b[(i+CHIP*W*H+h*W+0)*M+j]*//* stage#16.0|   ■■ | */
            exe(OP_FMS,      &b000,        b000,         EXP_H3210, Ajk, EXP_H3210, BR[15][3][1],EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);    /* stage#16.0+- x+ST  v */
            mop(OP_STWR,  1, &b000,        0,      d140[CHIP], MSK_D0, d140w[CHIP], 1,   0, 1, NULL, 1);                                  /* stage#16.0+------ xxx*/
#if (H>15)
            mop(OP_LDWR,  1, &BR[16][3][1],t150[CHIP],   cofs, MSK_W0, t150w[CHIP], len, 0, 1, NULL, len);  /* b[(i+CHIP*W*H+h*W+0)*M+k]*//* stage#16.3+->x     LD*/
            mop(OP_LDWR,  1, &b000,        d150[CHIP],   0,    MSK_W0, d150w[CHIP], 1,   0, 1, NULL, 1);    /* b[(i+CHIP*W*H+h*W+0)*M+j]*//* stage#17.0|   ■■ | */
            exe(OP_FMS,      &b000,        b000,         EXP_H3210, Ajk, EXP_H3210, BR[16][3][1],EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);    /* stage#17.0+- x+ST  v */
            mop(OP_STWR,  1, &b000,        0,      d150[CHIP], MSK_D0, d150w[CHIP], 1,   0, 1, NULL, 1);                                  /* stage#17.0+------ xxx*/
#endif
          }
        }
//EMAX5A end
//EMAX5A drain_dirty_lmm
        } /* else */
        /********************************************/
      } /* if (j<M-1) */
      for (CHIP=0; CHIP<NCHIP; CHIP++) {
        for (h=0; h<H; h++) { /* vertical (parallel) execution */
          inv1[j*M+p[i+CHIP*H+h]] = x[(i+CHIP*H+h)*M+j] = A[p[j]*M+j]*b[(i+CHIP*H+h)*M+j]; /* PIOにてLMMのx[i*M+j]を直接更新 */
                                                                                           /* iはそのままで,jを切替え */
        }
      }
    } /* j-loop */
  }
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\epsfile{file=inv+rmm-inv_x3-emax6.eps,width=1.00\textwidth}
\caption{逆行列(3/3)}
\end{figure}

\clearpage

\subsection{Lightfieldレンダリング}

\shabox{
\leftline{cent\% make -f Makefile-csim.emax6+dma gather-csim.emax6+dma clean}
\leftline{cent\% ../../src/csim/csim -x gather-csim.emax6+dma}
}

\shabox{
\leftline{zynq\% make -f Makefile-zynq.emax6+dma gather-zynq.emax6+dma clean}
\leftline{zynq\% ./gather-zynq.emax6+dma}
}

\begin{figure}[htbp]
\center
\includegraphics[angle=270,origin=b,width=0.35\textwidth]{472.eps}
\includegraphics[angle=270,origin=b,width=0.35\textwidth]{gather.eps}
\caption{Gather}
\end{figure}

解像度7500x7500ライトフィールド画像処理のレンダリングである．規則的なステン
シル計算ではないためmapdist=0である．

\begin{screen}
\tiny
\begin{verbatim}
orig()
{
  ry = (R+ofs)*IM;
  rx = (R+ofs);
  int w, pix, cvalR, cvalG, cvalB;

  for (row=PAD; row<OM-PAD; row++) {
    for (col=PAD; col<OM-PAD; col++) {
       c = ((row>>4)*R + (((~row&15)*ofs)>>4))*IM
          + (col>>4)*R + (((~col&15)*ofs)>>4);
      cvalR=0;
      cvalG=0;
      cvalB=0;
      for (i=-1; i<=1; i++) {
        for (j=-1; j<=1; j++) {
          Uint pix = in[c+ry*i+rx*j];
          w = weight[WBASE+i*MAXDELTA*2+j];
          cvalR += ((pix>>24)&255)*w;
          cvalG += ((pix>>16)&255)*w;
          cvalB += ((pix>> 8)&255)*w;
          count0++;
        }
      }
      out0[row*OM+col] = ((cvalR>>8)<<24) | ((cvalG>>8)<<16) | ((cvalB>>8)<<8);
} } }
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
imax()
{
  Ull CHIP;
  ry = (R+ofs)*IM;
  rx = (R+ofs);
  int w, pix, cvalR, cvalG, cvalB;

  for (row=0; row<RRANGE; row++) { /* 0..381 */
    for (CHIP=0; CHIP<NCHIP; CHIP++) {
      for (col=0; col<CRANGE; col++) {
        for (oc=0; oc<OMAP; oc++) {
          c =((((CHIP*OMAP+oc)*RRANGE+row+PAD)>>4)*R + (((~((CHIP*OMAP+oc)*RRANGE+row+PAD)&15)*ofs)>>4))*IM
            + ((                      col+PAD)>>4)*R + (((~(                      col+PAD)&15)*ofs)>>4);
          /* 256  512 256 */
          pix = in[c+ry*(-1)+rx*(-1)]; w = 16; cvalR =((pix>>24)&255)*w; cvalG =((pix>>16)&255)*w; cvalB =((pix>> 8)&255)*w;
          pix = in[c+ry*(-1)+rx*( 0)]; w = 32; cvalR+=((pix>>24)&255)*w; cvalG+=((pix>>16)&255)*w; cvalB+=((pix>> 8)&255)*w;
          pix = in[c+ry*(-1)+rx*( 1)]; w = 16; cvalR+=((pix>>24)&255)*w; cvalG+=((pix>>16)&255)*w; cvalB+=((pix>> 8)&255)*w;
          /* 512 1024 512 */
          pix = in[c+ry*( 0)+rx*(-1)]; w = 32; cvalR+=((pix>>24)&255)*w; cvalG+=((pix>>16)&255)*w; cvalB+=((pix>> 8)&255)*w;
          pix = in[c+ry*( 0)+rx*( 0)]; w = 64; cvalR+=((pix>>24)&255)*w; cvalG+=((pix>>16)&255)*w; cvalB+=((pix>> 8)&255)*w;
          pix = in[c+ry*( 0)+rx*( 1)]; w = 32; cvalR+=((pix>>24)&255)*w; cvalG+=((pix>>16)&255)*w; cvalB+=((pix>> 8)&255)*w;
          /* 256  512 256 */
          pix = in[c+ry*( 1)+rx*(-1)]; w = 16; cvalR+=((pix>>24)&255)*w; cvalG+=((pix>>16)&255)*w; cvalB+=((pix>> 8)&255)*w;
          pix = in[c+ry*( 1)+rx*( 0)]; w = 32; cvalR+=((pix>>24)&255)*w; cvalG+=((pix>>16)&255)*w; cvalB+=((pix>> 8)&255)*w;
          pix = in[c+ry*( 1)+rx*( 1)]; w = 16; cvalR+=((pix>>24)&255)*w; cvalG+=((pix>>16)&255)*w; cvalB+=((pix>> 8)&255)*w;
          count1+=9;
          out1[((CHIP*OMAP+oc)*RRANGE+row+PAD)*OM+(col+PAD)] = ((cvalR>>8)<<24) | ((cvalG>>8)<<16) | ((cvalB>>8)<<8);
} } } } }
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
imax()
{
  Ull  CHIP;  Ull  LOOP1, LOOP0;  Ull  INIT1, INIT0;
  Ull  AR[64][4];                     /* output of EX     in each unit */
  Ull  BR[64][4][4];                  /* output registers in each unit */
  Ull  r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15;
  Ull  r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31;
  Ull  c0, c1, c2, c3, ex0, ex1;  Ull  x[NCHIP];
  ry = (R+ofs)*IM;  rx = (R+ofs);
  Uint *ym_xm   = in         -ry-rx;
     :
  for (row=RRANGE-1; row>=0; row--) {
    int yin0[NCHIP];
    Uint *acci_ym0[NCHIP];    Uint *acci_yz0[NCHIP];    Uint *acci_yp0[NCHIP];
    Uint *acco_base0[NCHIP];  Uint *acco0[NCHIP];
         :
    Uint *acco_base5[NCHIP];  Uint *acco5[NCHIP];
    for (CHIP=0; CHIP<NCHIP; CHIP++) {
      int row0 = (CHIP*OMAP+0)*RRANGE+row+PAD;
      int yout0 = row0*OM;
      yin0[CHIP] = ((row0>>4)*R + (((~row0&15)*ofs)>>4))*IM;
      acci_ym0[CHIP] = in+yin0[CHIP]     -ry;      acci_yz0[CHIP] = in+yin0[CHIP];      acci_yp0[CHIP] = in+yin0[CHIP]     +ry;
      acco_base0[CHIP] = out1+yout0+PAD;  acco0[CHIP] = out1+yout0+PAD;
        :
      acco_base5[CHIP] = out1+yout5+PAD;  acco5[CHIP] = out1+yout5+PAD;
    }
//EMAX5A begin gather mapdist=0
    for (CHIP=0; CHIP<NCHIP; CHIP++) {
      for (INIT0=1,LOOP0=CRANGE,x[CHIP]=PAD-1; LOOP0--; INIT0=0) {
        exe(OP_ADD,  &x[CHIP], x[CHIP],  EXP_H3210,         1LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,   0LL, OP_NOP, 0LL);     /* stage#0 */
        exe(OP_SUB,  &r1,         -1LL,  EXP_H3210,     x[CHIP], EXP_H3210, 0LL, EXP_H3210, OP_AND,  15LL, OP_NOP, 0LL);     /* stage#1 */
        exe(OP_NOP,  &r2,      x[CHIP],  EXP_H3210,         0LL, EXP_H3210, 0LL, EXP_H3210, OP_OR,    0LL, OP_SRL, 4LL);     /* stage#1 */
        exe(OP_MLUH, &r3,           r1,  EXP_H3210,    (Ull)ofs, EXP_H3210, 0LL, EXP_H3210, OP_OR,    0LL, OP_SRL, 4LL);     /* stage#2 */
        exe(OP_MLUH, &r4,           r2,  EXP_H3210,        75LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,   0LL, OP_NOP, 0LL);     /* stage#2 */
        exe(OP_ADD3, &r0,           r3,  EXP_H3210,          r4, EXP_H3210,(Ull)yin0[CHIP], EXP_H3210,OP_OR,0LL,OP_SLL, 2LL);/* stage#3 */
        exe(OP_ADD,  &r1,           r3,  EXP_H3210,          r4, EXP_H3210, 0LL, EXP_H3210, OP_OR,    0LL, OP_NOP, 0LL);     /* stage#3 */
        mop(OP_LDWR,    1, &BR[4][0][1],  r0, (Ull)ym_xm, MSK_D0, (Ull)acci_ym0[CHIP], IM, 0, 0, (Ull)NULL, IM);         /* stage#4 */
        mop(OP_LDWR,    1, &BR[4][1][1],  r0, (Ull)ym_xz, MSK_D0, (Ull)acci_ym0[CHIP], IM, 0, 0, (Ull)NULL, IM);         /* stage#4 */
        mop(OP_LDWR,    1, &BR[4][2][1],  r0, (Ull)ym_xp, MSK_D0, (Ull)acci_ym0[CHIP], IM, 0, 0, (Ull)NULL, IM);         /* stage#4 */
        exe(OP_MLUH,  &r10,     BR[4][0][1],  EXP_B5410,        16LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL); /* stage#5 */
        exe(OP_MLUH,  &r11,     BR[4][1][1],  EXP_B5410,        32LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL); /* stage#5 */
        exe(OP_MLUH,  &r12,     BR[4][2][1],  EXP_B5410,        16LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL); /* stage#5 */
        exe(OP_MLUH,  &r13,     BR[4][0][1],  EXP_B7632,        16LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL); /* stage#6 */
        exe(OP_MLUH,  &r14,     BR[4][1][1],  EXP_B7632,        32LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL); /* stage#6 */
        exe(OP_MLUH,  &r15,     BR[4][2][1],  EXP_B7632,        16LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL); /* stage#6 */
        exe(OP_MAUH3, &r20,  r10, EXP_H3210,  r11, EXP_H3210,  r12, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);                    /* stage#6 */
        mop(OP_LDWR,    1, &BR[6][0][1], r0, (Ull)yz_xm, MSK_D0, (Ull)acci_yz0[CHIP], IM, 0, 0, (Ull)NULL, IM);          /* stage#6 */
        mop(OP_LDWR,    1, &BR[6][1][1], r0, (Ull)yz_xz, MSK_D0, (Ull)acci_yz0[CHIP], IM, 0, 0, (Ull)NULL, IM);          /* stage#6 */
        mop(OP_LDWR,    1, &BR[6][2][1], r0, (Ull)yz_xp, MSK_D0, (Ull)acci_yz0[CHIP], IM, 0, 0, (Ull)NULL, IM);          /* stage#6 */
        exe(OP_MAUH3, &r21,  r13, EXP_H3210,  r14, EXP_H3210,  r15, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);                    /* stage#7 */
        exe(OP_MLUH,  &r10,     BR[6][0][1],  EXP_B5410,        32LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL); /* stage#7 */
        exe(OP_MLUH,  &r11,     BR[6][1][1],  EXP_B5410,        64LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL); /* stage#7 */
        exe(OP_MLUH,  &r12,     BR[6][2][1],  EXP_B5410,        32LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL); /* stage#7 */
        exe(OP_MLUH,  &r13,     BR[6][0][1],  EXP_B7632,        32LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL); /* stage#8 */
        exe(OP_MLUH,  &r14,     BR[6][1][1],  EXP_B7632,        64LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL); /* stage#8 */
        exe(OP_MLUH,  &r15,     BR[6][2][1],  EXP_B7632,        32LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL); /* stage#8 */
        exe(OP_MAUH3, &r22,  r10, EXP_H3210,  r11, EXP_H3210,  r12, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);                    /* stage#8 */
        mop(OP_LDWR,    1, &BR[8][0][1], r0, (Ull)yp_xm, MSK_D0, (Ull)acci_yp0[CHIP], IM, 0, 0, (Ull)NULL, IM);          /* stage#8 */
        mop(OP_LDWR,    1, &BR[8][1][1], r0, (Ull)yp_xz, MSK_D0, (Ull)acci_yp0[CHIP], IM, 0, 0, (Ull)NULL, IM);          /* stage#8 */
        mop(OP_LDWR,    1, &BR[8][2][1], r0, (Ull)yp_xp, MSK_D0, (Ull)acci_yp0[CHIP], IM, 0, 0, (Ull)NULL, IM);          /* stage#8 */
        exe(OP_MAUH3, &r23,  r13, EXP_H3210,  r14, EXP_H3210,  r15, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);                    /* stage#9 */
        exe(OP_MLUH,  &r10,     BR[8][0][1],  EXP_B5410,        16LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL); /* stage#9 */
        exe(OP_MLUH,  &r11,     BR[8][1][1],  EXP_B5410,        32LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL); /* stage#9 */
        exe(OP_MLUH,  &r12,     BR[8][2][1],  EXP_B5410,        16LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL); /* stage#9 */
        exe(OP_MLUH,  &r13,     BR[8][0][1],  EXP_B7632,        16LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL); /* stage#10 */
        exe(OP_MLUH,  &r14,     BR[8][1][1],  EXP_B7632,        32LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL); /* stage#10 */
        exe(OP_MLUH,  &r15,     BR[8][2][1],  EXP_B7632,        16LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL); /* stage#10 */
        exe(OP_MAUH3, &r24,  r10, EXP_H3210,  r11, EXP_H3210,  r12, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);                    /* stage#10 */
        exe(OP_MAUH3, &r25,  r13, EXP_H3210,  r14, EXP_H3210,  r15, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);                    /* stage#11 */
        exe(OP_MAUH3, &r30,  r20, EXP_H3210,  r22, EXP_H3210,  r24, EXP_H3210, OP_AND, -1LL, OP_SRLM, 8LL);                  /* stage#12 */
        exe(OP_MAUH3, &r31,  r21, EXP_H3210,  r23, EXP_H3210,  r25, EXP_H3210, OP_AND, -1LL, OP_SRLM, 8LL);                  /* stage#12 */
        exe(OP_MH2BW, &r29,  r31, EXP_H3210,  r30, EXP_H3210,  0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);                   /* stage#13 */
        mop(OP_STWR,    3, &r29, (Ull)(acco0[CHIP]++), 0LL, MSK_D0, (Ull)acco_base0[CHIP], CRANGE, 0,0,(Ull)NULL,CRANGE);/* stage#13 */
        :
        /**********************/
        exe(OP_ADD,  &r0,           r1,  EXP_H3210,   (Ull)yin5[CHIP], EXP_H3210, 0LL, EXP_H3210, OP_OR,   0LL, OP_SLL, 2LL); /* stage#53 */
        /**********************/
        mop(OP_LDWR,    1, &BR[54][0][1],  r0, (Ull)ym_xm, MSK_D0, (Ull)acci_ym5[CHIP], IM, 0, 0, (Ull)NULL, IM);         /* stage#54 */
        mop(OP_LDWR,    1, &BR[54][1][1],  r0, (Ull)ym_xz, MSK_D0, (Ull)acci_ym5[CHIP], IM, 0, 0, (Ull)NULL, IM);         /* stage#54 */
        mop(OP_LDWR,    1, &BR[54][2][1],  r0, (Ull)ym_xp, MSK_D0, (Ull)acci_ym5[CHIP], IM, 0, 0, (Ull)NULL, IM);         /* stage#54 */
        exe(OP_MLUH,  &r10,     BR[54][0][1],  EXP_B5410,        16LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL); /* stage#55 */
        exe(OP_MLUH,  &r11,     BR[54][1][1],  EXP_B5410,        32LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL); /* stage#55 */
        exe(OP_MLUH,  &r12,     BR[54][2][1],  EXP_B5410,        16LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL); /* stage#55 */
        exe(OP_MLUH,  &r13,     BR[54][0][1],  EXP_B7632,        16LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL); /* stage#56 */
        exe(OP_MLUH,  &r14,     BR[54][1][1],  EXP_B7632,        32LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL); /* stage#56 */
        exe(OP_MLUH,  &r15,     BR[54][2][1],  EXP_B7632,        16LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL); /* stage#56 */
        exe(OP_MAUH3, &r20,  r10, EXP_H3210,  r11, EXP_H3210,  r12, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);                     /* stage#56 */
        mop(OP_LDWR,    1, &BR[56][0][1], r0, (Ull)yz_xm, MSK_D0, (Ull)acci_yz5[CHIP], IM, 0, 0, (Ull)NULL, IM);          /* stage#56 */
        mop(OP_LDWR,    1, &BR[56][1][1], r0, (Ull)yz_xz, MSK_D0, (Ull)acci_yz5[CHIP], IM, 0, 0, (Ull)NULL, IM);          /* stage#56 */
        mop(OP_LDWR,    1, &BR[56][2][1], r0, (Ull)yz_xp, MSK_D0, (Ull)acci_yz5[CHIP], IM, 0, 0, (Ull)NULL, IM);          /* stage#56 */
        exe(OP_MAUH3, &r21,  r13, EXP_H3210,  r14, EXP_H3210,  r15, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);                     /* stage#57 */
        exe(OP_MLUH,  &r10,     BR[56][0][1],  EXP_B5410,        32LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL); /* stage#57 */
        exe(OP_MLUH,  &r11,     BR[56][1][1],  EXP_B5410,        64LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL); /* stage#57 */
        exe(OP_MLUH,  &r12,     BR[56][2][1],  EXP_B5410,        32LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL); /* stage#57 */
        exe(OP_MLUH,  &r13,     BR[56][0][1],  EXP_B7632,        32LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL); /* stage#58 */
        exe(OP_MLUH,  &r14,     BR[56][1][1],  EXP_B7632,        64LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL); /* stage#58 */
        exe(OP_MLUH,  &r15,     BR[56][2][1],  EXP_B7632,        32LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL); /* stage#58 */
        exe(OP_MAUH3, &r22,  r10, EXP_H3210,  r11, EXP_H3210,  r12, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);                     /* stage#58 */
        mop(OP_LDWR,    1, &BR[58][0][1], r0, (Ull)yp_xm, MSK_D0, (Ull)acci_yp5[CHIP], IM, 0, 0, (Ull)NULL, IM);          /* stage#58 */
        mop(OP_LDWR,    1, &BR[58][1][1], r0, (Ull)yp_xz, MSK_D0, (Ull)acci_yp5[CHIP], IM, 0, 0, (Ull)NULL, IM);          /* stage#58 */
        mop(OP_LDWR,    1, &BR[58][2][1], r0, (Ull)yp_xp, MSK_D0, (Ull)acci_yp5[CHIP], IM, 0, 0, (Ull)NULL, IM);          /* stage#58 */
        exe(OP_MAUH3, &r23,  r13, EXP_H3210,  r14, EXP_H3210,  r15, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);                     /* stage#59 */
        exe(OP_MLUH,  &r10,     BR[58][0][1],  EXP_B5410,        16LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL); /* stage#59 */
        exe(OP_MLUH,  &r11,     BR[58][1][1],  EXP_B5410,        32LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL); /* stage#59 */
        exe(OP_MLUH,  &r12,     BR[58][2][1],  EXP_B5410,        16LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL); /* stage#59 */
        exe(OP_MLUH,  &r13,     BR[58][0][1],  EXP_B7632,        16LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL); /* stage#60 */
        exe(OP_MLUH,  &r14,     BR[58][1][1],  EXP_B7632,        32LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL); /* stage#60 */
        exe(OP_MLUH,  &r15,     BR[58][2][1],  EXP_B7632,        16LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL); /* stage#60 */
        exe(OP_MAUH3, &r24,  r10, EXP_H3210,  r11, EXP_H3210,  r12, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);                     /* stage#60 */
        exe(OP_MAUH3, &r25,  r13, EXP_H3210,  r14, EXP_H3210,  r15, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);                     /* stage#61 */
        exe(OP_MAUH3, &r30,  r20, EXP_H3210,  r22, EXP_H3210,  r24, EXP_H3210, OP_AND, -1LL, OP_SRLM, 8LL); /* stage#62 */
        exe(OP_MAUH3, &r31,  r21, EXP_H3210,  r23, EXP_H3210,  r25, EXP_H3210, OP_AND, -1LL, OP_SRLM, 8LL); /* stage#62 */
        exe(OP_MH2BW, &r29,  r31, EXP_H3210,  r30, EXP_H3210,  0LL, EXP_H3210, OP_NOP,  0LL, OP_NOP, 0LL);  /* stage#63 */
        mop(OP_STWR,    3, &r29, (Ull)(acco5[CHIP]++), 0LL, MSK_D0, (Ull)acco_base5[CHIP], CRANGE, 0,0,(Ull)NULL, CRANGE);/* stage#63 */
    } }
//EMAX5A end
  }
//EMAX5A drain_dirty_lmm
}
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\epsfile{file=gather+rmm-gather-emax6.eps,width=1.00\textwidth}
\caption{Lightfieldレンダリング}
\end{figure}

\clearpage

\subsection{Lightfield距離画像生成}

\shabox{
\leftline{cent\% make -f Makefile-csim.emax6+dma gdepth-csim.emax6+dma clean}
\leftline{cent\% ../../src/csim/csim -x gdepth-csim.emax6+dma}
}

\shabox{
\leftline{zynq\% make -f Makefile-zynq.emax6+dma gdepth-zynq.emax6+dma clean}
\leftline{zynq\% ./gdepth-zynq.emax6+dma}
}

\begin{figure}[htbp]
\center
\includegraphics[angle=270,origin=b,width=0.35\textwidth]{472.eps}
\includegraphics[angle=270,origin=b,width=0.35\textwidth]{gdepth.eps}
\caption{Gdepth}
\end{figure}

\begin{figure}[htbp]
\center
\includegraphics[width=0.80\textwidth]{lf0.eps}
\caption{\label{fig:lf0}Lightfield}
\end{figure}

解像度7500x7500ライトフィールド画像処理の距離画像生成である．規則的なステン
シル計算ではないものの適応的mapdistを使用しており，標準値はmapdist=3である．
図\ref{fig:lf0}(a)に，LFのデータ構造，(b)に各unitにSum of absolute
difference（SAD）演算器を1つ備える12x4構成のCGRAを示す．(b)は図
\ref{fig:cnn0}と同様，データフローグラフを示している．75x75画素のマイクロレ
ンズ画像が100x100の格子点上に配置され，全体で7500x7500画素の画像（in）が得ら
れると仮定する．各マイクロ画像（上下左右が反転）の一部（3x3）について，
75+ofs画素離れた複数のマイクロ画像間のSADを求め，最小となるofsを距離情報
（out）として生成する．具体的には，中央（p0）の3x3画像のうち6画素と，周囲6箇
所（p1）の3x3画像のうち6画素に対してSADを求め，合計36画素のSADを累算している．
CGRAの先頭段（unit[0][*]）に，y$\#$0の位置における3x3画素の最上行（i$\#$-1に
対応）を割り当て，1行分の画像を保存する先頭LMMから6箇所の離散的ロード（p0と
p1を含む）を行う（点線矩形部分）．第2段（unit[1][*]）と第3段（unit[2][*]）は，
各々，y$\#$-1およびy$\#$1の位置（p1）からのロードを行い，先頭段にて取得した
p0と比較する．CGRAを9段通過した後に，さらに2段を用いて，4列のSADを1つのSADに
累算する．最外ループにおいてofsを変更し，過去の最小sadを保存しておき，より小
さいSAD値が得られた場合に，条件付きストアを用いてsadとoutを更新する．このよ
うに，36画素のSAD値を求めるために11段を使用し，44個中40個の演算器がアクティ
ブとなる．全体の段数は，(b)に示したストア1段を含む12段に，cのアドレス計算等
に必要な6段を前置した合計18段となる．(c)はさらに，画面をNチップに分割して入
力画像を並列処理し，各チップが36画素のSAD演算をREP組写像できる段数を備える場
合の実装である．なおofsを更新する最外ループは省略している．以上の演算に要す
る理論的サイクル数は，CGRA起動時の遅延（REP$\ge$2の場合14xREP+3サイクル）お
よびLMMの入れ換え時間を除くと，ofsあたり40xOM$^2$/(REPxN)となる．outを1画素
生成するためにp0から6画素，p1から36画素必要であるものの，p0とp1の水平方向参
照は重複と考えると，理論的DDR-LMM間転送量は，in:9xOM$^2$ + out:OM$^2$である
（入力画像全体はIM$^2$であるがinとして参照する量は9xOM$^2$）．

\begin{screen}
\tiny
\begin{verbatim}
orig()
{
  ry = (R+ofs)*IM;
  rx = (R+ofs); /* ofs: from 8 to 14 */
  for (row=PAD; row<OM-PAD; row++) {
    for (col=PAD; col<OM-PAD; col++) {
      c =((row>>4)*R + (((~row&15)*ofs)>>4))*IM
        + (col>>4)*R + (((~col&15)*ofs)>>4);
      s = 0;
      for (y=-1; y<=1; y++) {
        for (x=-1; x<=1; x++) {
          if (x == 0) continue;
          for (i=-1; i<=1; i++) {
            for (j=-1; j<=1; j++) {
              if (j == 0) continue;
              p0 = in[c     +(i*IM)     +j]; /* center */
              p1 = in[c+ry*y+(i*IM)+rx*x+j]; /* comparand */
              s += dif(p0, p1);
              if (s > 0xffff) s = 0xffff;
              count0++;
      } } } }
      if (sad0[row*OM+col]>TH && s<sad0[row*OM+col]) {
        sad0[row*OM+col] = s;
        out0[row*OM+col] = ofs;
} } } }
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
imax()
{
  Ull CHIP;
  ry = (R+ofs)*IM;
  rx = (R+ofs); /* ofs: from 8 to 14 */
  for (row=0; row<RRANGE; row++) { /* 0..381 */
    for (CHIP=0; CHIP<NCHIP; CHIP++) {
      for (col=0; col<CRANGE; col++) {
        for (oc=0; oc<OMAP; oc++) {
          c =((((CHIP*OMAP+oc)*RRANGE+row+PAD)>>4)*R + (((~((CHIP*OMAP+oc)*RRANGE+row+PAD)&15)*ofs)>>4))*IM
            + ((                      col+PAD)>>4)*R + (((~(                      col+PAD)&15)*ofs)>>4);
          s = 0;
          for (y=-1; y<=1; y++) {
            for (x=-1; x<=1; x++) {
              if (x == 0) continue;
              for (i=-1; i<=1; i++) {
                for (j=-1; j<=1; j++) {
                  if (j == 0) continue;
                  p0 = in[c     +(i*IM)     +j]; /* center */
                  p1 = in[c+ry*y+(i*IM)+rx*x+j]; /* comparand */
                  s += dif(p0, p1);
                  count1++;
          } } } }
          if (sad1[((CHIP*OMAP+oc)*RRANGE+row+PAD)*OM+(col)+PAD]>TH && s<sad1[((CHIP*OMAP+oc)*RRANGE+row+PAD)*OM+(col+PAD)]) {
            sad1[((CHIP*OMAP+oc)*RRANGE+row+PAD)*OM+(col+PAD)] = s;
            out1[((CHIP*OMAP+oc)*RRANGE+row+PAD)*OM+(col+PAD)] = ofs;
} } } } } }
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
imax()
{
  Ull  CHIP;  Ull  LOOP1, LOOP0;  Ull  INIT1, INIT0;
  Ull  AR[64][4];                     /* output of EX     in each unit */
  Ull  BR[64][4][4];                  /* output registers in each unit */
  Ull  r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15;
  Ull  r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31;
  Ull  c0, c1, c2, c3, ex0, ex1;  Ull  x[NCHIP];
  ry = (R+ofs)*IM; rx = (R+ofs);
  Uint *yzm_xm_m4 = in-IM   -rx-1;  Uint *yzm_xm_p4 = in-IM   -rx+1;
    :
  Uint *ypp_xp_m4 = in+IM+ry+rx-1;  Uint *ypp_xp_p4 = in+IM+ry+rx+1;
  for (row=RRANGE-1; row>=0; row--) {
    int  yin0[NCHIP];
    Uint *acci_yzm0[NCHIP];  Uint *acci_ymm0[NCHIP];  Uint *acci_ypm0[NCHIP];
    Uint *acci_yzz0[NCHIP];  Uint *acci_ymz0[NCHIP];  Uint *acci_ypz0[NCHIP];
    Uint *acci_yzp0[NCHIP];  Uint *acci_ymp0[NCHIP];  Uint *acci_ypp0[NCHIP];
    Uint *sadx_base0[NCHIP]; Uint *sadi0[NCHIP]; Uint *sado0[NCHIP];
    Uint *acco_base0[NCHIP]; Uint *acco0[NCHIP];
      :
    Uint *sadi_base0[NCHIP];  Uint *sadi0[NCHIP]; Uint *sado_base0[NCHIP];  Uint *sado0[NCHIP]; Uint *acco_base0[NCHIP];  Uint *acco0[NCHIP];
      :
    for (CHIP=0; CHIP<NCHIP; CHIP++) {
      yin0[CHIP] = ((row0>>4)*R + (((~row0&15)*ofs)>>4))*IM;
      acci_yzm0[CHIP] = in+yin0[CHIP]-IM;  acci_ymm0[CHIP] = in+yin0[CHIP]-IM-ry;  acci_ypm0[CHIP] = in+yin0[CHIP]-IM+ry;
      acci_yzz0[CHIP] = in+yin0[CHIP];     acci_ymz0[CHIP] = in+yin0[CHIP]   -ry;  acci_ypz0[CHIP] = in+yin0[CHIP]   +ry;
      acci_yzp0[CHIP] = in+yin0[CHIP]+IM;  acci_ymp0[CHIP] = in+yin0[CHIP]+IM-ry;  acci_ypp0[CHIP] = in+yin0[CHIP]+IM+ry;
      sadx_base0[CHIP] = sad1+yout0+PAD;  sadi0[CHIP] = sad1+yout0+PAD;  sado0[CHIP] = sad1+yout0+PAD;
      acco_base0[CHIP] = out1+yout0+PAD;  acco0[CHIP] = out1+yout0+PAD;
        :
    }
//EMAX5A begin gdepth mapdist=3
    for (CHIP=0; CHIP<NCHIP; CHIP++) {
      for (INIT0=1,LOOP0=CRANGE,x[CHIP]=PAD-1; LOOP0--; INIT0=0) {
        exe(OP_ADD,  &x[CHIP], x[CHIP],  EXP_H3210,        1LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,   0LL, OP_NOP, 0LL);   /* stage#0 */
        exe(OP_SUB,  &r1,         -1LL,  EXP_H3210,    x[CHIP], EXP_H3210, 0LL, EXP_H3210, OP_AND,  15LL, OP_NOP, 0LL);   /* stage#1 */
        exe(OP_NOP,  &r2,      x[CHIP],  EXP_H3210,        0LL, EXP_H3210, 0LL, EXP_H3210, OP_OR,    0LL, OP_SRL, 4LL);   /* stage#1 */
        exe(OP_MLUH, &r3,           r1,  EXP_H3210,   (Ull)ofs, EXP_H3210, 0LL, EXP_H3210, OP_OR,    0LL, OP_SRL, 4LL);   /* stage#2 */
        exe(OP_MLUH, &r4,           r2,  EXP_H3210,       75LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,   0LL, OP_NOP, 0LL);   /* stage#2 */
        exe(OP_ADD3, &r0,           r3,  EXP_H3210,         r4, EXP_H3210,(Ull)yin0[CHIP],EXP_H3210,OP_OR,0LL,OP_SLL,2LL);/* stage#3 */
        exe(OP_ADD,  &r1,           r3,  EXP_H3210,         r4, EXP_H3210, 0LL, EXP_H3210, OP_OR,    0LL, OP_NOP, 0LL);   /* stage#3 */
        mop(OP_LDWR,   1, &BR[4][0][1], r0, (Ull)yzm_xm_m4, MSK_D0, (Ull)acci_yzm0[CHIP], IM, 0, 0, (Ull)NULL, IM);   /* stage#4 */
        mop(OP_LDWR,   1, &BR[4][0][0], r0, (Ull)yzm_xm_p4, MSK_D0, (Ull)acci_yzm0[CHIP], IM, 0, 0, (Ull)NULL, IM);   /* stage#4 */
        mop(OP_LDWR,   1, &BR[4][1][1], r0, (Ull)yzm_xz_m4, MSK_D0, (Ull)acci_yzm0[CHIP], IM, 0, 0, (Ull)NULL, IM);   /* stage#4 */
        mop(OP_LDWR,   1, &BR[4][1][0], r0, (Ull)yzm_xz_p4, MSK_D0, (Ull)acci_yzm0[CHIP], IM, 0, 0, (Ull)NULL, IM);   /* stage#4 */
        mop(OP_LDWR,   1, &BR[4][2][1], r0, (Ull)yzm_xp_m4, MSK_D0, (Ull)acci_yzm0[CHIP], IM, 0, 0, (Ull)NULL, IM);   /* stage#4 */
        mop(OP_LDWR,   1, &BR[4][2][0], r0, (Ull)yzm_xp_p4, MSK_D0, (Ull)acci_yzm0[CHIP], IM, 0, 0, (Ull)NULL, IM);   /* stage#4 */
        exe(OP_MSSAD,&r14,   0LL, EXP_H3210, BR[4][0][0], EXP_H3210, BR[4][1][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);   /* stage#5 */
        exe(OP_MSSAD,&r15,   0LL, EXP_H3210, BR[4][0][1], EXP_H3210, BR[4][1][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);   /* stage#5 */
        exe(OP_MSSAD,&r16,   0LL, EXP_H3210, BR[4][2][0], EXP_H3210, BR[4][1][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);   /* stage#5 */
        exe(OP_MSSAD,&r17,   0LL, EXP_H3210, BR[4][2][1], EXP_H3210, BR[4][1][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);   /* stage#5 */
        mop(OP_LDWR,   1, &BR[5][0][1], r0, (Ull)ymm_xm_m4, MSK_D0, (Ull)acci_ymm0[CHIP], IM, 0, 0, (Ull)NULL, IM);   /* stage#5 */
        mop(OP_LDWR,   1, &BR[5][0][0], r0, (Ull)ymm_xm_p4, MSK_D0, (Ull)acci_ymm0[CHIP], IM, 0, 0, (Ull)NULL, IM);   /* stage#5 */
        mop(OP_LDWR,   1, &BR[5][2][1], r0, (Ull)ymm_xp_m4, MSK_D0, (Ull)acci_ymm0[CHIP], IM, 0, 0, (Ull)NULL, IM);   /* stage#5 */
        mop(OP_LDWR,   1, &BR[5][2][0], r0, (Ull)ymm_xp_p4, MSK_D0, (Ull)acci_ymm0[CHIP], IM, 0, 0, (Ull)NULL, IM);   /* stage#5 */
          :
        exe(OP_MAUH, &r24,   r14, EXP_H3210,  r15, EXP_H3210, 0LL, EXP_H3210, OP_NOP,   0LL, OP_NOP, 0LL);                /* stage#14 */
        exe(OP_MAUH, &r26,   r16, EXP_H3210,  r17, EXP_H3210, 0LL, EXP_H3210, OP_NOP,   0LL, OP_NOP, 0LL);                /* stage#14 */
        exe(OP_MAUH, &r30,   r24, EXP_H3210,  r26, EXP_H3210, 0LL, EXP_H3210, OP_SUMHL, 0LL, OP_NOP, 0LL);                /* stage#15 */
        mop(OP_LDWR,   1, &BR[15][1][1], (Ull)(sadi0[CHIP]++),0LL, MSK_D0,(Ull)sadx_base0[CHIP], CRANGE,0,1,(Ull)NULL,CRANGE);/* stage#15 */
        exe(OP_CMP_LT, &c0, r30,           EXP_H3210, BR[15][1][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP,        0LL, OP_NOP, 0LL);  /* stage#16 */
        exe(OP_CMP_GT, &c1, BR[15][1][1],  EXP_H3210,        137LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,        0LL, OP_NOP, 0LL);  /* stage#16 */
        exe(OP_NOP,    &r31, 0LL,          EXP_H3210,          0LL, EXP_H3210, 0LL, EXP_H3210, OP_OR,    (Ull)ofs, OP_NOP, 0LL);  /* stage#16 */
        cex(OP_CEXE,   &ex1,   0, 0, c1, c0, 0x8888);                                                                             /* stage#17 */
        mop(OP_STWR, ex1, &r31, (Ull)(acco0[CHIP]++), 0LL, MSK_D0, (Ull)acco_base0[CHIP], CRANGE, 0, 1, (Ull)NULL, CRANGE);   /* stage#17 */
        cex(OP_CEXE,   &ex0,   0, 0, c1, c0, 0x8888);                                                                             /* stage#17 */
        mop(OP_STWR, ex0, &r30, (Ull)(sado0[CHIP]++), 0LL, MSK_D0, (Ull)sadx_base0[CHIP], CRANGE, 0, 1, (Ull)NULL, CRANGE);   /* stage#17 */
        /********************/
        exe(OP_ADD,  &r0,           r1,  EXP_H3210,    (Ull)yin1[CHIP], EXP_H3210, 0LL, EXP_H3210, OP_OR,    0LL, OP_SLL, 2LL);   /* stage#17 */
        /********************/
          :
        exe(OP_MSSAD,&r24,   r14, EXP_H3210, BR[51][0][0], EXP_H3210, BR[49][1][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#52 */
        exe(OP_MSSAD,&r25,   r15, EXP_H3210, BR[51][0][1], EXP_H3210, BR[49][1][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#52 */
        exe(OP_MSSAD,&r26,   r16, EXP_H3210, BR[51][2][0], EXP_H3210, BR[49][1][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#52 */
        exe(OP_MSSAD,&r27,   r17, EXP_H3210, BR[51][2][1], EXP_H3210, BR[49][1][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#52 */
        mop(OP_LDWR,   1, &BR[52][0][1], r0, (Ull)yzp_xm_m4, MSK_D0, (Ull)acci_yzp3[CHIP], IM, 0, 0, (Ull)NULL, IM);  /* stage#52 */
        mop(OP_LDWR,   1, &BR[52][0][0], r0, (Ull)yzp_xm_p4, MSK_D0, (Ull)acci_yzp3[CHIP], IM, 0, 0, (Ull)NULL, IM);  /* stage#52 */
        mop(OP_LDWR,   1, &BR[52][1][1], r0, (Ull)yzp_xz_m4, MSK_D0, (Ull)acci_yzp3[CHIP], IM, 0, 0, (Ull)NULL, IM);  /* stage#52 */
        mop(OP_LDWR,   1, &BR[52][1][0], r0, (Ull)yzp_xz_p4, MSK_D0, (Ull)acci_yzp3[CHIP], IM, 0, 0, (Ull)NULL, IM);  /* stage#52 */
        mop(OP_LDWR,   1, &BR[52][2][1], r0, (Ull)yzp_xp_m4, MSK_D0, (Ull)acci_yzp3[CHIP], IM, 0, 0, (Ull)NULL, IM);  /* stage#52 */
        mop(OP_LDWR,   1, &BR[52][2][0], r0, (Ull)yzp_xp_p4, MSK_D0, (Ull)acci_yzp3[CHIP], IM, 0, 0, (Ull)NULL, IM);  /* stage#52 */
        exe(OP_MSSAD,&r14,   r24, EXP_H3210, BR[52][0][0], EXP_H3210, BR[52][1][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#53 */
        exe(OP_MSSAD,&r15,   r25, EXP_H3210, BR[52][0][1], EXP_H3210, BR[52][1][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#53 */
        exe(OP_MSSAD,&r16,   r26, EXP_H3210, BR[52][2][0], EXP_H3210, BR[52][1][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#53 */
        exe(OP_MSSAD,&r17,   r27, EXP_H3210, BR[52][2][1], EXP_H3210, BR[52][1][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#53 */
        mop(OP_LDWR,   1, &BR[53][0][1], r0, (Ull)ymp_xm_m4, MSK_D0, (Ull)acci_ymp3[CHIP], IM, 0, 0, (Ull)NULL, IM);  /* stage#53 */
        mop(OP_LDWR,   1, &BR[53][0][0], r0, (Ull)ymp_xm_p4, MSK_D0, (Ull)acci_ymp3[CHIP], IM, 0, 0, (Ull)NULL, IM);  /* stage#53 */
        mop(OP_LDWR,   1, &BR[53][2][1], r0, (Ull)ymp_xp_m4, MSK_D0, (Ull)acci_ymp3[CHIP], IM, 0, 0, (Ull)NULL, IM);  /* stage#53 */
        mop(OP_LDWR,   1, &BR[53][2][0], r0, (Ull)ymp_xp_p4, MSK_D0, (Ull)acci_ymp3[CHIP], IM, 0, 0, (Ull)NULL, IM);  /* stage#53 */
        exe(OP_MSSAD,&r24,   r14, EXP_H3210, BR[53][0][0], EXP_H3210, BR[52][1][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#54 */
        exe(OP_MSSAD,&r25,   r15, EXP_H3210, BR[53][0][1], EXP_H3210, BR[52][1][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#54 */
        exe(OP_MSSAD,&r26,   r16, EXP_H3210, BR[53][2][0], EXP_H3210, BR[52][1][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#54 */
        exe(OP_MSSAD,&r27,   r17, EXP_H3210, BR[53][2][1], EXP_H3210, BR[52][1][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#54 */
        mop(OP_LDWR,   1, &BR[54][0][1], r0, (Ull)ypp_xm_m4, MSK_D0, (Ull)acci_ypp3[CHIP], IM, 0, 0, (Ull)NULL, IM);  /* stage#54 */
        mop(OP_LDWR,   1, &BR[54][0][0], r0, (Ull)ypp_xm_p4, MSK_D0, (Ull)acci_ypp3[CHIP], IM, 0, 0, (Ull)NULL, IM);  /* stage#54 */
        mop(OP_LDWR,   1, &BR[54][2][1], r0, (Ull)ypp_xp_m4, MSK_D0, (Ull)acci_ypp3[CHIP], IM, 0, 0, (Ull)NULL, IM);  /* stage#54 */
        mop(OP_LDWR,   1, &BR[54][2][0], r0, (Ull)ypp_xp_p4, MSK_D0, (Ull)acci_ypp3[CHIP], IM, 0, 0, (Ull)NULL, IM);  /* stage#54 */
        exe(OP_MSSAD,&r14,   r24, EXP_H3210, BR[54][0][0], EXP_H3210, BR[52][1][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#55 */
        exe(OP_MSSAD,&r15,   r25, EXP_H3210, BR[54][0][1], EXP_H3210, BR[52][1][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#55 */
        exe(OP_MSSAD,&r16,   r26, EXP_H3210, BR[54][2][0], EXP_H3210, BR[52][1][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#55 */
        exe(OP_MSSAD,&r17,   r27, EXP_H3210, BR[54][2][1], EXP_H3210, BR[52][1][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#55 */
        exe(OP_MAUH, &r24,   r14, EXP_H3210,  r15, EXP_H3210, 0LL, EXP_H3210, OP_NOP,   0LL, OP_NOP, 0LL);                /* stage#56 */
        exe(OP_MAUH, &r26,   r16, EXP_H3210,  r17, EXP_H3210, 0LL, EXP_H3210, OP_NOP,   0LL, OP_NOP, 0LL);                /* stage#56 */
        exe(OP_MAUH, &r30,   r24, EXP_H3210,  r26, EXP_H3210, 0LL, EXP_H3210, OP_SUMHL, 0LL, OP_NOP, 0LL);                /* stage#57 */
        mop(OP_LDWR,   1, &BR[57][1][1], (Ull)(sadi3[CHIP]++),0LL, MSK_D0,(Ull)sadx_base3[CHIP], CRANGE,0,1,(Ull)NULL,CRANGE);/* stage#57 */
        exe(OP_CMP_LT, &c0, r30,           EXP_H3210, BR[57][1][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP,        0LL, OP_NOP, 0LL);  /* stage#58 */
        exe(OP_CMP_GT, &c1, BR[57][1][1],  EXP_H3210,        137LL, EXP_H3210, 0LL, EXP_H3210, OP_NOP,        0LL, OP_NOP, 0LL);  /* stage#58 */
        exe(OP_NOP,    &r31, 0LL,          EXP_H3210,          0LL, EXP_H3210, 0LL, EXP_H3210, OP_OR,    (Ull)ofs, OP_NOP, 0LL);  /* stage#58 */
        cex(OP_CEXE,   &ex1,   0, 0, c1, c0, 0x8888);                                                                             /* stage#59 */
        mop(OP_STWR, ex1, &r31, (Ull)(acco3[CHIP]++), 0LL, MSK_D0, (Ull)acco_base3[CHIP], CRANGE, 0, 1, (Ull)NULL, CRANGE);   /* stage#59 */
        cex(OP_CEXE,   &ex0,   0, 0, c1, c0, 0x8888);                                                                             /* stage#59 */
        mop(OP_STWR, ex0, &r30, (Ull)(sado3[CHIP]++), 0LL, MSK_D0, (Ull)sadx_base3[CHIP], CRANGE, 0, 1, (Ull)NULL, CRANGE);   /* stage#59 */
    } }
//EMAX5A end
  }
//EMAX5A drain_dirty_lmm
}
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\epsfile{file=gdepth+rmm-gdepth-emax6.eps,width=1.00\textwidth}
\caption{Lightfield距離画像生成}
\end{figure}

\clearpage

\section{Graph processing on EMAX5}

\shabox{
\leftline{cent\% make -f Makefile-bsim.emax5 all clean}
\leftline{cent\% ../../src/bsim/bsim -x tricount-bsim.emax5 ../graph-data/test.edges}
}

\begin{figure}[htbp]
\center
\includegraphics[angle=270,origin=b,width=0.90\textwidth]{graph.eps}
\caption{Graph}
\end{figure}

\subsection{Triangle counting kernel0 with TCU}

グラフ構造に存在する三角形を数える処理（BFS）である．トランザクションを使用している．

\begin{screen}
\tiny
\begin{verbatim}
void tri_kernel0(struct param_bfs *param)
{
  volatile int i, j, pid, qid, MVL, MEL;
  volatile struct vertex *p, *np, *q;
  volatile struct neighborvertex *n;

  i = param->i;
  p = param->p;
  np = param->nextp;
  MVL = param->maxvlist;
  MEL = param->maxelist;
  pid = p->id;

#if !defined(EMAX5) && !defined(EMAX6)
    for (j=0; j<p->nedges; j++) {                      /* R０段:最内ループ256回転程度 */
      n = p->npage[j/MAXNV_PPAGE]+(j%MAXNV_PPAGE);
      q = n->vp;                                       /* R０段:neighborvertex全体を配置 pointerを使い参照 */
      qid = n->id;                                     /* R０段:同上 */
      if (!q->parent) {                                /* R１段:vertex全体を配置 pointer->pointerを使い参照 */
        /************************/
        while (cmpxchg(&Sem0, -1, param->th) != -1);
        /************************/
        if (!q->parent) {                              /* R１段:同上 */
          if (nnextfrontiers >= MVL) {
            printf("vlist[%d] exhausted\n", MVL);
            exit(1);
          }
          q->parent = pid;                             /* W２段:verex更新 */
          q->depth  = depth;                           /* W２段:同上 */
          q->findex = nnextfrontiers;                  /* W２段:同上 */
          nextfrontier[nnextfrontiers] = q;            /* W２段:next_frontier[]更新 */
          nnextfrontiers++;                            /* W２段:同上 */
          nnextfrontiers__neighbors+=q->nedges;
        }
        /************************/
        /*cmpxchg(&Sem0, param->th, -1);*/
        release(&Sem0, -1);
        /************************/
      }
      else if (q->depth==depth-1 && q->findex<i) {     /* R１段:vertex全体を配置 pointer->pointerを使い参照 */
        /************************/
        while (cmpxchg(&Sem1, -1, param->th) != -1);
        /************************/
        if (nfrontier_edges >= MEL) {
          printf("elist[%d] exhausted\n", MEL);
          exit(1);
        }
        frontier_edge[nfrontier_edges].src = (pid<qid)?p:q; /* W２段:frontier_edge[]更新 */
        frontier_edge[nfrontier_edges].dst = (pid<qid)?q:p; /* W２段:同上 */
        nfrontier_edges++;                                  /* W２段:同上 */
        nfrontier_edges__neighbors+=((pid<qid)?p:q)->nedges;
        /************************/
        /*cmpxchg(&Sem1, param->th, -1);*/
        release(&Sem1, -1);
        /************************/
      }
    }
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
#else
  Ull  AR[64][4];    /* output registers in each unit */
  Ull  BR[64][4][4]; /* output registers in each unit */
  struct neighborvertex  *r0     =NULL; /* n */
  struct neighborvertex **r0_top =p->npage;
  Uint                    r0_len =p->nedges*4;
  Uint                    pnedges=p->nedges;
  struct neighborvertex **r0_ntop=np?np->npage:NULL;
  Uint                    r0_nlen=np?np->nedges*4:NULL;
  Ull                     r2[4], r3[4], r4[4], r6, r7, r8;
  Ull                     depth_1=depth-1;
  Ull                     c0, c1, c2, c3, ex0, ex1;
  int loop=p->nedges;
  void tri_kernel0_trans0();
  void tri_kernel0_trans1();
//EMAX5A begin tri_kernel0 mapdist=1
  while (loop--) {
/*0,0*/ mo4(OP_LDRQ,    1,      BR[0][0],    (Ull)(r0++), 0LL,         MSK_D0,    (Ull)r0_top, r0_len, 2, 0, (Ull)r0_ntop, r0_nlen);
/*1,1*/ mo4(OP_LDDMQ,   1,      BR[1][1],    BR[0][0][3], 32LL,        MSK_D0,    (Ull)NULL, 0, 0, 0, (Ull)NULL, 0);
/*1,2*/ exe(OP_CMP_LT,  &c0,    pid,         EXP_H3210,   BR[0][0][2], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);
/*2,0*/ exe(OP_CMOV,    &r6,    c0,          EXP_H3210,   p,           EXP_H3210, BR[0][0][3], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);
/*2,1*/ exe(OP_CMOV,    &r7,    c0,          EXP_H3210,   BR[0][0][3], EXP_H3210, p,           EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);
/*2,2*/ exe(OP_CMOV,    &r8,    c0,          EXP_H3210,   pnedges,     EXP_H3210, BR[1][1][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);
/*2,3*/ exe(OP_CMP_EQ,  &c0,    BR[1][1][1], EXP_H3210,   0LL,         EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* q->parent==0? */
/*3,0*/ exe(OP_ADD,     &AR[3][0], BR[0][0][3], EXP_H3210,0LL,         EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* address(q) */
/*3,1*/ exe(OP_ADD,     &AR[3][1], BR[1][1][0], EXP_H3210,0LL,         EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* q->nedges */
/*3,2*/ exe(OP_ADD,     &AR[3][2], pid,         EXP_H3210,0LL,         EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* pid */
/*3,2*/ cex(OP_CEXE,    &ex0,   0,  0,  0, c0, 0xaaaa);
/*3,2*/ mo4(OP_TR,      ex0,    AR[3],          (Ull)NULL,0LL,         0LL,       (Ull)tri_kernel0_trans0, 0, 0, 0, (Ull)NULL, 0);
/*4,0*/ exe(OP_CMP_NE,  &c0,    BR[1][1][1], EXP_H3210,   0LL,         EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* q->parent!=0 */
/*4,1*/ exe(OP_CMP_EQ,  &c1,    BR[1][1][2], EXP_H3210,   depth_1,     EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* q->depth==depth-1 */
/*4,2*/ exe(OP_CMP_LT,  &c2,    BR[1][1][3], EXP_H3210,   i,           EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* q->findex<i */
/*5,0*/ exe(OP_ADD,     &AR[5][0], r6,       EXP_H3210,   0LL,         EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* src */
/*5,1*/ exe(OP_ADD,     &AR[5][1], r7,       EXP_H3210,   0LL,         EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* dst */
/*5,2*/ exe(OP_ADD,     &AR[5][2], r8,       EXP_H3210,   0LL,         EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* nen */
/*5,3*/ exe(OP_ADD,     &AR[5][3], 0LL,      EXP_H3210,   0LL,         EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* dummy */
/*5,3*/ cex(OP_CEXE,    &ex1,   0, c2, c1, c0, 0x8080);
/*5,3*/ mo4(OP_TR,      ex1,    AR[5],       (Ull)NULL,   0LL,         0LL,       (Ull)tri_kernel0_trans1, 0, 0, 0, (Ull)NULL, 0);
  }
//EMAX5A end
#endif
}
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\epsfile{file=tricount-tri_kernel0-emax6.eps,width=1.00\textwidth}
\caption{Triangle counting kernel0 with TCU}
\end{figure}

\clearpage

\subsection{Triangle counting kernel1 with TCU}

グラフ構造に存在する三角形を数える処理（三角形カウント）である．トランザクショ
ンを使用している．

\begin{screen}
\tiny
\begin{verbatim}
void tri_kernel1(struct param_tricount *param)
{
  /* search triangle in {frontier,next} */
  /* case 1: e∈frontier, v∈prev     */
  /* case 2: e∈frontier, v∈frontier */
  /* case 3: e∈frontier, v∈next     */
  int i, j, pid, qid, sdepth, tdepth;
  struct vertex *p, *np, *q, *t;
  struct neighborvertex *n;

  p = param->p;
  np = param->nextp;
  t = param->t;
  pid = p->id;
  sdepth = p->depth;

#if !defined(EMAX5) && !defined(EMAX6)
    int tricount = 0;
    for (j=0; j<p->nedges; j++) {                    /* R０段:最内ループ256回転程度 */
      n = p->npage[j/MAXNV_PPAGE]+(j%MAXNV_PPAGE);
      q = n->vp;                                     /* R０段:neighborvertex全体を配置 pointerを使い参照 */
      qid = n->id;                                   /* R０段:同上 */
      tdepth = q->depth;                             /* R１段:vertex全体を配置 pointer->pointerを使い参照 */
      if ((tdepth==sdepth-1)||(tdepth==sdepth+1)||(tdepth==sdepth && qid<pid)) { /* R２段:比較 */
        if (search_nvertex(t->nhashtbl, qid))        /* R３段:HASH-SEARCH/CAM-SEARCH */
          tricount++;                                /* W４段:カウンタ更新 */
      }
    }
    param->tricount += tricount;
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
#else
  Ull  BR[16][4][4]; /* output registers in each unit */
  struct neighborvertex  *r0     =NULL; /* n */
  struct neighborvertex **r0_top =p->npage;
  Uint                    r0_len =p->nedges*4;
  Uint                    pnedges=p->nedges;
  struct neighborvertex **r0_ntop=np?np->npage:NULL;
  Uint                    r0_nlen=np?np->nedges*4:NULL;
  Ull                     r2[4], r3[4], r6, r7, r8;
  Ull                     sdepth_m1=sdepth-1;
  Ull                     tnhashtbl=t->nhashtbl;
  Ull                     sdepth_p1=sdepth+1;
  Ull                     c0, c1, c2, c3, ex0, ex1;
  int loop=p->nedges;
  void tri_kernel1_trans0();
//EMAX5A begin tri_kernel1 mapdist=1
  while (loop--) {
/*0,0*/ mo4(OP_LDRQ,    1,      BR[0][0],    (Ull)(r0++), 0LL,         MSK_D0,    (Ull)r0_top, r0_len, 2, 0, (Ull)r0_ntop, r0_nlen);
/*1,1*/ mo4(OP_LDDMQ,   1,      BR[1][1],    BR[0][0][3], 32LL,        MSK_D0,    (Ull)NULL, 0, 0, 0, (Ull)NULL, 0);
/*2,0*/ exe(OP_CMP_EQ,  &c0,    BR[1][1][2], EXP_H3210,   sdepth_m1,   EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);       /* q->depth==p->depth-1 */
/*2,1*/ exe(OP_CMP_EQ,  &c1,    BR[1][1][2], EXP_H3210,   sdepth_p1,   EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);       /* q->depth==p->depth+1 */
/*2,2*/ exe(OP_CMP_EQ,  &c2,    BR[1][1][2], EXP_H3210,   sdepth,      EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);       /* q->depth==p->depth   */
/*2,3*/ exe(OP_CMP_LT,  &c3,    BR[0][0][2], EXP_H3210,   pid,         EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);       /* qid<pid              */
/*3,0*/ exe(OP_ADD,     &AR[3][0], tnhashtbl,   EXP_H3210,0LL,         EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);       /* t->nhashtbl */
/*3,1*/ exe(OP_ADD,     &AR[3][1], BR[0][0][2], EXP_H3210,0LL,         EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);       /* qid */
/*3,2*/ exe(OP_ADD,     &AR[3][2], 0LL,         EXP_H3210,0LL,         EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);       /* dummy */
/*3,3*/ exe(OP_ADD,     &AR[3][3], 0LL,         EXP_H3210,0LL,         EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);       /* dummy */
/*3,3*/ cex(OP_CEXE,    &ex0,   c3, c2, c1, c0, 0xfeee);
/*3,3*/ mo4(OP_TR,      ex0,    AR[3],       (Ull)NULL,   0LL,         0LL,       (Ull)tri_kernel1_trans0, 0, 0, 0, (Ull)NULL, 0);  /* r3[1]<-(nhashtbl) r3[0]<-(qid) */
  }
//EMAX5A end
#endif
}
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\epsfile{file=tricount-tri_kernel1-emax6.eps,width=1.00\textwidth}
\caption{Triangle counting kernel1 with TCU}
\end{figure}

\clearpage

\section{Graph processing on IMAX2}

\shabox{
\leftline{cent\% make -f Makefile.emax6nc all clean}
\leftline{cent\% tricount.emax6nc ../graph-data/facebook.edges}
}

\subsection{Triangle counting kernel0}

\begin{screen}
\tiny
\begin{verbatim}
#if !defined(EMAX6)
  int  i, j, pid, qid;
  for (i=0; i<curfront_v->n_v; i+=4) {
    pid = curfront_v->pid[i/4];          /* sequential        [LMM#0] */
    for (j=0; j<vinfo[pid].n_v; j++) { /*             vinfo [LMM#1] */
      qid = vpack[pid].qid[j];         /* top+1D-sequential [LMM#2] */
      if (!vinfo[qid].parent) {        /* 1D-random         [LMM#1] */
        if (nxtfront_v->n_v >= MAXFRONT_V*4) {
          printf("nxtfront_v exhausted (%d)\n", MAXFRONT_V);
          exit(1);
        }
        vinfo[qid].parent = 1/*pid*/;             /* 1D-random  update [LMM#1] */
        vinfo[qid].depth  = depth;                /* 1D-random  update [LMM#1] */
        nxtfront_v->pid[nxtfront_v->n_v/4] = qid; /* sequential update [LMM#3] */
        nxtfront_v->n_v+=4;                       /* sequential update [LMM#3] */
      }
      else if (vinfo[qid].depth==depth-1 && pid<qid) { /* 1D-random */
        if (curfront_e->n_e >= MAXFRONT_E*4) {
          printf("curfront_e exhausted (%d)\n", MAXFRONT_E);
          exit(1);
        }
        curfront_e->e[curfront_e->n_e/4].src = pid; /* sequential update [LMM#4]   */
        curfront_e->e[curfront_e->n_e/4].dst = qid; /* sequential update [LMM#4]   */
        curfront_e->n_e+=4;                         /* sequential update [LMM#5++] */
  } } }
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
#else
  Ull  CHIP;
  Ull  LOOP1, LOOP0;
  Ull  INIT1, INIT0;
  Ull  AR[64][4];                     /* output of EX     in each unit */
  Ull  BR[64][4][4];                  /* output registers in each unit */
  Ull  r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15;
  Ull  r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31;
  Ull  cc0, cc1, cc2, cc3, ex0, ex1;
  Ull  cand0, cand1;
  int  i, j, pid, len;
  Ull  qofs, qid, qid_pid, qidofs, qinfo1, qinfo2, qinfo_depth, parent_depth, depth_m1;
  Ull  nxtfront_v_p4 = (Ull)nxtfront_v + 4;
  Ull  curfront_e_p4 = (Ull)curfront_e + 4;
  Ull  nxtfront_v_n, nxtfront_ofs;
  Ull  curfront_e_n, curfront_ofs;

  parent_depth = 0x80000000 | (depth<<16);
  depth_m1    = depth-1;
  for (i=0; i<curfront_v->n_v; i+=4) {
    pid = curfront_v->pid[i/4];          /* sequential        [LMM#0] */
    len = vinfo[pid].n_v;              /* #of words */
//EMAX5A begin tri_kernel0 mapdist=0
    for (INIT0=1,LOOP0=len,qofs=(0-4); LOOP0--; INIT0=0) {
      exe(OP_ADD,       &qofs,         qofs,          EXP_H3210, 4,            EXP_H3210, 0,              EXP_H3210,    OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL);
      mop(OP_LDWR, 1,   &qid,          vpack[pid].qid,           qofs,         MSK_W0,    vpack[pid].qid, len,          0, 0,   NULL, 0); /* qid */
      exe(OP_ADD,       &qidofs,       qid,           EXP_H3210, 0,            EXP_H3210, 0,              EXP_H3210,    OP_AND, 0x00000000ffffffffLL, OP_SLL, 2LL);
      mop(OP_LDWR, 1,   &qinfo1,       vinfo,                    qidofs,       MSK_W0,    vinfo,          nvertices,    0, 0,   NULL, 0); /* qinfo */
      mop(OP_LDWR, 1,   &qinfo2,       vinfo,                    qidofs,       MSK_W0,    vinfo,          nvertices,    0, 0,   NULL, 0); /* qinfo */
      exe(OP_CMP_LT,    &cc0,          qinfo1,        EXP_H3210, 0x80000000LL, EXP_H3210, 0,              EXP_H3210,    OP_NOP, 0LL,                  OP_NOP, 0LL);
      exe(OP_NOP,       &nxtfront_ofs, cc0,           EXP_H3210, 0,            EXP_H3210, 0,              EXP_H3210,    OP_AND, 1LL,                  OP_SLL, 2LL);

      exe(OP_NOP,       &qinfo1,       parent_depth,  EXP_H3210, 0,            EXP_H3210, 0,              EXP_H3210,    OP_OR,  qinfo1,               OP_NOP, 0LL);
      cex(OP_CEXE,      &ex0,          0,0,0,cc0,0xaaaa);
      mop(OP_STWR, ex0, &qinfo1,       vinfo,                    qidofs,       MSK_W0,    vinfo,          nvertices,    0, 0,   NULL, 0); /* vinfo[qid].parent=1 */

      mop(OP_LDWR, 1,   &nxtfront_v_n, nxtfront_v,               0,            MSK_W0,    nxtfront_v,     1,            0, 1,   NULL, 0); /* nxtfront_v->n_v */
      cex(OP_CEXE,      &ex0,          0,0,0,cc0,0xaaaa);
      mop(OP_STWR, ex0, &qid,          nxtfront_v_p4,            nxtfront_v_n, MSK_W0,    nxtfront_v,     MAXFRONT_V+1, 0, 0,   NULL, 0);
      mop(OP_LDWR, 1,   &nxtfront_v_n, nxtfront_v,               0,            MSK_W0,    nxtfront_v,     1,            0, 1,   NULL, 0); /* nxtfront_v->n_v */
      exe(OP_ADD,       &nxtfront_v_n, nxtfront_v_n,  EXP_H3210, nxtfront_ofs, EXP_H3210, 0,              EXP_H3210,    OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL);
      mop(OP_STWR, 1,   &nxtfront_v_n, nxtfront_v,               0,            MSK_W0,    nxtfront_v,     1,            0, 1,   NULL, 0); /* nxtfront_v->n_v */

      exe(OP_NOP,       &qinfo_depth,  qinfo2,        EXP_H3210, 0,            EXP_H3210, 0,              EXP_H3210,    OP_AND, 0x000000007fffffffLL, OP_SRL, 16LL);
      exe(OP_CMP_GE,    &cc2,          qinfo2,        EXP_H3210, 0x80000000LL, EXP_H3210, 0,              EXP_H3210,    OP_NOP, 0LL,                  OP_NOP, 0LL);
      exe(OP_CMP_EQ,    &cc1,          qinfo_depth,   EXP_H3210, depth_m1,     EXP_H3210, 0,              EXP_H3210,    OP_NOP, 0LL,                  OP_NOP, 0LL);
      exe(OP_CMP_LT,    &cc0,          pid,           EXP_H3210, qid,          EXP_H3210, 0,              EXP_H3210,    OP_NOP, 0LL,                  OP_NOP, 0LL);
      exe(OP_NOP,       &cand0,        cc2,           EXP_H3210, 0,            EXP_H3210, 0,              EXP_H3210,    OP_AND, cc1,                  OP_NOP, 0LL);
      exe(OP_NOP,       &cand1,        cand0,         EXP_H3210, 0,            EXP_H3210, 0,              EXP_H3210,    OP_AND, cc0,                  OP_NOP, 0LL);
      exe(OP_NOP,       &curfront_ofs, cand1,         EXP_H3210, 0,            EXP_H3210, 0,              EXP_H3210,    OP_AND, 1LL,                  OP_SLL, 2LL);

      exe(OP_ADD,       &qid_pid,      qid,           EXP_H3210, 0,            EXP_H3210, 0,              EXP_H3210,    OP_AND, 0x000000000000ffffLL, OP_SLL, 16LL);
      exe(OP_ADD,       &qid_pid,      0,             EXP_H3210, qid_pid,      EXP_H3210, 0,              EXP_H3210,    OP_OR,  pid,                  OP_NOP, 0LL);

      mop(OP_LDWR, 1,   &curfront_e_n, curfront_e,               0,            MSK_W0,    curfront_e,     1,            0, 1,   NULL, 0); /* curfront_e->n_e */
      cex(OP_CEXE,      &ex1,          0,cc2,cc1,cc0,0x8080);
      mop(OP_STWR, ex1, &qid_pid,      curfront_e_p4,            curfront_e_n, MSK_W0,    curfront_e,     MAXFRONT_E+1, 0, 0,   NULL, 0); /* qid_pid */
      mop(OP_LDWR, 1,   &curfront_e_n, curfront_e,               0,            MSK_W0,    curfront_e,     1,            0, 1,   NULL, 0); /* curfront_e->n_e */
      exe(OP_ADD,       &curfront_e_n, curfront_e_n,  EXP_H3210, curfront_ofs, EXP_H3210, 0,              EXP_H3210,    OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL);
      mop(OP_STWR, 1,   &curfront_e_n, curfront_e,               0,            MSK_W0,    curfront_e,     1,            0, 1,   NULL, 0); /* curfront_e->n_e */
    }
//EMAX5A end
  }
#endif
}
\end{verbatim}
\end{screen}

\clearpage

\subsection{Triangle counting kernel1}

\begin{screen}
\tiny
\begin{verbatim}
#if !defined(EMAX6)
  int  i, j, src, dst, qid, sdepth, qdepth;

  for (i=0; i<curfront_e->n_e; i+=4) {
    src = curfront_e->e[i/4].src;          /* sequential        [LMM#0] */
    dst = curfront_e->e[i/4].dst;          /* sequential        [LMM#0] */
    sdepth = vinfo[src].depth;           /*             vinfo [LMM#1] */
    for (j=0; j<vinfo[src].n_v; j++) {   /*             vinfo [LMM#1] */
      qid    = vpack[src].qid[j];        /* top+1D-sequential [LMM#2] */
      qdepth = vinfo[qid].depth;         /* 1D-random         [LMM#1] */
      if ((sdepth-1==qdepth)||(sdepth+1==qdepth)||(sdepth==qdepth && dst<qid)) { /* src < dst < qid */
        if (search_qid_in_dst(qid, dst)) /* search */
          (*tricount)++;                 /* update */
      }
    }
  }
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
#else
  Ull  CHIP;
  Ull  LOOP1, LOOP0;
  Ull  INIT1, INIT0;
  Ull  AR[64][4];                     /* output of EX     in each unit */
  Ull  BR[64][4][4];                  /* output registers in each unit */
  Ull  r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15;
  Ull  r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31;
  Ull  cc0, cc1, cc2, cc3, ex0, ex1;
  Ull  cand0, cand1, cand2;
  int  i, j, src, dst, len;
  Ull  sofs, qid, qidofs, qinfo, qinfo_depth, sdepth, sdepth_m1, sdepth_p1, vsearchqid, vsearchtop, search;
  Ull  tricount_ofs, tricount_r;

  for (i=0; i<curfront_e->n_e; i+=4) {
    src = curfront_e->e[i/4].src;        /* sequential        [LMM#0] */
    dst = curfront_e->e[i/4].dst;        /* sequential        [LMM#0] */
    sdepth = vinfo[src].depth;           /*             vinfo [LMM#1] */
    sdepth_m1 = sdepth-1;                /*             vinfo [LMM#1] */
    sdepth_p1 = sdepth+1;                /*             vinfo [LMM#1] */
    len  = vinfo[src].n_v;               /* #of words                 */
//EMAX5A begin tri_kernel1 mapdist=0
    for (INIT0=1,LOOP0=len,sofs=(0-4); LOOP0--; INIT0=0) {
      exe(OP_ADD,     &sofs,        sofs,           EXP_H3210, 4,           EXP_H3210,  0,              EXP_H3210,    OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL);
      mop(OP_LDWR, 1, &qid,         vpack[src].qid,            sofs,        MSK_W0,     vpack[src].qid, len,          0, 0,   NULL, 0);                          
      exe(OP_ADD,     &qidofs,      qid,            EXP_H3210, 0,           EXP_H3210,  0,              EXP_H3210,    OP_AND, 0x00000000ffffffffLL, OP_SLL, 2LL);
      mop(OP_LDWR, 1, &qinfo,       vinfo,                     qidofs,      MSK_W0,     vinfo,          nvertices,    0, 0,   NULL, 0);
      exe(OP_NOP,     &qinfo_depth, qinfo,          EXP_H3210, 0,           EXP_H3210,  0,              EXP_H3210,    OP_AND, 0x7fffffffLL,         OP_SRL, 16LL);
      exe(OP_CMP_EQ,  &cc3,         sdepth_m1,      EXP_H3210, qinfo_depth, EXP_H3210,  0,              EXP_H3210,    OP_AND, 1LL,                  OP_NOP, 0LL);
      exe(OP_CMP_EQ,  &cc2,         sdepth_p1,      EXP_H3210, qinfo_depth, EXP_H3210,  0,              EXP_H3210,    OP_AND, 1LL,                  OP_NOP, 0LL);
      exe(OP_CMP_EQ,  &cc1,         sdepth,         EXP_H3210, qinfo_depth, EXP_H3210,  0,              EXP_H3210,    OP_AND, 1LL,                  OP_NOP, 0LL);
      exe(OP_CMP_LT,  &cc0,         dst,            EXP_H3210, qid,         EXP_H3210,  0,              EXP_H3210,    OP_AND, 1LL,                  OP_NOP, 0LL);
      exe(OP_NOP,     &cand0,       cc1,            EXP_H3210, 0,           EXP_H3210,  0,              EXP_H3210,    OP_AND, cc0,                  OP_NOP, 0LL);
      exe(OP_NOP,     &cand1,       cc3,            EXP_H3210, 0,           EXP_H3210,  0,              EXP_H3210,    OP_OR,  cc2,                  OP_NOP, 0LL);
      exe(OP_NOP,     &cand2,       cand1,          EXP_H3210, 0,           EXP_H3210,  0,              EXP_H3210,    OP_OR,  cand0,                OP_NOP, 0LL);

      exe(OP_ADD,     &vsearchqid,  qid,            EXP_H3210, 0,           EXP_H3210,  0,              EXP_H3210,    OP_AND, 0x00000000ffffffffLL, OP_SLL, MAXN_BIT);
      exe(OP_ADD,     &vsearchtop,  vsearch,        EXP_H3210, vsearchqid,  EXP_H3210,  0,              EXP_H3210,    OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL);
      mop(OP_LDBR, 1, &search,      vsearchtop,                dst,         MSK_W0,     vsearch,        vsearchsize,  0, 0,   NULL, 0); /* search */

      exe(OP_NOP,     &tricount_ofs,cand2,          EXP_H3210, 0,           EXP_H3210,  0,              EXP_H3210,    OP_AND, search,               OP_NOP, 0LL);

      //tricount += tricount_ofs;
      mop(OP_LDWR, 1, &tricount_r,  tricount,                 0,            MSK_W0,     tricount,       1,            0, 1,   NULL, 0); /* curfront_e->n_e */
      exe(OP_ADD,     &tricount_r,  tricount_r,     EXP_H3210, tricount_ofs,EXP_H3210,  0,              EXP_H3210,    OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL);
      mop(OP_STWR, 1, &tricount_r,  tricount,                 0,            MSK_W0,     tricount,       1,            0, 1,   NULL, 0); /* curfront_e->n_e */
    }
//EMAX5A end
  }
#endif
\end{verbatim}
\end{screen}

\clearpage

\section{Image Recognition (ssim)}

MINST

\shabox{
\leftline{cent\% make -f Makefile-cent.emax6nc all clean}
\leftline{cent\% cd ../; ssim/ssim-cent.emax6nc -x -t -I0 -C1 -F1}
}

\shabox{
\leftline{zynq\% make -f Makefile-zynq.emax6+dma all clean}
\leftline{zynq\% cd ../; ssim/ssim-zynq.emax6+dma -x -t -I0 -C1 -F1}
}

\vskip .1in

CIFAR10

\shabox{
\leftline{cent\% make -f Makefile-cent.emax6nc all clean}
\leftline{cent\% cd ../; ssim/ssim-cent.emax6nc -x -t -I1 -C6 -F2}
}

\shabox{
\leftline{zynq\% make -f Makefile-zynq.emax6+dma all clean}
\leftline{zynq\% cd ../; ssim/ssim-zynq.emax6+dma -x -t -I1 -C6 -F2}
}

\begin{figure}[htbp]
\center
\includegraphics[angle=270,origin=b,width=1.00\textwidth]{ssim.eps}
\caption{Image recognition (training + inference)}
\end{figure}

\subsection{Cnn5x5}

\begin{screen}
\tiny
\begin{verbatim}
for (img=0; img<BATCH; img++) {
  for (top=0; top<M; top+=RMGRP) {
    for (iset=0; iset<IC; iset+=IMAP) {  /* accumulate multiple sets of IC */
      Uint *ip0  = &i_inp[(img*IC+iset+0)*IM*IM]; /* top of input#0 */
      Uint *it00 = ip0+top*IM, *ip00[25];
      ip00[ 0] = ip0+(top+0)*IM+0; ip00[ 1] = ip0+(top+0)*IM+1; ip00[ 2] = ip0+(top+0)*IM+2; ip00[ 3] = ip0+(top+0)*IM+3; ip00[ 4] = ip0+(top+0)*IM+4;
      ip00[ 5] = ip0+(top+1)*IM+0; ip00[ 6] = ip0+(top+1)*IM+1; ip00[ 7] = ip0+(top+1)*IM+2; ip00[ 8] = ip0+(top+1)*IM+3; ip00[ 9] = ip0+(top+1)*IM+4;
      ip00[10] = ip0+(top+2)*IM+0; ip00[11] = ip0+(top+2)*IM+1; ip00[12] = ip0+(top+2)*IM+2; ip00[13] = ip0+(top+2)*IM+3; ip00[14] = ip0+(top+2)*IM+4;
      ip00[15] = ip0+(top+3)*IM+0; ip00[16] = ip0+(top+3)*IM+1; ip00[17] = ip0+(top+3)*IM+2; ip00[18] = ip0+(top+3)*IM+3; ip00[19] = ip0+(top+3)*IM+4;
      ip00[20] = ip0+(top+4)*IM+0; ip00[21] = ip0+(top+4)*IM+1; ip00[22] = ip0+(top+4)*IM+2; ip00[23] = ip0+(top+4)*IM+3; ip00[24] = ip0+(top+4)*IM+4;

      for (oc=0; oc<OC4/NCHIP; oc+=W) { /* set output channel */
        Uint *kp00[NCHIP], *kp01[NCHIP], *kp02[NCHIP], *kp03[NCHIP];
        Uint *op0[NCHIP], *op1[NCHIP], *op2[NCHIP], *op3[NCHIP];
        Uint *ot0[NCHIP], *ot1[NCHIP], *ot2[NCHIP], *ot3[NCHIP];

        for (CHIP=0; CHIP<NCHIP; CHIP++) { /* output channels are parallelized by multi-chip (OC4/#chip) */
          Uint choc  = CHIP*OC4/NCHIP+oc;
          kp00[CHIP] = i_ker+((choc+0)*IC+iset+0)*K*K; kp01[CHIP] = i_ker+((choc+1)*IC+iset+0)*K*K;
          kp02[CHIP] = i_ker+((choc+2)*IC+iset+0)*K*K; kp03[CHIP] = i_ker+((choc+3)*IC+iset+0)*K*K;
          op0[CHIP] = i_out+(img*OC4+choc+0)*M*M+top*M; op1[CHIP] = i_out+(img*OC4+choc+1)*M*M+top*M;
          op2[CHIP] = i_out+(img*OC4+choc+2)*M*M+top*M; op3[CHIP] = i_out+(img*OC4+choc+3)*M*M+top*M;
          ot0[CHIP] = i_out+(img*OC4+choc+0)*M*M+top*M; ot1[CHIP] = i_out+(img*OC4+choc+1)*M*M+top*M;
          ot2[CHIP] = i_out+(img*OC4+choc+2)*M*M+top*M; ot3[CHIP] = i_out+(img*OC4+choc+3)*M*M+top*M;
        }

#define cnn5x5_core1(b, o, bp1, n) \
  mop(OP_LDWR,   1, &BR[b][0][1],  (Ull)kp00[CHIP], o, MSK_D0, (Ull)i_ker, Klen, 0, Force, (Ull)NULL, Klen);\
  mop(OP_LDWR,   1, &BR[b][0][0],  (Ull)kp01[CHIP], o, MSK_D0, (Ull)i_ker, Klen, 0, Force, (Ull)NULL, Klen);\
  mop(OP_LDWR,   1, &BR[b][1][1],  (Ull)kp02[CHIP], o, MSK_D0, (Ull)i_ker, Klen, 0, Force, (Ull)NULL, Klen);\
  mop(OP_LDWR,   1, &BR[b][1][0],  (Ull)kp03[CHIP], o, MSK_D0, (Ull)i_ker, Klen, 0, Force, (Ull)NULL, Klen);\
  mop(OP_LDWR,   1, &BR[b][2][1],  (Ull)ip00[n], iofs, MSK_W1, (Ull)it00, IMlen, 0, 0, (Ull)NULL, IMlen);\
  exe(OP_FMA, &AR[bp1][0], AR[b][0], EXP_H3210, BR[b][2][1], EXP_H3210, BR[b][0][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
  exe(OP_FMA, &AR[bp1][1], AR[b][1], EXP_H3210, BR[b][2][1], EXP_H3210, BR[b][0][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
  exe(OP_FMA, &AR[bp1][2], AR[b][2], EXP_H3210, BR[b][2][1], EXP_H3210, BR[b][1][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
  exe(OP_FMA, &AR[bp1][3], AR[b][3], EXP_H3210, BR[b][2][1], EXP_H3210, BR[b][1][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL)

#define cnn5x5_final(b, bp1) \
  mop(OP_LDWR,   1, &BR[bp1][0][1],  (Ull)op0[CHIP], oofs, MSK_W0, (Ull)ot0[CHIP], Mlen, 0, 1, (Ull)NULL, Mlen);\
  mop(OP_LDWR,   1, &BR[bp1][1][1],  (Ull)op1[CHIP], oofs, MSK_W0, (Ull)ot1[CHIP], Mlen, 0, 1, (Ull)NULL, Mlen);\
  mop(OP_LDWR,   1, &BR[bp1][2][1],  (Ull)op2[CHIP], oofs, MSK_W0, (Ull)ot2[CHIP], Mlen, 0, 1, (Ull)NULL, Mlen);\
  mop(OP_LDWR,   1, &BR[bp1][3][1],  (Ull)op3[CHIP], oofs, MSK_W0, (Ull)ot3[CHIP], Mlen, 0, 1, (Ull)NULL, Mlen);\
  exe(OP_FAD, &AR[bp1][0], AR[b][0], EXP_H3210, BR[bp1][0][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
  exe(OP_FAD, &AR[bp1][1], AR[b][1], EXP_H3210, BR[bp1][1][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
  exe(OP_FAD, &AR[bp1][2], AR[b][2], EXP_H3210, BR[bp1][2][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
  exe(OP_FAD, &AR[bp1][3], AR[b][3], EXP_H3210, BR[bp1][3][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
  mop(OP_STWR,   1, &AR[bp1][0], oofs, (Ull)op0[CHIP], MSK_D0, (Ull)ot0[CHIP], Mlen, 0, 1, (Ull)NULL, Mlen);\
  mop(OP_STWR,   1, &AR[bp1][1], oofs, (Ull)op1[CHIP], MSK_D0, (Ull)ot1[CHIP], Mlen, 0, 1, (Ull)NULL, Mlen);\
  mop(OP_STWR,   1, &AR[bp1][2], oofs, (Ull)op2[CHIP], MSK_D0, (Ull)ot2[CHIP], Mlen, 0, 1, (Ull)NULL, Mlen);\
  mop(OP_STWR,   1, &AR[bp1][3], oofs, (Ull)op3[CHIP], MSK_D0, (Ull)ot3[CHIP], Mlen, 0, 1, (Ull)NULL, Mlen)

//EMAX5A begin cnn5x5 mapdist=0
/*3*/ for (CHIP=0; CHIP<NCHIP; CHIP++) { /* output channels are parallelized by multi-chip (OC4/#chip) */
  /*2*/ for (INIT1=1,LOOP1=RMGRP,rofs=(0-IM4)<<32|((0-M4)&0xffffffff); LOOP1--; INIT1=0) {                      /* mapped to FOR() on BR[63][1][0] */ /* stage#0 */
    /*1*/ for (INIT0=1,LOOP0=M,cofs=(0-4LL)<<32|((0-4LL)&0xffffffff); LOOP0--; INIT0=0) {                       /* mapped to FOR() on BR[63][0][0] */ /* stage#0 */
            exe(OP_ADD,    &rofs, rofs,            EXP_H3210, INIT0?IM4M4:0, EXP_H3210, 0LL, EXP_H3210, OP_NOP,   0LL,                  OP_NOP, 0LL); /* stage#0 */
            exe(OP_ADD,    &cofs, INIT0?cofs:cofs, EXP_H3210, 4LL<<32|4LL,   EXP_H3210, 0LL, EXP_H3210, OP_AND,   0xffffffffffffffffLL, OP_NOP, 0LL); /* stage#0 */
            exe(OP_ADD,    &iofs, rofs,            EXP_H3210, cofs,          EXP_H3210, 0LL, EXP_H3210, OP_AND,   0xffffffff00000000LL, OP_NOP, 0LL); /* stage#1 */
            exe(OP_ADD,    &oofs, rofs,            EXP_H3210, cofs,          EXP_H3210, 0LL, EXP_H3210, OP_AND,   0x00000000ffffffffLL, OP_NOP, 0LL); /* stage#1 */

            /****in0*****/
            mop(OP_LDWR,   1, &BR[2][0][1],  (Ull)kp00[CHIP], 0LL, MSK_D0, (Ull)i_ker, Klen, 0, Force, (Ull)NULL, Klen); /* stage#2 */
            mop(OP_LDWR,   1, &BR[2][0][0],  (Ull)kp01[CHIP], 0LL, MSK_D0, (Ull)i_ker, Klen, 0, Force, (Ull)NULL, Klen); /* stage#2 */
            mop(OP_LDWR,   1, &BR[2][1][1],  (Ull)kp02[CHIP], 0LL, MSK_D0, (Ull)i_ker, Klen, 0, Force, (Ull)NULL, Klen); /* stage#2 */
            mop(OP_LDWR,   1, &BR[2][1][0],  (Ull)kp03[CHIP], 0LL, MSK_D0, (Ull)i_ker, Klen, 0, Force, (Ull)NULL, Klen); /* stage#2 10KB */
            mop(OP_LDWR,   1, &BR[2][2][1],  (Ull)ip00[0],   iofs, MSK_W1, (Ull)it00, IMlen, 0, 0, (Ull)NULL, IMlen);    /* stage#2 10KB */
            exe(OP_FML, &AR[3][0], BR[2][2][1], EXP_H3210, BR[2][0][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#3 */
            exe(OP_FML, &AR[3][1], BR[2][2][1], EXP_H3210, BR[2][0][0], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#3 */
            exe(OP_FML, &AR[3][2], BR[2][2][1], EXP_H3210, BR[2][1][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#3 */
            exe(OP_FML, &AR[3][3], BR[2][2][1], EXP_H3210, BR[2][1][0], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#3 */
            cnn5x5_core1( 3, 4LL, 4, 1);
            cnn5x5_core1( 4, 8LL, 5, 2);
            cnn5x5_core1( 5,12LL, 6, 3);
            cnn5x5_core1( 6,16LL, 7, 4);
            cnn5x5_core1( 7,20LL, 8, 5);
            cnn5x5_core1( 8,24LL, 9, 6);
            cnn5x5_core1( 9,28LL,10, 7);
            cnn5x5_core1(10,32LL,11, 8);
            cnn5x5_core1(11,36LL,12, 9);
            cnn5x5_core1(12,40LL,13,10);
            cnn5x5_core1(13,44LL,14,11);
            cnn5x5_core1(14,48LL,15,12);
            cnn5x5_core1(15,52LL,16,13);
            cnn5x5_core1(16,56LL,17,14);
            cnn5x5_core1(17,60LL,18,15);
            cnn5x5_core1(18,64LL,19,16);
            cnn5x5_core1(19,68LL,20,17);
            cnn5x5_core1(20,72LL,21,18);
            cnn5x5_core1(21,76LL,22,19);
            cnn5x5_core1(22,80LL,23,20);
            cnn5x5_core1(23,84LL,24,21);
            cnn5x5_core1(24,88LL,25,22);
            cnn5x5_core1(25,92LL,26,23);
            cnn5x5_core1(26,96LL,27,24);
            /****final*****/
            cnn5x5_final(27,     28);
      } } }
//EMAX5A end
      if (Force) Force = 0;
} } } }
//EMAX5A drain_dirty_lmm
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\epsfile{file=imax-cnn5x5-emax6.eps,width=1.00\textwidth}
\caption{5x5 Convolution}
\end{figure}

\clearpage

\subsection{Cnn3x3}

\begin{screen}
\tiny
\begin{verbatim}
for (img=0; img<BATCH; img++) {
  for (top=0; top<M; top+=RMGRP) {
    for (iset=0; iset<IC; iset+=IMAP) {  /* accumulate multiple sets of IC */
      Uint *ip0  = &i_inp[(img*IC+iset+0)*IM*IM]; /* top of input#0 */
      Uint *it00 = ip0+top*IM, *ip00[9];
      ip00[0] = ip0+(top+0)*IM+0; ip00[1] = ip0+(top+0)*IM+1; ip00[2] = ip0+(top+0)*IM+2;
      ip00[3] = ip0+(top+1)*IM+0; ip00[4] = ip0+(top+1)*IM+1; ip00[5] = ip0+(top+1)*IM+2;
      ip00[6] = ip0+(top+2)*IM+0; ip00[7] = ip0+(top+2)*IM+1; ip00[8] = ip0+(top+2)*IM+2;

      for (oc=0; oc<OC4/NCHIP; oc+=W) { /* set output channel */
        Uint *kp00[NCHIP], *kp01[NCHIP], *kp02[NCHIP], *kp03[NCHIP];
        Uint *op0[NCHIP], *op1[NCHIP], *op2[NCHIP], *op3[NCHIP];
        Uint *ot0[NCHIP], *ot1[NCHIP], *ot2[NCHIP], *ot3[NCHIP];

        for (CHIP=0; CHIP<NCHIP; CHIP++) { /* output channels are parallelized by multi-chip (OC4/#chip) */
          Uint choc  = CHIP*OC4/NCHIP+oc;
          kp00[CHIP] = i_ker+((choc+0)*IC+iset+0)*K*K; kp01[CHIP] = i_ker+((choc+1)*IC+iset+0)*K*K;
          kp02[CHIP] = i_ker+((choc+2)*IC+iset+0)*K*K; kp03[CHIP] = i_ker+((choc+3)*IC+iset+0)*K*K;
          op0[CHIP] = i_out+(img*OC4+choc+0)*M*M+top*M; op1[CHIP] = i_out+(img*OC4+choc+1)*M*M+top*M;
          op2[CHIP] = i_out+(img*OC4+choc+2)*M*M+top*M; op3[CHIP] = i_out+(img*OC4+choc+3)*M*M+top*M;
          ot0[CHIP] = i_out+(img*OC4+choc+0)*M*M+top*M; ot1[CHIP] = i_out+(img*OC4+choc+1)*M*M+top*M;
          ot2[CHIP] = i_out+(img*OC4+choc+2)*M*M+top*M; ot3[CHIP] = i_out+(img*OC4+choc+3)*M*M+top*M;
        }

#define cnn3x3_core1(b, o, bp1, n) \
  mop(OP_LDWR,   1, &BR[b][0][1],  (Ull)kp00[CHIP], o, MSK_D0, (Ull)i_ker, Klen, 0, Force, (Ull)NULL, Klen);\
  mop(OP_LDWR,   1, &BR[b][0][0],  (Ull)kp01[CHIP], o, MSK_D0, (Ull)i_ker, Klen, 0, Force, (Ull)NULL, Klen);\
  mop(OP_LDWR,   1, &BR[b][1][1],  (Ull)kp02[CHIP], o, MSK_D0, (Ull)i_ker, Klen, 0, Force, (Ull)NULL, Klen);\
  mop(OP_LDWR,   1, &BR[b][1][0],  (Ull)kp03[CHIP], o, MSK_D0, (Ull)i_ker, Klen, 0, Force, (Ull)NULL, Klen);\
  mop(OP_LDWR,   1, &BR[b][2][1],  (Ull)ip00[n], iofs, MSK_W1, (Ull)it00, IMlen, 0, 0, (Ull)NULL, IMlen);\
  exe(OP_FMA, &AR[bp1][0], AR[b][0], EXP_H3210, BR[b][2][1], EXP_H3210, BR[b][0][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
  exe(OP_FMA, &AR[bp1][1], AR[b][1], EXP_H3210, BR[b][2][1], EXP_H3210, BR[b][0][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
  exe(OP_FMA, &AR[bp1][2], AR[b][2], EXP_H3210, BR[b][2][1], EXP_H3210, BR[b][1][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
  exe(OP_FMA, &AR[bp1][3], AR[b][3], EXP_H3210, BR[b][2][1], EXP_H3210, BR[b][1][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL)

#define cnn3x3_final(b, bp1) \
  mop(OP_LDWR,   1, &BR[bp1][0][1],  (Ull)op0[CHIP], oofs, MSK_W0, (Ull)ot0[CHIP], Mlen, 0, 1, (Ull)NULL, Mlen);\
  mop(OP_LDWR,   1, &BR[bp1][1][1],  (Ull)op1[CHIP], oofs, MSK_W0, (Ull)ot1[CHIP], Mlen, 0, 1, (Ull)NULL, Mlen);\
  mop(OP_LDWR,   1, &BR[bp1][2][1],  (Ull)op2[CHIP], oofs, MSK_W0, (Ull)ot2[CHIP], Mlen, 0, 1, (Ull)NULL, Mlen);\
  mop(OP_LDWR,   1, &BR[bp1][3][1],  (Ull)op3[CHIP], oofs, MSK_W0, (Ull)ot3[CHIP], Mlen, 0, 1, (Ull)NULL, Mlen);\
  exe(OP_FAD, &AR[bp1][0], AR[b][0], EXP_H3210, BR[bp1][0][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
  exe(OP_FAD, &AR[bp1][1], AR[b][1], EXP_H3210, BR[bp1][1][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
  exe(OP_FAD, &AR[bp1][2], AR[b][2], EXP_H3210, BR[bp1][2][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
  exe(OP_FAD, &AR[bp1][3], AR[b][3], EXP_H3210, BR[bp1][3][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
  mop(OP_STWR,   1, &AR[bp1][0], oofs, (Ull)op0[CHIP], MSK_D0, (Ull)ot0[CHIP], Mlen, 0, 1, (Ull)NULL, Mlen);\
  mop(OP_STWR,   1, &AR[bp1][1], oofs, (Ull)op1[CHIP], MSK_D0, (Ull)ot1[CHIP], Mlen, 0, 1, (Ull)NULL, Mlen);\
  mop(OP_STWR,   1, &AR[bp1][2], oofs, (Ull)op2[CHIP], MSK_D0, (Ull)ot2[CHIP], Mlen, 0, 1, (Ull)NULL, Mlen);\
  mop(OP_STWR,   1, &AR[bp1][3], oofs, (Ull)op3[CHIP], MSK_D0, (Ull)ot3[CHIP], Mlen, 0, 1, (Ull)NULL, Mlen)

//EMAX5A begin cnn3x3 mapdist=0
/*3*/ for (CHIP=0; CHIP<NCHIP; CHIP++) { /* output channels are parallelized by multi-chip (OC4/#chip) */
  /*2*/ for (INIT1=1,LOOP1=RMGRP,rofs=(0-IM4)<<32|((0-M4)&0xffffffff); LOOP1--; INIT1=0) {                      /* mapped to FOR() on BR[63][1][0] */ /* stage#0 */
    /*1*/ for (INIT0=1,LOOP0=M,cofs=(0-4LL)<<32|((0-4LL)&0xffffffff); LOOP0--; INIT0=0) {                       /* mapped to FOR() on BR[63][0][0] */ /* stage#0 */
            exe(OP_ADD,    &rofs, rofs,            EXP_H3210, INIT0?IM4M4:0, EXP_H3210, 0LL, EXP_H3210, OP_NOP,   0LL,                  OP_NOP, 0LL); /* stage#0 */
            exe(OP_ADD,    &cofs, INIT0?cofs:cofs, EXP_H3210, 4LL<<32|4LL,   EXP_H3210, 0LL, EXP_H3210, OP_AND,   0xffffffffffffffffLL, OP_NOP, 0LL); /* stage#0 */
            exe(OP_ADD,    &iofs, rofs,            EXP_H3210, cofs,          EXP_H3210, 0LL, EXP_H3210, OP_AND,   0xffffffff00000000LL, OP_NOP, 0LL); /* stage#1 */
            exe(OP_ADD,    &oofs, rofs,            EXP_H3210, cofs,          EXP_H3210, 0LL, EXP_H3210, OP_AND,   0x00000000ffffffffLL, OP_NOP, 0LL); /* stage#1 */

            /****in0*****/
            mop(OP_LDWR,   1, &BR[2][0][1],  (Ull)kp00[CHIP], 0LL, MSK_D0, (Ull)i_ker, Klen, 0, Force, (Ull)NULL, Klen); /* stage#2 */
            mop(OP_LDWR,   1, &BR[2][0][0],  (Ull)kp01[CHIP], 0LL, MSK_D0, (Ull)i_ker, Klen, 0, Force, (Ull)NULL, Klen); /* stage#2 */
            mop(OP_LDWR,   1, &BR[2][1][1],  (Ull)kp02[CHIP], 0LL, MSK_D0, (Ull)i_ker, Klen, 0, Force, (Ull)NULL, Klen); /* stage#2 */
            mop(OP_LDWR,   1, &BR[2][1][0],  (Ull)kp03[CHIP], 0LL, MSK_D0, (Ull)i_ker, Klen, 0, Force, (Ull)NULL, Klen); /* stage#2 10KB */
            mop(OP_LDWR,   1, &BR[2][2][1],  (Ull)ip00[0],   iofs, MSK_W1, (Ull)it00, IMlen, 0, 0, (Ull)NULL, IMlen);    /* stage#2 10KB */
            exe(OP_FML, &AR[3][0], BR[2][2][1], EXP_H3210, BR[2][0][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#3 */
            exe(OP_FML, &AR[3][1], BR[2][2][1], EXP_H3210, BR[2][0][0], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#3 */
            exe(OP_FML, &AR[3][2], BR[2][2][1], EXP_H3210, BR[2][1][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#3 */
            exe(OP_FML, &AR[3][3], BR[2][2][1], EXP_H3210, BR[2][1][0], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#3 */
            cnn3x3_core1( 3, 4LL, 4, 1);
            cnn3x3_core1( 4, 8LL, 5, 2);
            cnn3x3_core1( 5,12LL, 6, 3);
            cnn3x3_core1( 6,16LL, 7, 4);
            cnn3x3_core1( 7,20LL, 8, 5);
            cnn3x3_core1( 8,24LL, 9, 6);
            cnn3x3_core1( 9,28LL,10, 7);
            cnn3x3_core1(10,32LL,11, 8);
            /****final*****/
            cnn3x3_final(11,     12);
      } } }
//EMAX5A end
      if (Force) Force = 0;
} } } }
//EMAX5A drain_dirty_lmm
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\epsfile{file=imax-cnn3x3-emax6.eps,width=1.00\textwidth}
\caption{3x3 Convolution}
\end{figure}

\clearpage

\subsection{Cnn2x2}

\begin{screen}
\tiny
\begin{verbatim}
for (top=0; top<M; top+=RMGRP) {
  for (iset=0; iset<IC; iset+=IMAP) {  /* accumulate multiple sets of IC */
    Uint *ip0  = &i_inp[iset*IM*BATCH*IM]; /* top of input#0 */
    Uint *it00 = ip0+top*IM*BATCH, *ip00[4];
    ip00[0] = ip0+(top+0)*IM*BATCH+0; ip00[1] = ip0+(top+0)*IM*BATCH+1;
    ip00[2] = ip0+(top+1)*IM*BATCH+0; ip00[3] = ip0+(top+1)*IM*BATCH+1;

    for (rofs=0; rofs<RMGRP&&(top+rofs)<M; rofs++) { /* image loop (row) */

      for (oc=0; oc<OC4/NCHIP; oc+=W) { /* set output channel */
        Uint *kp00[NCHIP], *kp01[NCHIP], *kp02[NCHIP], *kp03[NCHIP];
        Uint *op0[NCHIP], *op1[NCHIP], *op2[NCHIP], *op3[NCHIP];
        Uint *ot0[NCHIP], *ot1[NCHIP], *ot2[NCHIP], *ot3[NCHIP];

        for (CHIP=0; CHIP<NCHIP; CHIP++) { /* output channels are parallelized by multi-chip (OC4/#chip) */
          Uint choc  = CHIP*OC4/NCHIP+oc;
          kp00[CHIP] = i_ker+((choc+0)*IC+iset+0)*K*K; kp01[CHIP] = i_ker+((choc+1)*IC+iset+0)*K*K;
          kp02[CHIP] = i_ker+((choc+2)*IC+iset+0)*K*K; kp03[CHIP] = i_ker+((choc+3)*IC+iset+0)*K*K;
          op0[CHIP] = i_out+((choc+0)*M+top)*M*BATCH; op1[CHIP] = i_out+((choc+1)*M+top)*M*BATCH;
          op2[CHIP] = i_out+((choc+2)*M+top)*M*BATCH; op3[CHIP] = i_out+((choc+3)*M+top)*M*BATCH;
          ot0[CHIP] = i_out+((choc+0)*M+top)*M*BATCH; ot1[CHIP] = i_out+((choc+1)*M+top)*M*BATCH;
          ot2[CHIP] = i_out+((choc+2)*M+top)*M*BATCH; ot3[CHIP] = i_out+((choc+3)*M+top)*M*BATCH;
        }

#define cnn2x2_core1(b, o, bp1, n) \
  mop(OP_LDWR,   1, &BR[b][0][1],  (Ull)kp00[CHIP], o, MSK_D0, (Ull)i_ker, Klen, 0, Force, (Ull)NULL, Klen);\
  mop(OP_LDWR,   1, &BR[b][0][0],  (Ull)kp01[CHIP], o, MSK_D0, (Ull)i_ker, Klen, 0, Force, (Ull)NULL, Klen);\
  mop(OP_LDWR,   1, &BR[b][1][1],  (Ull)kp02[CHIP], o, MSK_D0, (Ull)i_ker, Klen, 0, Force, (Ull)NULL, Klen);\
  mop(OP_LDWR,   1, &BR[b][1][0],  (Ull)kp03[CHIP], o, MSK_D0, (Ull)i_ker, Klen, 0, Force, (Ull)NULL, Klen);\
  mop(OP_LDWR,   1, &BR[b][2][1],  (Ull)ip00[n], iofs, MSK_W1, (Ull)it00, IMlen, 0, 0, (Ull)NULL, IMlen);\
  exe(OP_FMA, &AR[bp1][0], AR[b][0], EXP_H3210, BR[b][2][1], EXP_H3210, BR[b][0][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
  exe(OP_FMA, &AR[bp1][1], AR[b][1], EXP_H3210, BR[b][2][1], EXP_H3210, BR[b][0][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
  exe(OP_FMA, &AR[bp1][2], AR[b][2], EXP_H3210, BR[b][2][1], EXP_H3210, BR[b][1][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
  exe(OP_FMA, &AR[bp1][3], AR[b][3], EXP_H3210, BR[b][2][1], EXP_H3210, BR[b][1][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL)

#define cnn2x2_final(b, bp1) \
  mop(OP_LDWR,   1, &BR[bp1][0][1],  (Ull)op0[CHIP], oofs, MSK_W0, (Ull)ot0[CHIP], Mlen, 0, 1, (Ull)NULL, Mlen);\
  mop(OP_LDWR,   1, &BR[bp1][1][1],  (Ull)op1[CHIP], oofs, MSK_W0, (Ull)ot1[CHIP], Mlen, 0, 1, (Ull)NULL, Mlen);\
  mop(OP_LDWR,   1, &BR[bp1][2][1],  (Ull)op2[CHIP], oofs, MSK_W0, (Ull)ot2[CHIP], Mlen, 0, 1, (Ull)NULL, Mlen);\
  mop(OP_LDWR,   1, &BR[bp1][3][1],  (Ull)op3[CHIP], oofs, MSK_W0, (Ull)ot3[CHIP], Mlen, 0, 1, (Ull)NULL, Mlen);\
  exe(OP_FAD, &AR[bp1][0], AR[b][0], EXP_H3210, BR[bp1][0][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
  exe(OP_FAD, &AR[bp1][1], AR[b][1], EXP_H3210, BR[bp1][1][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
  exe(OP_FAD, &AR[bp1][2], AR[b][2], EXP_H3210, BR[bp1][2][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
  exe(OP_FAD, &AR[bp1][3], AR[b][3], EXP_H3210, BR[bp1][3][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
  mop(OP_STWR,   1, &AR[bp1][0], oofs, (Ull)op0[CHIP], MSK_D0, (Ull)ot0[CHIP], Mlen, 0, 1, (Ull)NULL, Mlen);\
  mop(OP_STWR,   1, &AR[bp1][1], oofs, (Ull)op1[CHIP], MSK_D0, (Ull)ot1[CHIP], Mlen, 0, 1, (Ull)NULL, Mlen);\
  mop(OP_STWR,   1, &AR[bp1][2], oofs, (Ull)op2[CHIP], MSK_D0, (Ull)ot2[CHIP], Mlen, 0, 1, (Ull)NULL, Mlen);\
  mop(OP_STWR,   1, &AR[bp1][3], oofs, (Ull)op3[CHIP], MSK_D0, (Ull)ot3[CHIP], Mlen, 0, 1, (Ull)NULL, Mlen)

//EMAX5A begin cnn2x2 mapdist=0
/*3*/ for (CHIP=0; CHIP<NCHIP; CHIP++) { /* output channels are parallelized by multi-chip (OC4/#chip) */
  /*2*/ for (INIT1=1,LOOP1=BATCH,img=(0-IM4)<<32|((0-M4)&0xffffffff); LOOP1--; INIT1=0) {                       /* mapped to FOR() on BR[63][1][0] */ /* stage#0 */
    /*1*/ for (INIT0=1,LOOP0=M,cofs=(0-4LL)<<32|((0-4LL)&0xffffffff); LOOP0--; INIT0=0) {                       /* mapped to FOR() on BR[63][0][0] */ /* stage#0 */
            exe(OP_ADD,    &img,  img,             EXP_H3210, INIT0?IM4M4:0, EXP_H3210, 0LL, EXP_H3210, OP_NOP,   0LL,                  OP_NOP, 0LL); /* stage#0 */
            exe(OP_ADD,    &cofs, INIT0?cofs:cofs, EXP_H3210, 4LL<<32|4LL,   EXP_H3210, 0LL, EXP_H3210, OP_AND,   0xffffffffffffffffLL, OP_NOP, 0LL); /* stage#0 */
            exe(OP_ADD,    &iofs, img,             EXP_H3210, cofs,          EXP_H3210, 0LL, EXP_H3210, OP_AND,   0xffffffff00000000LL, OP_NOP, 0LL); /* stage#1 */
            exe(OP_ADD,    &oofs, img,             EXP_H3210, cofs,          EXP_H3210, 0LL, EXP_H3210, OP_AND,   0x00000000ffffffffLL, OP_NOP, 0LL); /* stage#1 */

            /****in0*****/
            mop(OP_LDWR,   1, &BR[2][0][1],  (Ull)kp00[CHIP], 0LL, MSK_D0, (Ull)i_ker, Klen, 0, Force, (Ull)NULL, Klen); /* stage#2 */
            mop(OP_LDWR,   1, &BR[2][0][0],  (Ull)kp01[CHIP], 0LL, MSK_D0, (Ull)i_ker, Klen, 0, Force, (Ull)NULL, Klen); /* stage#2 */
            mop(OP_LDWR,   1, &BR[2][1][1],  (Ull)kp02[CHIP], 0LL, MSK_D0, (Ull)i_ker, Klen, 0, Force, (Ull)NULL, Klen); /* stage#2 */
            mop(OP_LDWR,   1, &BR[2][1][0],  (Ull)kp03[CHIP], 0LL, MSK_D0, (Ull)i_ker, Klen, 0, Force, (Ull)NULL, Klen); /* stage#2 10KB */
            mop(OP_LDWR,   1, &BR[2][2][1],  (Ull)ip00[0],   iofs, MSK_W1, (Ull)it00, IMlen, 0, 0, (Ull)NULL, IMlen);    /* stage#2 10KB */
            exe(OP_FML, &AR[3][0], BR[2][2][1], EXP_H3210, BR[2][0][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#3 */
            exe(OP_FML, &AR[3][1], BR[2][2][1], EXP_H3210, BR[2][0][0], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#3 */
            exe(OP_FML, &AR[3][2], BR[2][2][1], EXP_H3210, BR[2][1][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#3 */
            exe(OP_FML, &AR[3][3], BR[2][2][1], EXP_H3210, BR[2][1][0], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL); /* stage#3 */
            cnn2x2_core1( 3, 4LL, 4, 1);
            cnn2x2_core1( 4, 8LL, 5, 2);
            cnn2x2_core1( 5,12LL, 6, 3);
            /****final*****/
            cnn2x2_final( 6,      7);
      } } }
//EMAX5A end
      if (Force) Force = 0;
} } } }
//EMAX5A drain_dirty_lmm
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\epsfile{file=imax-cnn2x2-emax6.eps,width=1.00\textwidth}
\caption{2x2 Convolution}
\end{figure}

\clearpage

\subsection{Sgemm00}

\begin{screen}
\tiny
\begin{verbatim}
for (top=0; top<m/NCHIP; top+=RMGRP) { /* will be parallelized by multi-chip (M/#chip) */
  for (blk=0; blk<ka; blk+=H) { /* 3重ループ展開の外側対象 */
    typedef struct {Uint i[4]} Ui4;
    Uint *a0[NCHIP];
    Uint *a[H][NCHIP];
    Ui4  *b[H], *b0[H], *b1[H], *b2[H], *b3[H];
    Ui4  *c0[NCHIP];
    Ui4  *c00[NCHIP], *c01[NCHIP], *c02[NCHIP], *c03[NCHIP];
    for (k=0; k<H; k++) {
      b[k] = i_m0B+(blk+k)*n; b0[k] = b[k]; b1[k] = (Uint*)b[k]+1; b2[k] = (Uint*)b[k]+2;  b3[k] = (Uint*)b[k]+3;
    }
    for (CHIP=0; CHIP<NCHIP; CHIP++) { /* will be parallelized by multi-chip (M/#chip) */
      a0[CHIP] = i_m0A+(CHIP*m/NCHIP+top)*ka;
      for (k=0; k<H; k++)
        a[k][CHIP] = a0[CHIP]+blk+k;
      c0[CHIP] = i_m0C+(CHIP*m/NCHIP+top)*n;
      c00[CHIP]= (Uint*)c0[CHIP]+0; c01[CHIP]= (Uint*)c0[CHIP]+1; c02[CHIP]= (Uint*)c0[CHIP]+2; c03[CHIP]= (Uint*)c0[CHIP]+3;
    }
    cofslimit1 = n4- 4; /* cofs32 < 36 x */
    cofslimit2 = n4- 8; /* cofs32 < 32 x */
    cofslimit3 = n4-12; /* cofs32 < 28 x */

#define sgemm00_core1(r, rm1, rp1) \
        mop(OP_LDWR,   1, &BR[r][0][1],  (Ull)b0[rm1], (Ull)cofs, MSK_W1, (Ull)b[rm1], Blen, 0, 0, (Ull)NULL, Blen);\
        mop(OP_LDWR,   1, &BR[r][0][0],  (Ull)b1[rm1], (Ull)cofs, MSK_W1, (Ull)b[rm1], Blen, 0, 0, (Ull)NULL, Blen);\
        mop(OP_LDWR,   1, &BR[r][1][1],  (Ull)b2[rm1], (Ull)cofs, MSK_W1, (Ull)b[rm1], Blen, 0, 0, (Ull)NULL, Blen);\
        mop(OP_LDWR,   1, &BR[r][1][0],  (Ull)b3[rm1], (Ull)cofs, MSK_W1, (Ull)b[rm1], Blen, 0, 0, (Ull)NULL, Blen);\
        mop(OP_LDWR,   1, &BR[r][2][1],  (Ull)a[rm1][CHIP],  (Ull)rofs, MSK_W1, (Ull)a0[CHIP], Alen, 0, 0, (Ull)NULL, Alen);\
        exe(OP_FMA, &AR[rp1][0], AR[r][0], EXP_H3210,  BR[r][2][1], EXP_H3210, BR[r][0][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
        exe(OP_FMA, &AR[rp1][1], AR[r][1], EXP_H3210,  BR[r][2][1], EXP_H3210, BR[r][0][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
        exe(OP_FMA, &AR[rp1][2], AR[r][2], EXP_H3210,  BR[r][2][1], EXP_H3210, BR[r][1][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
        exe(OP_FMA, &AR[rp1][3], AR[r][3], EXP_H3210,  BR[r][2][1], EXP_H3210, BR[r][1][0], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL)

#define sgemm00_final(r, rp1) \
        exe(OP_CMP_LT,   &cc1, cofs, EXP_H3210, cofslimit1, EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
        exe(OP_CMP_LT,   &cc2, cofs, EXP_H3210, cofslimit2, EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
        exe(OP_CMP_LT,   &cc3, cofs, EXP_H3210, cofslimit3, EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
        mop(OP_LDWR,   1, &BR[rp1][0][1],  (Ull)c00[CHIP], (Ull)oofs, MSK_W0, (Ull)c0[CHIP], Clen, 0, 1, (Ull)NULL, Clen);\
        mop(OP_LDWR,   1, &BR[rp1][1][1],  (Ull)c01[CHIP], (Ull)oofs, MSK_W0, (Ull)c0[CHIP], Clen, 0, 1, (Ull)NULL, Clen);\
        mop(OP_LDWR,   1, &BR[rp1][2][1],  (Ull)c02[CHIP], (Ull)oofs, MSK_W0, (Ull)c0[CHIP], Clen, 0, 1, (Ull)NULL, Clen);\
        mop(OP_LDWR,   1, &BR[rp1][3][1],  (Ull)c03[CHIP], (Ull)oofs, MSK_W0, (Ull)c0[CHIP], Clen, 0, 1, (Ull)NULL, Clen);\
        exe(OP_FAD, &AR[rp1][0], AR[r][0], EXP_H3210,  BR[rp1][0][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
        exe(OP_FAD, &AR[rp1][1], AR[r][1], EXP_H3210,  BR[rp1][1][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
        exe(OP_FAD, &AR[rp1][2], AR[r][2], EXP_H3210,  BR[rp1][2][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
        exe(OP_FAD, &AR[rp1][3], AR[r][3], EXP_H3210,  BR[rp1][3][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);\
        mop(OP_STWR,   1, &AR[rp1][0],     (Ull)oofs, (Ull)c00[CHIP], MSK_D0, (Ull)c0[CHIP], Clen, 0, 1, (Ull)NULL, Clen);\
        cex(OP_CEXE,      &ex1,   0, 0, 0, cc1, 0xaaaa);\
        mop(OP_STWR, ex1, &AR[rp1][1],     (Ull)oofs, (Ull)c01[CHIP], MSK_D0, (Ull)c0[CHIP], Clen, 0, 1, (Ull)NULL, Clen);\
        cex(OP_CEXE,      &ex2,   0, 0, 0, cc2, 0xaaaa);\
        mop(OP_STWR, ex2, &AR[rp1][2],     (Ull)oofs, (Ull)c02[CHIP], MSK_D0, (Ull)c0[CHIP], Clen, 0, 1, (Ull)NULL, Clen);\
        cex(OP_CEXE,      &ex3,   0, 0, 0, cc3, 0xaaaa);\
        mop(OP_STWR, ex3, &AR[rp1][3],     (Ull)oofs, (Ull)c03[CHIP], MSK_D0, (Ull)c0[CHIP], Clen, 0, 1, (Ull)NULL, Clen)

//EMAX5A begin sgemm00 mapdist=0
/*3*/ for (CHIP=0; CHIP<NCHIP; CHIP++) { /* will be parallelized by multi-chip (M/#chip) */
  /*2*/ for (INIT1=1,LOOP1=RMGRP,rofs=(0-KA4)<<32|((0-n4)&0xffffffff); LOOP1--; INIT1=0) { /* stage#0 *//* mapped to FOR() on BR[63][1][0] */
    /*1*/ for (INIT0=1,LOOP0=N/W,cofs=(0-W*4)<<32|((0-W*4)&0xffffffff); LOOP0--; INIT0=0) {  /* stage#0 *//* mapped to FOR() on BR[63][0][0] */
            exe(OP_ADD,    &cofs, INIT0?cofs:cofs, EXP_H3210, (W*4)<<32|(W*4), EXP_H3210, 0LL, EXP_H3210, OP_AND, 0xffffffffffffffffLL, OP_NOP, 0LL);/* stage#0 */
            exe(OP_ADD,    &rofs, rofs, EXP_H3210, INIT0?KA4n4:0, EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);       /* stage#0 */
            exe(OP_ADD,    &oofs, rofs, EXP_H3210, cofs, EXP_H3210, 0, EXP_H3210, OP_AND, 0xffffffff, OP_NOP, 0LL);           /* stage#1 */

            mop(OP_LDWR,   1, &BR[1][0][1],  (Ull)b0[0], (Ull)cofs, MSK_W1, (Ull)b[0], Blen, 0, 0, (Ull)NULL, Blen);          /* stage#1 */
            mop(OP_LDWR,   1, &BR[1][0][0],  (Ull)b1[0], (Ull)cofs, MSK_W1, (Ull)b[0], Blen, 0, 0, (Ull)NULL, Blen);          /* stage#1 */
            mop(OP_LDWR,   1, &BR[1][1][1],  (Ull)b2[0], (Ull)cofs, MSK_W1, (Ull)b[0], Blen, 0, 0, (Ull)NULL, Blen);          /* stage#1 */
            mop(OP_LDWR,   1, &BR[1][1][0],  (Ull)b3[0], (Ull)cofs, MSK_W1, (Ull)b[0], Blen, 0, 0, (Ull)NULL, Blen);          /* stage#1 2KB */
            mop(OP_LDWR,   1, &BR[1][2][1],  (Ull)a[0][CHIP],  (Ull)rofs, MSK_W1, (Ull)a0[CHIP], Alen, 0, 0, (Ull)NULL, Alen);/* stage#1 16KB */
            exe(OP_FML, &AR[2][0], BR[1][0][1], EXP_H3210,  BR[1][2][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);/* stage#2 */
            exe(OP_FML, &AR[2][1], BR[1][0][0], EXP_H3210,  BR[1][2][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);/* stage#2 */
            exe(OP_FML, &AR[2][2], BR[1][1][1], EXP_H3210,  BR[1][2][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);/* stage#2 */
            exe(OP_FML, &AR[2][3], BR[1][1][0], EXP_H3210,  BR[1][2][1], EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);/* stage#2 */

            sgemm00_core1( 2,  1,  3);
            sgemm00_core1( 3,  2,  4);
            sgemm00_core1( 4,  3,  5);
            sgemm00_core1( 5,  4,  6);
            sgemm00_core1( 6,  5,  7);
            sgemm00_core1( 7,  6,  8);
            sgemm00_core1( 8,  7,  9);
            sgemm00_core1( 9,  8, 10);
            sgemm00_core1(10,  9, 11);
            sgemm00_core1(11, 10, 12);
            sgemm00_core1(12, 11, 13);
            sgemm00_core1(13, 12, 14);
            sgemm00_core1(14, 13, 15);
            sgemm00_core1(15, 14, 16);
            sgemm00_core1(16, 15, 17);
            sgemm00_core1(17, 16, 18);
            sgemm00_core1(18, 17, 19);
            sgemm00_core1(19, 18, 20);
            sgemm00_core1(20, 19, 21);
            sgemm00_core1(21, 20, 22);
            sgemm00_core1(22, 21, 23);
            sgemm00_core1(23, 22, 24);
            sgemm00_core1(24, 23, 25);
            sgemm00_core1(25, 24, 26);
            sgemm00_core1(26, 25, 27);
            sgemm00_core1(27, 26, 28);
            sgemm00_core1(28, 27, 29);
            sgemm00_core1(29, 28, 30);
            sgemm00_core1(30, 29, 31);
            sgemm00_core1(31, 30, 32);
            sgemm00_core1(32, 31, 33);
            sgemm00_core1(33, 32, 34);
               :
            sgemm00_core1(48, 47, 49); /* 288/6 H=48 */
            /****final*****/
            sgemm00_final(49,     51);
      } } }
//EMAX5A end
  } }
//EMAX5A drain_dirty_lmm
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\epsfile{file=imax-sgemm00-emax6.eps,width=1.00\textwidth}
\caption{Sgemm00}
\end{figure}

\clearpage

\subsection{Back\_g\_ker}

\begin{figure}[htbp]
\center
\includegraphics[angle=270,origin=b,width=0.90\textwidth]{rsim01.eps}
\caption{\label{fig:rsim01}back\_g\_ker}
\end{figure}

\begin{figure}[htbp]
\center
\includegraphics[angle=270,origin=b,width=0.90\textwidth]{rsim02.eps}
\caption{\label{fig:rsim02}back\_g\_ker}
\end{figure}

\clearpage

\begin{screen}
\tiny
\begin{verbatim}
for (oset=0; oset<((OC+OMAP-1)&~(OMAP-1)); oset+=OMAP) { /* set output channel */
  Ull  cc0[IMAP], cc1[IMAP];
  Uint inum[IMAP], *ip0[IMAP], *it0[IMAP], onum[OMAP], *op0[OMAP], *ot0[OMAP], *kp0[IMAP][OMAP];
  for (rofs=0; rofs<M; rofs++) {
    for (iset=0; iset<((IC+IMAP-1)&~(IMAP-1)); iset+=IMAP) { /* set offset of input channel */
      kidx = 0;
      for (y=-(K/2); y<K-(K/2); y++) { /* kernel loop */
        for (x=-(K/2); x<K-(K/2); x++) {
          for (ic=0; ic<IMAP; ic++) {
            inum[ic] = iset+ic;
            ip0[ic]  = &i_inp[(iset+ic)*IMX*BATCH*IMX+(rofs+y+K/2)*BATCH*IMX+(x+K/2)]; /* input */
            it0[ic]  = &i_inp[(iset+ic)*IMX*BATCH*IMX+(rofs+y+K/2)*BATCH*IMX];         /* input */
          }
          for (oc=0; oc<OMAP; oc++) {
            onum[oc] = oset+oc;
            op0[oc]  = &i_out[(oset+oc)*M*BATCH*M+rofs*BATCH*M]; /* output */
            ot0[oc]  = op0[oc];
          }
          for (ic=0; ic<IMAP; ic++) {
            for (oc=0; oc<OMAP; oc++)
              kp0[ic][oc] = ((iset+ic)<IC && (oset+oc)<OC) ? &i_ker[((oset+oc)*IC+iset+ic)*K*K+kidx] : 0; /* NULL skip DMA */
          }

#define back_g_ker_core1(b, o, i) \
  exe(OP_CMP_LT,   &cc0[o][i],onum[o], EXP_H3210,      OC,          EXP_H3210, 0LL,            EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);    /* stage#1 */\
  exe(OP_CMP_LT,   &cc1[o][i],inum[i], EXP_H3210,      IC,          EXP_H3210, 0LL,            EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);    /* stage#1 */\
  mop(OP_LDWR,  1, &BR[b][1][1],       (Ull)op0[o],    oofs,        MSK_W0,    (Ull)ot0[o],    Mlen,      0,      0,   NULL,   Mlen);   /* stage#2 */\
  mop(OP_LDWR,  1, &BR[b][2][1],       (Ull)ip0[i],    iofs,        MSK_W1,    (Ull)it0[i],    IMXlen,    0,      0,   NULL,   IMXlen); /* stage#2 */\
  exe(OP_NOP,      &AR[b][0], 0LL,     EXP_H3210,      0LL,         EXP_H3210, 0LL,            EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);    /* stage#2 (dummy) */\
  mop(OP_LDWR,  1, &b00,               (Ull)kp0[o][i], 0LL,         MSK_W0,    (Ull)kp0[o][i], 1LL,       0,      1,   NULL,   1LL);    /* stage#2 fold:unit[0] */\
  exe(OP_FMA,      &b00,      b00,     EXP_H3210,      BR[b][2][1], EXP_H3210, BR[b][1][1],    EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);    /* stage#2 */\
  cex(OP_CEXE,     &ex0, 0, 0, cc1[o][i], cc0[o][i], 0x8888);                                                                           /* stage#2 */\
  mop(OP_STWR,ex0, &b00,               (Ull)kp0[o][i], 0LL,         MSK_D0,    (Ull)kp0[o][i], 1LL,       0,      1,   NULL,   1LL)     /* stage#2 */

//EMAX5A begin back_g_ker mapdist=0
/*3*/ for (CHIP=0; CHIP<NCHIP; CHIP++) { /* output channels are parallelized by multi-chip (OC4/#chip) */
  /*2*/ for (INIT1=1,LOOP1=BATCH,img=(0-IMX4)<<32|((0-M4)&0xffffffff); LOOP1--; INIT1=0) {                           /* mapped to FOR() on BR[63][1][0] */ /* stage#0 */
    /*1*/ for (INIT0=1,LOOP0=M,cofs=(0-4LL)<<32|((0-4LL)&0xffffffff); LOOP0--; INIT0=0) {                            /* mapped to FOR() on BR[63][0][0] */ /* stage#0 */
            exe(OP_ADD,      &img,  img,             EXP_H3210,  INIT0?IMX4M4:0, EXP_H3210,  0LL, EXP_H3210, OP_NOP,   0LL,                  OP_NOP, 0LL); /* stage#0 */
            exe(OP_ADD,      &cofs, INIT0?cofs:cofs, EXP_H3210,  4LL<<32|4LL,    EXP_H3210,  0LL, EXP_H3210, OP_AND,   0xffffffffffffffffLL, OP_NOP, 0LL); /* stage#0 */
            exe(OP_ADD,      &iofs, img,             EXP_H3210,  cofs,           EXP_H3210,  0LL, EXP_H3210, OP_AND,   0xffffffff00000000LL, OP_NOP, 0LL); /* stage#1 */
            exe(OP_ADD,      &oofs, img,             EXP_H3210,  cofs,           EXP_H3210,  0LL, EXP_H3210, OP_AND,   0x00000000ffffffffLL, OP_NOP, 0LL); /* stage#1 */

            back_g_ker_core1( 2,  0,  0); /**** ic0 oc0*****/
            back_g_ker_core1( 3,  1,  0); /**** ic1 oc0*****/
            back_g_ker_core1( 4,  0,  1); /**** ic0 oc1*****/
            back_g_ker_core1( 5,  1,  1); /**** ic1 oc1*****/
            back_g_ker_core1( 6,  0,  2); /**** ic0 oc2*****/
            back_g_ker_core1( 7,  1,  2); /**** ic1 oc2*****/
            back_g_ker_core1( 8,  0,  3); /**** ic0 oc3*****/
            back_g_ker_core1( 9,  1,  3); /**** ic1 oc3*****/
            back_g_ker_core1(10,  0,  4); /**** ic0 oc4*****/
            back_g_ker_core1(11,  1,  4); /**** ic1 oc4*****/
            back_g_ker_core1(12,  0,  5); /**** ic0 oc5*****/
            back_g_ker_core1(13,  1,  5); /**** ic1 oc5*****/
            back_g_ker_core1(14,  0,  6); /**** ic0 oc6*****/
            back_g_ker_core1(15,  1,  6); /**** ic1 oc6*****/
            back_g_ker_core1(16,  0,  7); /**** ic0 oc7*****/
            back_g_ker_core1(17,  1,  7); /**** ic1 oc7*****/
      } } }
//EMAX5A end
      kidx++;
  } } } } }
//EMAX5A drain_dirty_lmm
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\epsfile{file=imax-back_g_ker-emax6.eps,width=1.00\textwidth}
\caption{Back propagation to g\_ker}
\end{figure}

\clearpage

\subsection{Back\_in}

\begin{figure}[htbp]
\center
\includegraphics[angle=270,origin=b,width=0.90\textwidth]{rsim03.eps}
\caption{\label{fig:rsim03}back\_in}
\end{figure}

\begin{figure}[htbp]
\center
\includegraphics[angle=270,origin=b,width=0.90\textwidth]{rsim04.eps}
\caption{\label{fig:rsim04}back\_in}
\end{figure}

\clearpage

\begin{screen}
\tiny
\begin{verbatim}
for (oset=0; oset<((OC+OMAP-1)&~(OMAP-1)); oset+=OMAP) { /* set output channel */
  Uint inum[IMAP], *ip0[IMAP], *it0[IMAP], onum[OMAP], *op0[OMAP], *ot0[OMAP], kp0[IMAP][OMAP];
  for (rofs=0;rofs<M;rofs++) { /*24, 10*/
    for (iset=0; iset<((IC+IMAP-1)&~(IMAP-1)); iset+=IMAP) { /* set offset of input channel */
      for (xy=0;xy<K*K;xy++) { /*5x5, 8x3x3*/
        y  = xy/K + y0;
        x  = xy%K + x0;
        Ull  yIM4  = y*IM4;
        Ull  x4    = x*4;
        Ull  IMIM4 = IM*IM4;
        if (0<=rofs+y && rofs+y<IM) {
          for (ic=0; ic<IMAP; ic++) {
            inum[ic] = iset+ic;
            ip0[ic]  = &i_inp[(iset+ic)*IM*BATCH*IM+(rofs+y)*BATCH*IM+x];
            it0[ic]  = &i_inp[(iset+ic)*IM*BATCH*IM+(rofs+y)*BATCH*IM]; // xのマイナス成分を除去
          }
          for (oc=0; oc<OMAP; oc++) {
            onum[oc] = oset+oc;
            op0[oc]  = &i_out[(oset+oc)*M*BATCH*M  +rofs*BATCH*M];
            ot0[oc]  = op0[oc];
          }
          for (ic=0; ic<IMAP; ic++) {
            for (oc=0; oc<OMAP; oc++)
              kp0[ic][oc]  = (iset+ic)<IC&&(oset+oc)<OC ? (Ull)i_ker[(oset+oc)*IC*K*K+(iset+ic)*K*K+xy] : 0; /* 0.0 */
          }

#define back_in_core1(b, bp1, i, o) \
  mop(OP_LDWR,  1, &BR[b][0][1],          (Ull)op0[o], oofs,   MSK_W1,    (Ull)ot0[o], Mlen,      0,      0,   NULL,   Mlen); /* stage#2 */\
  exe(OP_FMA,      &AR[bp1][0], AR[b][0], EXP_H3210,   kp0[i][o], EXP_H3210, BR[b][0][1], EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL)   /* stage#3 */

#define back_in_final(b, bp2, i) \
  exe(OP_ADD,      &r10,      cofs,        EXP_H3210,   x4,            EXP_H3210, 0LL,         EXP_H3210, OP_AND, 0x00ffffffffLL, OP_NOP, 0LL);   /* stage#5 */\
  exe(OP_CMP_LT,   &cc0,      r10,         EXP_H3210,   IM4,           EXP_H3210, 0LL,         EXP_H3210, OP_NOP, 0LL,            OP_NOP, 0LL);   /* stage#6 */\
  mop(OP_LDWR,  1, &BR[bp2][0][1],         (Ull)ip0[i], iofs,          MSK_W0,    (Ull)it0[i], IMlen,     0,      1,              NULL,   IMlen); /* stage#7 */\
  exe(OP_FAD,      &AR[bp2][0], AR[b][0],  EXP_H3210,   BR[bp2][0][1], EXP_H3210, 0LL,         EXP_H3210, OP_NOP, 0LL,            OP_NOP, 0LL);   /* stage#7 */\
  cex(OP_CEXE,     &ex0, 0, 0, 0, cc0, 0xaaaa);                                                                                                   /* stage#7 */\
  mop(OP_STWR,ex0, &AR[bp2][0],            iofs,        (Ull)ip0[i],   MSK_D0,    (Ull)it0[i], IMlen,     0,      1,              NULL,   IMlen)  /* stage#7 */

//EMAX5A begin back_in mapdist=0
/*3*/ for (CHIP=0; CHIP<NCHIP; CHIP++) { /* output channels are parallelized by multi-chip (OC4/#chip) */
  /*2*/ for (INIT1=1,LOOP1=BATCH,img=(0-M4)<<32|((0-IM4)&0xffffffff); LOOP1--; INIT1=0) {                      /* mapped to FOR() on BR[63][1][0] */ /* stage#0 */
    /*1*/ for (INIT0=1,LOOP0=M,cofs=(0-4LL)<<32|((0-4LL)&0xffffffff); LOOP0--; INIT0=0) {                      /* mapped to FOR() on BR[63][0][0] */ /* stage#0 */
            exe(OP_ADD,    &img,  img,             EXP_H3210,  INIT0?M4IM4:0, EXP_H3210, 0LL, EXP_H3210, OP_NOP, 0LL,                  OP_NOP, 0LL); /* stage#0 */
            exe(OP_ADD,    &cofs, INIT0?cofs:cofs, EXP_H3210,  4LL<<32|4LL,   EXP_H3210, 0LL, EXP_H3210, OP_AND, 0xffffffffffffffffLL, OP_NOP, 0LL); /* stage#0 */
            exe(OP_ADD,    &iofs, img,             EXP_H3210,  cofs,          EXP_H3210, 0LL, EXP_H3210, OP_AND, 0x00000000ffffffffLL, OP_NOP, 0LL); /* stage#1 */
            exe(OP_ADD,    &oofs, img,             EXP_H3210,  cofs,          EXP_H3210, 0LL, EXP_H3210, OP_AND, 0xffffffff00000000LL, OP_NOP, 0LL); /* stage#1 */
            /****ic0*****/
            mop(OP_LDWR,  1, &BR[2][0][1],               (Ull)op0[0], oofs,          MSK_W1,    (Ull)ot0[0], Mlen,      0,      0,   NULL,   Mlen);  /* stage#2 */
            exe(OP_FML,      &AR[3][0],    kp0[0][0],    EXP_H3210,   BR[2][0][1],   EXP_H3210, 0LL,         EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);   /* stage#3 */
            back_in_core1( 3,  4, 0,  1); /**** ic0 oc1*****/
            back_in_core1( 4,  5, 0,  2); /**** ic0 oc2*****/
            back_in_core1( 5,  6, 0,  3); /**** ic0 oc3*****/
            back_in_core1( 6,  7, 0,  4); /**** ic0 oc4*****/
            back_in_core1( 7,  8, 0,  5); /**** ic0 oc5*****/
            back_in_core1( 8,  9, 0,  6); /**** ic0 oc6*****/
            back_in_core1( 9, 10, 0,  7); /**** ic0 oc7*****/
            back_in_final(10, 12, 0);     /****OMAP( 8)+2,OMAP( 8)+4****/
            /****ic1*****/
            mop(OP_LDWR,  1, &BR[13][0][1],              (Ull)op0[0], oofs,          MSK_W1,    (Ull)ot0[0], Mlen,      0,      0,   NULL,   Mlen);  /* stage#2 */
            exe(OP_FML,      &AR[14][0],    kp0[1][0],    EXP_H3210,   BR[13][0][1], EXP_H3210, 0LL,         EXP_H3210, OP_NOP, 0LL, OP_NOP, 0LL);   /* stage#3 */
            back_in_core1(14, 15, 1,  1); /**** ic1 oc1*****/
            back_in_core1(15, 16, 1,  2); /**** ic1 oc2*****/
            back_in_core1(16, 17, 1,  3); /**** ic1 oc3*****/
            back_in_core1(17, 18, 1,  4); /**** ic1 oc4*****/
            back_in_core1(18, 19, 1,  5); /**** ic1 oc5*****/
            back_in_core1(19, 20, 1,  6); /**** ic1 oc6*****/
            back_in_core1(20, 21, 1,  7); /**** ic1 oc7*****/
            back_in_final(21, 23, 1);     /****OMAP( 8)+2,OMAP( 8)+4****/
      } } }
//EMAX5A end
  } } } } }
//EMAX5A drain_dirty_lmm
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\epsfile{file=imax-back_in-emax6.eps,width=1.00\textwidth}
\caption{Back propagation to input}
\end{figure}

\clearpage

\clearpage

\section{Crypto}

\shabox{
\leftline{cent\% make -f Makefile-csim.emax6+dma sha256-csim.emax6+dma clean}
\leftline{cent\% ../../src/csim/csim sha256-csim.emax6+dma}
}

\shabox{
\leftline{zynq\% make -f Makefile-zynq.emax6+dma sha256-zynq.emax6+dma clean}
\leftline{zynq\% ./sha256-zynq.emax6+dma}
}

\subsection{SHA256}

\begin{screen}
\tiny
\begin{verbatim}
WORD i, j, th, thm;
WORD a, b, c, d, e, f, g, h, t1, t2;
printf("<<CPU>>mbuf=%08.8x mbuflen=%08.8x\n", (Uint)mbuf, (Uint)ctx->mbuflen);
for (i=0; i<ctx->mbuflen; i+=BLKSIZE) { /* 1データ流内の並列実行は不可能. 多数データ流のパイプライン実行のみ */
  for (th=0; th<thnum; th++) {
    sregs[th*8+0] = state[th*8+0];
    sregs[th*8+1] = state[th*8+1];
    sregs[th*8+2] = state[th*8+2];
    sregs[th*8+3] = state[th*8+3];
    sregs[th*8+4] = state[th*8+4];
    sregs[th*8+5] = state[th*8+5];
    sregs[th*8+6] = state[th*8+6];
    sregs[th*8+7] = state[th*8+7];
  }
  for (j=0; j<BLKSIZE; j+=BLKSIZE/DIV) {
    for (th=0; th<thnum; th++) {
      a = sregs[th*8+0];
      b = sregs[th*8+1];
      c = sregs[th*8+2];
      d = sregs[th*8+3];
      e = sregs[th*8+4];
      f = sregs[th*8+5];
      g = sregs[th*8+6];
      h = sregs[th*8+7];
      t1 = h+EP1(e)+CH(e,f,g)+k[j+ 0]+mbuf[i/BLKSIZE*MAX_THNUM*BLKSIZE+th*BLKSIZE+j+ 0]; t2=EP0(a)+MAJ(a,b,c); h=g; g=f; f=e; e=d+t1; d=c; c=b; b=a; a=t1+t2;
      t1 = h+EP1(e)+CH(e,f,g)+k[j+ 1]+mbuf[i/BLKSIZE*MAX_THNUM*BLKSIZE+th*BLKSIZE+j+ 1]; t2=EP0(a)+MAJ(a,b,c); h=g; g=f; f=e; e=d+t1; d=c; c=b; b=a; a=t1+t2;
      t1 = h+EP1(e)+CH(e,f,g)+k[j+ 2]+mbuf[i/BLKSIZE*MAX_THNUM*BLKSIZE+th*BLKSIZE+j+ 2]; t2=EP0(a)+MAJ(a,b,c); h=g; g=f; f=e; e=d+t1; d=c; c=b; b=a; a=t1+t2;
      t1 = h+EP1(e)+CH(e,f,g)+k[j+ 3]+mbuf[i/BLKSIZE*MAX_THNUM*BLKSIZE+th*BLKSIZE+j+ 3]; t2=EP0(a)+MAJ(a,b,c); h=g; g=f; f=e; e=d+t1; d=c; c=b; b=a; a=t1+t2;
      t1 = h+EP1(e)+CH(e,f,g)+k[j+ 4]+mbuf[i/BLKSIZE*MAX_THNUM*BLKSIZE+th*BLKSIZE+j+ 4]; t2=EP0(a)+MAJ(a,b,c); h=g; g=f; f=e; e=d+t1; d=c; c=b; b=a; a=t1+t2;
      t1 = h+EP1(e)+CH(e,f,g)+k[j+ 5]+mbuf[i/BLKSIZE*MAX_THNUM*BLKSIZE+th*BLKSIZE+j+ 5]; t2=EP0(a)+MAJ(a,b,c); h=g; g=f; f=e; e=d+t1; d=c; c=b; b=a; a=t1+t2;
      t1 = h+EP1(e)+CH(e,f,g)+k[j+ 6]+mbuf[i/BLKSIZE*MAX_THNUM*BLKSIZE+th*BLKSIZE+j+ 6]; t2=EP0(a)+MAJ(a,b,c); h=g; g=f; f=e; e=d+t1; d=c; c=b; b=a; a=t1+t2;
      t1 = h+EP1(e)+CH(e,f,g)+k[j+ 7]+mbuf[i/BLKSIZE*MAX_THNUM*BLKSIZE+th*BLKSIZE+j+ 7]; t2=EP0(a)+MAJ(a,b,c); h=g; g=f; f=e; e=d+t1; d=c; c=b; b=a; a=t1+t2;
      t1 = h+EP1(e)+CH(e,f,g)+k[j+ 8]+mbuf[i/BLKSIZE*MAX_THNUM*BLKSIZE+th*BLKSIZE+j+ 8]; t2=EP0(a)+MAJ(a,b,c); h=g; g=f; f=e; e=d+t1; d=c; c=b; b=a; a=t1+t2;
      t1 = h+EP1(e)+CH(e,f,g)+k[j+ 9]+mbuf[i/BLKSIZE*MAX_THNUM*BLKSIZE+th*BLKSIZE+j+ 9]; t2=EP0(a)+MAJ(a,b,c); h=g; g=f; f=e; e=d+t1; d=c; c=b; b=a; a=t1+t2;
      t1 = h+EP1(e)+CH(e,f,g)+k[j+10]+mbuf[i/BLKSIZE*MAX_THNUM*BLKSIZE+th*BLKSIZE+j+10]; t2=EP0(a)+MAJ(a,b,c); h=g; g=f; f=e; e=d+t1; d=c; c=b; b=a; a=t1+t2;
      t1 = h+EP1(e)+CH(e,f,g)+k[j+11]+mbuf[i/BLKSIZE*MAX_THNUM*BLKSIZE+th*BLKSIZE+j+11]; t2=EP0(a)+MAJ(a,b,c); h=g; g=f; f=e; e=d+t1; d=c; c=b; b=a; a=t1+t2;
      t1 = h+EP1(e)+CH(e,f,g)+k[j+12]+mbuf[i/BLKSIZE*MAX_THNUM*BLKSIZE+th*BLKSIZE+j+12]; t2=EP0(a)+MAJ(a,b,c); h=g; g=f; f=e; e=d+t1; d=c; c=b; b=a; a=t1+t2;
      t1 = h+EP1(e)+CH(e,f,g)+k[j+13]+mbuf[i/BLKSIZE*MAX_THNUM*BLKSIZE+th*BLKSIZE+j+13]; t2=EP0(a)+MAJ(a,b,c); h=g; g=f; f=e; e=d+t1; d=c; c=b; b=a; a=t1+t2;
      t1 = h+EP1(e)+CH(e,f,g)+k[j+14]+mbuf[i/BLKSIZE*MAX_THNUM*BLKSIZE+th*BLKSIZE+j+14]; t2=EP0(a)+MAJ(a,b,c); h=g; g=f; f=e; e=d+t1; d=c; c=b; b=a; a=t1+t2;
      t1 = h+EP1(e)+CH(e,f,g)+k[j+15]+mbuf[i/BLKSIZE*MAX_THNUM*BLKSIZE+th*BLKSIZE+j+15]; t2=EP0(a)+MAJ(a,b,c); h=g; g=f; f=e; e=d+t1; d=c; c=b; b=a; a=t1+t2;
      sregs[th*8+0] = a;
      sregs[th*8+1] = b;
      sregs[th*8+2] = c;
      sregs[th*8+3] = d;
      sregs[th*8+4] = e;
      sregs[th*8+5] = f;
      sregs[th*8+6] = g;
      sregs[th*8+7] = h;
    }
  }
  for (th=0; th<thnum; th++) {
    state[th*8+0] += sregs[th*8+0];
    state[th*8+1] += sregs[th*8+1];
    state[th*8+2] += sregs[th*8+2];
    state[th*8+3] += sregs[th*8+3];
    state[th*8+4] += sregs[th*8+4];
    state[th*8+5] += sregs[th*8+5];
    state[th*8+6] += sregs[th*8+6];
    state[th*8+7] += sregs[th*8+7];
  }
}
\end{verbatim}
\end{screen}

\begin{screen}
\tiny
\begin{verbatim}
Ull  CHIP;
Ull  LOOP1, LOOP0;
Ull  INIT1, INIT0;
Ull  AR[64][4];                     /* output of EX     in each unit */
Ull  BR[64][4][4];                  /* output registers in each unit */
Ull  r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15;
Ull  r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31;
Ull  cc0, cc1, cc2, cc3, ex0, ex1;
Ull  i, j, th, thm;
Ull  a, b, c, d, d0, e, f, g, h, t1, t2;
Ull  ep0maj, ep1ch, x, y, hd, gc, fb, ea;
Ull  md, mbase, mtop, mptop, mlen=thnum==1?ctx->mbuflen:MAX_THNUM*BLKSIZE;
Ull  kd, kbase, ktop=imax_k;
Ull  sregs0 = sregs+0;
Ull  sregs2 = sregs+2;
Ull  sregs4 = sregs+4;
Ull  sregs6 = sregs+6;
printf("<<IMAX2>>mbuf=%08.8x mlen=%08.8x\n", (Uint)mbuf, (Uint)mlen);
for (i=0; i<ctx->mbuflen; i+=BLKSIZE) { /* 1データ流内の並列実行は不可能. 多数データ流のパイプライン実行のみ */
  mtop  = &mbuf[i/BLKSIZE*MAX_THNUM*BLKSIZE];
  for (th=0; th<thnum; th++) {
    *(Ull*)&sregs[th*8+0] = (Ull)state[th*8+4]<<32|state[th*8+0];
    *(Ull*)&sregs[th*8+2] = (Ull)state[th*8+5]<<32|state[th*8+1];
    *(Ull*)&sregs[th*8+4] = (Ull)state[th*8+6]<<32|state[th*8+2];
    *(Ull*)&sregs[th*8+6] = (Ull)state[th*8+7]<<32|state[th*8+3];
  }
  /*      col#3        |      col#2          |       col#1          |       col#0          */
  /*                   |    H         L      |                      |    H         L       */
  /*                   |    e        efg     |                      |    a        abc      */
  /*      d0=d         | OP_ROTS=OP_CH OP_LD |                      | OP_ROTS=OP_MAJ OP_LD */
  /*                   |    ep1      ch    k |                      |    ep0      maj    m */
  /*      hd=gc        | OP_ADD3(h+ep1+ch)   | OP_ADD(k+m)          | OP_ADD(ep0+maj)      */
  /*                   |    t1.x             |    t1.y              |    t2                */
  /* a=OP_ADD3(t2+x+y) | e=OP_ADD3(d0+x+y)   |    fb=ea             |    gc=fb             */

  /* a,b,c,d,e,f,g,h をLMM経由でctx.stateに一旦ストアし，継続実行 */
  /* state[8]を各データ流にアサインして二次元配列化.CGRAとしてパイプライン処理 */
#define sha256_core1(r, ofs) \
exe(OP_NOP,     &AR[r][0], 0,      EXP_H3210, 0,      EXP_H3210, 0,           EXP_H3210, OP_NOP,  0,                    OP_NOP, 0);\
mop(OP_LDWR, 3, &md,       mbase,  ofs,       MSK_D0, mtop,      mlen,        0, 0,      mptop,   mlen);                           \
exe(OP_MAJ,     &ep0maj,   a,      EXP_H1010, fb,     EXP_H1010, gc,          EXP_H1010, OP_ROTS, (2LL<<48)|(13LL<<40)|(22LL<<32), OP_NOP, 0);\
exe(OP_NOP,     &AR[r][2], 0,      EXP_H3210, 0,      EXP_H3210, 0,           EXP_H3210, OP_NOP,  0,                    OP_NOP, 0);\
mop(OP_LDWR, 3, &kd,       kbase,  ofs,       MSK_D0, ktop,      64,          0, 0,      NULL,    64);                             \
exe(OP_CH,      &ep1ch,    e,      EXP_H3232, fb,     EXP_H3232, gc,          EXP_H3232, OP_ROTS, (6LL<<48)|(11LL<<40)|(25LL<<32), OP_NOP, 0);\
exe(OP_NOP,     &d0,       hd,     EXP_H1010, 0,      EXP_H3210, 0,           EXP_H3210, OP_AND,  0xffffffff00000000LL, OP_NOP, 0);\
exe(OP_ADD,     &t2,       ep0maj, EXP_H3232, ep0maj, EXP_H1010, 0,           EXP_H3210, OP_AND,  0x00000000ffffffffLL, OP_NOP, 0);\
exe(OP_ADD,     &y,        kd,     EXP_H3210, md,     EXP_H3210, 0,           EXP_H3210, OP_AND,  0x00000000ffffffffLL, OP_NOP, 0);\
exe(OP_ADD3,    &x,        hd,     EXP_H3232, ep1ch,  EXP_H3232, ep1ch,       EXP_H1010, OP_AND,  0x00000000ffffffffLL, OP_NOP, 0);\
exe(OP_NOP,     &hd,       gc,     EXP_H3210, 0,      EXP_H3210, 0,           EXP_H3210, OP_OR,   0,                    OP_NOP, 0);\
exe(OP_NOP,     &gc,       fb,     EXP_H3210, 0,      EXP_H3210, 0,           EXP_H3210, OP_OR,   0,                    OP_NOP, 0);\
exe(OP_NOP,     &fb,       e,      EXP_H3210, 0,      EXP_H3210, 0,           EXP_H3210, OP_OR,   a,                    OP_NOP, 0);\
exe(OP_ADD3,    &a,        t2,     EXP_H3210, x,      EXP_H1010, y,           EXP_H1010, OP_AND,  0x00000000ffffffffLL, OP_NOP, 0);\
exe(OP_ADD3,    &e,        d0,     EXP_H3210, x,      EXP_H1010, y,           EXP_H1010, OP_AND,  0xffffffff00000000LL, OP_NOP, 0)

#define sha256_final(r) \
exe(OP_NOP,    &ea,        e,      EXP_H3210, 0,      EXP_H3210, 0,           EXP_H3210, OP_OR,   a,                    OP_NOP, 0);\
mop(OP_STR, 3, &ea,        sregs0, th,        MSK_W0, sregs,     MAX_THNUM*8, 0, 0,      NULL,    MAX_THNUM*8);                    \
exe(OP_NOP,    &AR[r][1],  0,      EXP_H3210, 0,      EXP_H3210, 0,           EXP_H3210, OP_NOP,  0,                    OP_NOP, 0);\
mop(OP_STR, 3, &fb,        sregs2, th,        MSK_W0, sregs,     MAX_THNUM*8, 0, 0,      NULL,    MAX_THNUM*8);                    \
exe(OP_NOP,    &AR[r][2],  0,      EXP_H3210, 0,      EXP_H3210, 0,           EXP_H3210, OP_NOP,  0,                    OP_NOP, 0);\
mop(OP_STR, 3, &gc,        sregs4, th,        MSK_W0, sregs,     MAX_THNUM*8, 0, 0,      NULL,    MAX_THNUM*8);                    \
exe(OP_NOP,    &AR[r][3],  0,      EXP_H3210, 0,      EXP_H3210, 0,           EXP_H3210, OP_NOP,  0,                    OP_NOP, 0);\
mop(OP_STR, 3, &hd,        sregs6, th,        MSK_W0, sregs,     MAX_THNUM*8, 0, 0,      NULL,    MAX_THNUM*8)

  for (INIT1=1,LOOP1=DIV,j=0; LOOP1--; INIT1=0,j+=BLKSIZE/DIV*4) {
    mptop = (LOOP1==0)? mtop+MAX_THNUM*BLKSIZE*4:mtop; /* 最終回のみPLOAD */
//with-prefetch
//EMAX5A begin imax mapdist=0
 /*3*/for (CHIP=0; CHIP<NCHIP; CHIP++) {
 /*1*/for (INIT0=1,LOOP0=thnum,th=(0-BLKSIZE*4)<<32|((0-32LL)&0xffffffff); LOOP0--; INIT0=0) {
        exe(OP_ADD,    &th,     INIT0?th:th, EXP_H3210, (BLKSIZE*4)<<32|32LL,  EXP_H3210, 0, EXP_H3210, OP_AND, 0xffffffffffffffffLL, OP_NOP, 0); /* stage#0 */
        exe(OP_NOP,    &thm,    th,          EXP_H3232, 0,                     EXP_H3210, 0, EXP_H3210, OP_AND, 0x00000000ffffffffLL, OP_NOP, 0); /* stage#1 */
        exe(OP_ADD3,   &mbase,  mtop,        EXP_H3210, thm,                   EXP_H3210, j, EXP_H3210, OP_NOP, 0,                    OP_NOP, 0); /* stage#2 */
        mop(OP_LDR, 3, &a,      sregs0, th,  MSK_W0,    sregs, MAX_THNUM*8, 0, 1, NULL,  MAX_THNUM*8); /* stage#2 */
        mop(OP_LDR, 3, &e,      sregs0, th,  MSK_W0,    sregs, MAX_THNUM*8, 0, 1, NULL,  MAX_THNUM*8); /* stage#2 */
        exe(OP_ADD3,   &kbase,  imax_k,      EXP_H3210, 0,                     EXP_H3210, j, EXP_H3210, OP_NOP, 0,                    OP_NOP, 0); /* stage#2 */
        mop(OP_LDR, 3, &fb,     sregs2, th,  MSK_W0,    sregs, MAX_THNUM*8, 0, 1, NULL,  MAX_THNUM*8); /* stage#2 */
        mop(OP_LDR, 3, &gc,     sregs4, th,  MSK_W0,    sregs, MAX_THNUM*8, 0, 1, NULL,  MAX_THNUM*8); /* stage#2 */
        mop(OP_LDR, 3, &hd,     sregs6, th,  MSK_W0,    sregs, MAX_THNUM*8, 0, 1, NULL,  MAX_THNUM*8); /* stage#2 */
        sha256_core1( 3,  0);
        sha256_core1( 6,  4);
        sha256_core1( 9,  8);
        sha256_core1(12, 12);
        sha256_core1(15, 16);
        sha256_core1(18, 20);
        sha256_core1(21, 24);
        sha256_core1(24, 28);
        sha256_core1(27, 32);
        sha256_core1(30, 36);
        sha256_core1(33, 40);
        sha256_core1(36, 44);
        sha256_core1(39, 48);
        sha256_core1(42, 52);
        sha256_core1(45, 56);
        sha256_core1(48, 60);
        sha256_final(51);
      }
    }
//EMAX5A end
  }
//EMAX5A drain_dirty_lmm
  for (th=0; th<thnum; th++) {
    state[th*8+0] += sregs[th*8+0];
    state[th*8+1] += sregs[th*8+2];
    state[th*8+2] += sregs[th*8+4];
    state[th*8+3] += sregs[th*8+6];
    state[th*8+4] += sregs[th*8+1];
    state[th*8+5] += sregs[th*8+3];
    state[th*8+6] += sregs[th*8+5];
    state[th*8+7] += sregs[th*8+7];
  }
}
\end{verbatim}
\end{screen}

\begin{figure}[htbp]
\center
\epsfile{file=sha256-imax-emax6.eps,width=1.00\textwidth}
\caption{SHA256}
\end{figure}

%%
